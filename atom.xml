<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>木子</title>
  <icon>https://blog.k8s.li/icon.png</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.k8s.li/"/>
  <updated>2021-02-15T16:00:00.000Z</updated>
  <id>https://blog.k8s.li/</id>
  
  <author>
    <name>木子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>同步 docker hub library 镜像到本地 registry</title>
    <link href="https://blog.k8s.li/sync-dockerhub-library-images.html"/>
    <id>https://blog.k8s.li/sync-dockerhub-library-images.html</id>
    <published>2021-02-09T16:00:00.000Z</published>
    <updated>2021-02-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="恰烂钱？"><a href="#恰烂钱？" class="headerlink" title="恰烂钱？"></a>恰烂钱？</h2><p>自从去年 11 月份开始，docker 公司为了恰点烂钱就对 docker hub 上 pull 镜像的策略进行限制：</p><ul><li><strong>未登录用户，每 6 小时只允许 pull 100 次</strong></li><li><strong>已登录用户，每 6 小时只允许 pull 200 次</strong></li></ul><p>而且，限制的手段也非常地粗暴，通过判断请求镜像的 manifest 文件的次数，请求一个镜像的 manifest 文件就算作一次 pull 镜像。即便你 pull 失败了，也会算作一次。</p><p>随后也有很多大佬分享绕过 docker hub 限制的办法，比如搭建私有的镜像仓库，然后再给客户端配置上 <code>registry-mirrors</code> 参数，就可以通过本地的镜像仓库来拉取镜像。</p><ul><li><a href="https://moelove.info/2020/09/20/%E7%AA%81%E7%A0%B4-DockerHub-%E9%99%90%E5%88%B6%E5%85%A8%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E6%9C%8D%E5%8A%A1/" target="_blank" rel="noopener">突破 DockerHub 限制，全镜像加速服务</a></li><li><a href="https://nova.moe/bypass-docker-hub-429/" target="_blank" rel="noopener">绕过从 Docker Hub pull 镜像时的 429 toomanyrequests</a></li><li><a href="https://www.chenshaowen.com/blog/how-to-cross-the-limit-of-dockerhub.html" target="_blank" rel="noopener">如何绕过 DockerHub 拉取镜像限制</a></li></ul><p>但是呢，以上方法都比较局限：首先镜像需要挨个手动 push 到本地镜像仓库；其次本地镜像仓库中的镜像无法和官方镜像保持同步更新，如果要使用新的 tag 好的镜像仍然需要手动将镜像从 docker hub 上 pull 下来，然后再 push 到本地镜像仓库；还有手动 push 镜像是比较混乱的，如果使用的镜像比较多，比如公有云容器服务，这时候再手动 push 的话管理起来是及其不方便的。</p><p>因此经过一番折腾终于摸索出了一个方案：将 docker hub 上 library repo 的镜像同步到本地镜像仓库，最终要做到上游如果更新了镜像 tag 也能自动地将镜像同步到本地镜像仓库。</p><h2 id="获取镜像-tag"><a href="#获取镜像-tag" class="headerlink" title="获取镜像 tag"></a>获取镜像 tag</h2><p>对于 docker hub 上的镜像，我们使用到最多的就是 library 这个 repo 即 <a href="https://docs.docker.com/docker-hub/official_images/" target="_blank" rel="noopener">Official Images on Docker Hub</a>，里面包含着大部分开源软件和 Linux 发行版的基础镜像。</p><blockquote><ul><li>Provide essential base OS repositories (for example, <a href="https://hub.docker.com/_/ubuntu/" target="_blank" rel="noopener">ubuntu</a>, <a href="https://hub.docker.com/_/centos/" target="_blank" rel="noopener">centos</a>) that serve as the starting point for the majority of users.</li><li>Provide drop-in solutions for popular programming language runtimes, data stores, and other services, similar to what a Platform as a Service (PAAS) would offer.</li><li>Exemplify <a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener"><code>Dockerfile</code> best practices</a> and provide clear documentation to serve as a reference for other <code>Dockerfile</code> authors.</li><li>Ensure that security updates are applied in a timely manner. This is particularly important as Official Images are some of the most popular on Docker Hub.</li></ul></blockquote><p>library 的镜像常见的特点就是当我们使用 docker 客户端去 pull 一个镜像时，无需指定该镜像的 repo ，比如 <code>ubuntu:latest</code>，其他非 library 的镜像需要指定镜像所属的 repo ，比如 <code>jenkins/slave:latest</code>。这部分代码是硬编码在 docker 的源码当中的。</p><blockquote><p>我们虽然日常访问的是 <code>https://hub.docker.com</code> ，但是我们在 <a href="https://github.com/docker/distribution/blob/master/reference/normalize.go#L13" target="_blank" rel="noopener">https://github.com/docker/distribution/blob/master/reference/normalize.go#L13</a> 中可以看到实际 <code>docker</code> 使用的地址是一个硬编码的 <code>docker.io</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">legacyDefaultDomain = <span class="string">"index.docker.io"</span></span><br><span class="line">defaultDomain       = <span class="string">"docker.io"</span></span><br><span class="line">officialRepoName    = <span class="string">"library"</span></span><br><span class="line">defaultTag          = <span class="string">"latest"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></blockquote><p>我们可以通过如下几种办法来获取 docker hub 上 library repo 的镜像列表。</p><h3 id="通过-docker-registry-命令行"><a href="#通过-docker-registry-命令行" class="headerlink" title="通过 docker registry 命令行"></a>通过 docker registry 命令行</h3><p>在 docker 官方文档中 <a href="https://docs.docker.com/engine/reference/commandline/registry/" target="_blank" rel="noopener">docker registry</a> 有提到可以列出某个 registry 中的镜像，但这个功能仅限于 <a href="https://docs.docker.com/ee/supported-platforms/" target="_blank" rel="noopener">Docker Enterprise Edition.</a> 版本，而社区的版本中未有该命令。遂放弃……</p><blockquote><p>This command is only available on Docker Enterprise Edition.</p><p>Learn more about <a href="https://docs.docker.com/ee/supported-platforms/" target="_blank" rel="noopener">Docker Enterprise products</a>.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker registry ls <span class="comment"># List registry images</span></span><br></pre></td></tr></table></figure><h3 id="通过-registry-v2-API"><a href="#通过-registry-v2-API" class="headerlink" title="通过 registry v2 API"></a>通过 registry v2 API</h3><ul><li><code>get-images.list</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -eo pipefail</span><br><span class="line"></span><br><span class="line">DOCKER_HUB_URL=<span class="string">"https://hub.docker.com/v2/repositories/library"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_images_list</span></span>() &#123;</span><br><span class="line">    ALL_IMAGES=<span class="string">""</span></span><br><span class="line">    URL=<span class="string">"<span class="variable">$&#123;DOCKER_HUB_URL&#125;</span>/?page_size=100"</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> ; <span class="keyword">do</span></span><br><span class="line">        ALL_IMAGES=<span class="string">"<span class="variable">$(curl -sSL $&#123;URL&#125; | jq -r '.results[].name' | tr '\n' ' ')</span> <span class="variable">$&#123;ALL_IMAGES&#125;</span>"</span></span><br><span class="line">        URL=<span class="string">"<span class="variable">$(curl -sSL $&#123;URL&#125; | jq -r '.next')</span>"</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;URL&#125;</span>"</span> = <span class="string">"null"</span> ]; <span class="keyword">then</span> <span class="built_in">break</span>; <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    : &gt; all_library_images.list</span><br><span class="line">    <span class="keyword">for</span> image <span class="keyword">in</span> <span class="variable">$&#123;ALL_IMAGES&#125;</span>;<span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> skopeo list-tags docker://<span class="variable">$&#123;image&#125;</span> &amp;&gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">            skopeo list-tags docker://<span class="variable">$&#123;image&#125;</span> | jq <span class="string">".Tags"</span> | tr -d <span class="string">'[],\" '</span> | tr -s <span class="string">'\n'</span> | sed <span class="string">"s|^|<span class="variable">$&#123;image&#125;</span>:|g"</span> &gt;&gt; all_library_images.list</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line">get_images_list</span><br></pre></td></tr></table></figure><p>通过 docker hub 的  API 获取到的镜像 tag 实在是太多了，截至今日 docker hub 上整个 <a href="https://hub.docker.com/u/library" target="_blank" rel="noopener">library repo</a> 的项目一共有 162 个，而这 162 个项目中的镜像 tag 数量多达<strong>五万两千</strong>多个。总的镜像仓库存储占用空间的大小预计至少 5TB 。其中的镜像我们真正需要用到的估计也不到 <strong>0.1%</strong>，因此需要想个办法减少这个镜像列表的数量，获得的镜像列表更精确一些，通用一些。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /opt/official-images ‹sync*›</span><br><span class="line">╰─<span class="comment"># cat all_library_images.list|cut -d ':' -f1 | sort -u | wc</span></span><br><span class="line">    162     162    1353</span><br><span class="line">╭─root@sg-02 /opt/official-images ‹sync*›</span><br><span class="line">╰─<span class="comment"># cat all_library_images.list | wc</span></span><br><span class="line">  52094   52094 1193973</span><br></pre></td></tr></table></figure><h3 id="通过-official-images-repo"><a href="#通过-official-images-repo" class="headerlink" title="通过 official-images repo"></a>通过 official-images repo</h3><p>以 <a href="https://hub.docker.com/_/debian" target="_blank" rel="noopener">debian</a> 为例，在 docker hub 上镜像的 tag 基本上都是这样子的：</p><blockquote><p><strong>Supported tags and respective <code>Dockerfile</code> links</strong></p><ul><li><a href="https://github.com/debuerreotype/docker-debian-artifacts/blob/b05117a87fbd32f977b4909e399fe368c75767ad/bullseye/Dockerfile" target="_blank" rel="noopener"><code>bullseye</code>, <code>bullseye-20210208</code></a></li><li><a href="https://github.com/debuerreotype/docker-debian-artifacts/blob/b05117a87fbd32f977b4909e399fe368c75767ad/bullseye/backports/Dockerfile" target="_blank" rel="noopener"><code>bullseye-backports</code></a></li><li><a href="https://github.com/debuerreotype/docker-debian-artifacts/blob/b05117a87fbd32f977b4909e399fe368c75767ad/bullseye/slim/Dockerfile" target="_blank" rel="noopener"><code>bullseye-slim</code>, <code>bullseye-20210208-slim</code></a></li><li><a href="https://github.com/debuerreotype/docker-debian-artifacts/blob/b05117a87fbd32f977b4909e399fe368c75767ad/buster/Dockerfile" target="_blank" rel="noopener"><code>buster</code>, <code>buster-20210208</code>, <code>10.8</code>, <code>10</code>, <code>latest</code></a></li><li><a href="https://github.com/debuerreotype/docker-debian-artifacts/blob/b05117a87fbd32f977b4909e399fe368c75767ad/buster/backports/Dockerfile" target="_blank" rel="noopener"><code>buster-backports</code></a></li><li><a href="https://github.com/debuerreotype/docker-debian-artifacts/blob/b05117a87fbd32f977b4909e399fe368c75767ad/buster/slim/Dockerfile" target="_blank" rel="noopener"><code>buster-slim</code>, <code>buster-20210208-slim</code>, <code>10.8-slim</code>, <code>10-slim</code></a></li><li><a href="https://github.com/debuerreotype/docker-debian-artifacts/blob/b05117a87fbd32f977b4909e399fe368c75767ad/experimental/Dockerfile" target="_blank" rel="noopener"><code>experimental</code>, <code>experimental-20210208</code></a></li><li><a href="https://github.com/debuerreotype/docker-debian-artifacts/blob/b05117a87fbd32f977b4909e399fe368c75767ad/jessie/Dockerfile" target="_blank" rel="noopener"><code>jessie</code>, <code>jessie-20210208</code>, <code>8.11</code>, <code>8</code></a></li><li><a href="https://github.com/debuerreotype/docker-debian-artifacts/blob/b05117a87fbd32f977b4909e399fe368c75767ad/jessie/slim/Dockerfile" target="_blank" rel="noopener"><code>jessie-slim</code>, <code>jessie-20210208-slim</code>, <code>8.11-slim</code>, <code>8-slim</code></a></li></ul></blockquote><p>每一行都代表着同一个镜像，如： <a href="https://github.com/debuerreotype/docker-debian-artifacts/blob/b05117a87fbd32f977b4909e399fe368c75767ad/buster/Dockerfile" target="_blank" rel="noopener"><code>buster</code>, <code>buster-20210208</code>, <code>10.8</code>, <code>10</code>, <code>latest</code></a> 。一行中镜像虽然有多个 tag，但这些 tag 指向的 manifest 其实都是一致的。镜像 tag 的关系有点类似于 C 语言里的指针变量，是引用的关系。</p><p>但这么多的信息是如何高效地管理的呢？于是顺藤摸瓜发现了：由于 library repo 里的镜像构建信息都是由 <a href="https://github.com/docker-library/official-images" target="_blank" rel="noopener">official-images</a> 这个 repo 来管理的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># buster -- Debian 10.8 Released 06 February 2021</span></span><br><span class="line">Tags: buster, buster-20210208, 10.8, 10, latest</span><br><span class="line">Architectures: amd64, arm32v5, arm32v7, arm64v8, i386, mips64le, ppc64le, s390x</span><br><span class="line">Directory: buster</span><br><span class="line"></span><br><span class="line">Tags: buster-backports</span><br><span class="line">Architectures: amd64, arm32v5, arm32v7, arm64v8, i386, mips64le, ppc64le, s390x</span><br><span class="line">Directory: buster/backports</span><br><span class="line"></span><br><span class="line">Tags: buster-slim, buster-20210208-slim, 10.8-slim, 10-slim</span><br><span class="line">Architectures: amd64, arm32v5, arm32v7, arm64v8, i386, mips64le, ppc64le, s390x</span><br><span class="line">Directory: buster/slim</span><br></pre></td></tr></table></figure><p>在这个 <a href="https://github.com/docker-library/official-images" target="_blank" rel="noopener">official-images</a>  repo 里  library 目录下有以镜像 name 命名的文件，而文件的内容正是记录着与 docker hub 相对应的 tag 信息。由此我们可以根据这个 repo 获取 library repo 镜像的 tag。好处在于虽然这样得到的镜像列表并不是全面的，但这个 repo 里记录的镜像 tag 都是官方还在维护的，并不会包含一些旧的或者 CI 测试的镜像。这样获得的镜像列表更通用一些。</p><p>拿出 Linux 文本处理三剑客，一顿操作搓出了个脚本来生成镜像以及镜像的数量。惊奇的发现，通过这种方式获取到的镜像数量为 docker hub 的 registry API 获取到的镜像数量的十分之一左右。根据如下数据可以得出，docker hub 真实需要的镜像数量为 1517 个，而 5590 个镜像中包含了多个 tag 指向同一个镜像的情况，因此，我们只需要将这些相同镜像的 tag pull 一次即可，其余的镜像通过 retag 的方式打上 tag 即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取镜像列表</span></span><br><span class="line">$ grep -Er <span class="string">"^Tags:|^SharedTags:"</span> library | sed <span class="string">'s|library/||g;s|:Tags||g;s|:SharedTags||g;s| ||g'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取镜像数量，也就是 manifests 的数量</span></span><br><span class="line">$ grep -Er <span class="string">"^Tags:|^SharedTags:"</span> library | sed <span class="string">'s|library/||g;s|:Tags||g;s|:SharedTags||g;s| ||g'</span> | wc</span><br><span class="line">   1518    1518   95999</span><br><span class="line"><span class="comment"># 获取所有镜像 tag 数量，包含了所有的 tag</span></span><br><span class="line">$ grep -Er <span class="string">"^Tags:|^SharedTags:"</span> library | sed <span class="string">'s|library/||g;s|:Tags||g;s|:SharedTags||g;s| ||g'</span> | tr <span class="string">','</span> <span class="string">'\n'</span> | wc</span><br><span class="line">   5590    5590   95999</span><br></pre></td></tr></table></figure><h2 id="本地同步镜像"><a href="#本地同步镜像" class="headerlink" title="本地同步镜像"></a>本地同步镜像</h2><p>获取到镜像列表之后，我们就可用使用 <a href="https://github.com/containers/skopeo/blob/master/docs/skopeo-copy.1.md" target="_blank" rel="noopener">skopeo copy</a> 直接将镜像 copy 到本地的镜像仓库中啦。结合上述步骤，使用不到 20 行的脚本就能完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ALL_IMAGES=$(grep -Er <span class="string">"^Tags:|^SharedTags:"</span> library \</span><br><span class="line">| sed <span class="string">'s|library/||g;s|:Tags||g;s|:SharedTags||g;s| ||g'</span>)</span><br><span class="line">IFS=$<span class="string">'\n'</span></span><br><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> <span class="variable">$&#123;ALL_IMAGES&#125;</span>; <span class="keyword">do</span></span><br><span class="line">    name=<span class="string">"<span class="variable">$(echo $&#123;image&#125; | cut -d ':' -f1)</span>"</span></span><br><span class="line">    tags=<span class="string">"<span class="variable">$(echo $&#123;image&#125; | cut -d ':' -f2 | cut -d ',' -f1)</span>"</span></span><br><span class="line">    <span class="keyword">if</span> skopeo copy docker://<span class="variable">$&#123;name&#125;</span>:<span class="variable">$&#123;tags&#125;</span> docker://registry.local/library/<span class="variable">$&#123;name&#125;</span>:<span class="variable">$&#123;tags&#125;</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">for</span> tag <span class="keyword">in</span> $(<span class="built_in">echo</span> <span class="variable">$&#123;image&#125;</span> | cut -d <span class="string">':'</span> -f2 | tr <span class="string">','</span> <span class="string">'\n'</span>); <span class="keyword">do</span></span><br><span class="line">        skopeo copy docker://<span class="variable">$&#123;name&#125;</span>:<span class="variable">$&#123;tag&#125;</span> docker://registry.local/library/<span class="variable">$&#123;name&#125;</span>:<span class="variable">$&#123;tags&#125;</span>;</span><br><span class="line">     <span class="keyword">done</span></span><br><span class="line">     <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>但，没我想象中的那么简单，在自己的机器上 pull 了不到 150 个镜像的时候就报错退出了，提示 <code>toomanyrequests: You have reached your pull rate limit.</code> 错误。心里 mmp，docker inc 啊，干啥啥不行（如今 Docker Machine，Docker Swarm，docker-compose 三驾马车哪儿去了？），<strong>恰烂钱可还行</strong>😡。</p><blockquote><p>ime=”2021-02-12T07:08:51Z” level=fatal msg=”Error parsing image name &quot;docker://ubuntu:latest&quot;:</p><p>Error reading manifest latest in docker.io/library/ubuntu: toomanyrequests: You have reached your pull rate limit. You may increase the limit by authenticating and upgrading: <a href="https://www.docker.com/increase-rate-limit&quot;" target="_blank" rel="noopener">https://www.docker.com/increase-rate-limit&quot;</a></p></blockquote><h2 id="Dockerfile-里同步镜像？"><a href="#Dockerfile-里同步镜像？" class="headerlink" title="Dockerfile 里同步镜像？"></a>Dockerfile 里同步镜像？</h2><p>既然在本地有 pull 次数的限制，那什么地方不会有这种限制呢？首先想到的是 docker hub 上 build 镜像肯定不会限制吧。应该是的……。不如在 Dockerfile 里塞一个脚本，用它来同步镜像如何？于是一顿操作猛如虎，不一会儿就搓出来个 Dockerfile。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:unstable-slim</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -xue ;\</span></span><br><span class="line"><span class="bash">    apt update -y ;\</span></span><br><span class="line"><span class="bash">    apt install ca-certificates skopeo git curl jq -y --no-install-recommends ;\</span></span><br><span class="line"><span class="bash">    rm -rf /var/lib/apt/lists/* ;\</span></span><br><span class="line"><span class="bash">    git <span class="built_in">clone</span> -b sync https://github.com/muzi502/official-images /build</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -xue ;\</span></span><br><span class="line"><span class="bash">    skopeo login hub.k8s.li -u admin -p Harbor123456 ;\</span></span><br><span class="line"><span class="bash">    bash /build/sync-images.sh</span></span><br></pre></td></tr></table></figure><p>然……事实证明是我太天真了，在同步了不到 100 多个镜像后，同样也出现了 429 toomanyrequests 的限制。掀桌儿！在 docker hub 上构建镜像，也会被限制？自己限制自己？？这什么鸡儿玩意。</p><p><del>假如有一个多阶段构建的 Dockerfile，就有可能因为拉不到镜像而导致镜像构建失败。那么这种智障的设计没想到过？</del></p><p>想到一种可能是 docker hub 内部是通过 token 来进行验证的，而不是根据客户端访问源 IP 。build 镜像的宿主机上会有 docker login 的 token 文件，但 build 镜像的容器里是没有这个 token 文件的，所以在 dockerfile 里 pull 镜像同样会被限制。看来 dockerfile 里同步镜像的方案也就不行了🙃，只能另寻他路啦。</p><h2 id="GitHub-Action-来同步镜像"><a href="#GitHub-Action-来同步镜像" class="headerlink" title="GitHub Action 来同步镜像"></a>GitHub Action 来同步镜像</h2><h3 id="ssh-连接-runner"><a href="#ssh-连接-runner" class="headerlink" title="ssh 连接 runner"></a>ssh 连接 runner</h3><p>在刚开始写这篇博客的时候也没有想到使用 GitHub Action，在刷 GitHub 动态的时候无意间发现了它。于是又一顿操作看看 GitHub Action 是否能用来同步镜像。</p><p>首先参考 <a href="https://p3terx.com/archives/ssh-to-the-github-actions-virtual-server-environment.html" target="_blank" rel="noopener">SSH 连接到 GitHub Actions 虚拟服务器</a> 连接到 runner 的机器上:</p><ul><li><code>.github/workflows/ssh.yaml</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Ubuntu</span></span><br><span class="line"><span class="attr">on:</span> <span class="string">push</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-20.04</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">tmate</span> <span class="string">session</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">mxschmitt/action-tmate@v1</span></span><br></pre></td></tr></table></figure><p>使用 ssh 连接到 action runner 的机器里意外发现，在 <code>~/.docker/config.json</code> 文件里竟然已经有了个 login 的 docker hub 账户。<code>哦豁.jpg</code>。由于 docker login 的配置文件只是简单的 base64 加密，解码后拿到真实的 user 和 token。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">runner@fv-az60-303:~$ cat .docker/config.json</span><br><span class="line">&#123;</span><br><span class="line">        "auths": &#123;</span><br><span class="line">                "https://index.docker.io/v1/": &#123;</span><br><span class="line">                        "auth": "Z2l0aHViYWN0aW9uczozZDY0NzJiOS0zZDQ5LTRkMTctOWZjOS05MGQyNDI1ODA0M2I="</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;runner@fv-az60-303:~$ echo "Z2l0aHViYWN0aW9uczozZDY0NzJiOS0zZDQ5LTRkMTctOWZjOS05MGQyNDI1ODA0M2I=" | base64 -d</span><br><span class="line">githubactions:3d6472b9-3d49-4d17-9fc9-90d24258043b</span><br></pre></td></tr></table></figure><p><img src="img/image-20210216173039196.png" alt="image-20210216173039196"></p><p>于是想着可以验证一下这个账户是否有限制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --user <span class="string">'githubactions:3d6472b9-3d49-4d17-9fc9-90d24258043'</span> <span class="string">"https://auth.docker.io/token?service=registry.docker.io&amp;scope=repository:ratelimitpreview/test:pull"</span></span><br></pre></td></tr></table></figure><p>但失败了，提示 <code>{&quot;details&quot;:&quot;incorrect username or password&quot;}</code> ，估计这个账户是个 bot 账户，只能用于 pull 镜像，其他的 api 请求都没权限使用。至于这个账户有没有限制，还需要做下测试。</p><p>另外意外地发现 runner 的机器里集成了很多工具，其中  skopeo 也包含在内，实在是太方便了。GitHub 牛皮，微软爸爸我爱你😘！那就方便了，我们就使用 skopeo inspect 去请求镜像的 manifests 文件。看看最多能请求多少会被限制。于是花了点时间搓了个脚本用于去获取 docker hub 上 library repo 中的所有镜像的 manifests 文件。</p><ul><li><code>get-manifests.sh</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -eo pipefail</span><br><span class="line"></span><br><span class="line">DOCKER_HUB_URL=<span class="string">"https://hub.docker.com/v2/repositories/library"</span></span><br><span class="line">IMAGES_LIST=<span class="string">"images.list"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_images_list</span></span>() &#123;</span><br><span class="line">    ALL_IMAGES=<span class="string">""</span></span><br><span class="line">    URL=<span class="string">"<span class="variable">$&#123;DOCKER_HUB_URL&#125;</span>/?page_size=100"</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> ; <span class="keyword">do</span></span><br><span class="line">        ALL_IMAGES=<span class="string">"<span class="variable">$(curl -sSL $&#123;URL&#125; | jq -r '.results[].name' | tr '\n' ' ')</span> <span class="variable">$&#123;ALL_IMAGES&#125;</span>"</span></span><br><span class="line">        URL=<span class="string">"<span class="variable">$(curl -sSL $&#123;URL&#125; | jq -r '.next')</span>"</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;URL&#125;</span>"</span> = <span class="string">"null"</span> ]; <span class="keyword">then</span> <span class="built_in">break</span>; <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    : &gt; <span class="variable">$&#123;IMAGES_LIST&#125;</span></span><br><span class="line">    <span class="keyword">for</span> image <span class="keyword">in</span> <span class="variable">$&#123;ALL_IMAGES&#125;</span>;<span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> skopeo list-tags docker://<span class="variable">$&#123;image&#125;</span> &amp;&gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">            skopeo list-tags docker://<span class="variable">$&#123;image&#125;</span> | jq -c <span class="string">".Tags"</span> | tr -d <span class="string">'[]\"'</span> \</span><br><span class="line">            | tr <span class="string">','</span> <span class="string">'\n'</span> | sed <span class="string">"s|^|<span class="variable">$&#123;image&#125;</span>:|g"</span> &gt;&gt; <span class="variable">$&#123;IMAGES_LIST&#125;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_manifests</span></span>() &#123;</span><br><span class="line">    mkdir -p manifests</span><br><span class="line">    IFS=$<span class="string">'\n'</span></span><br><span class="line">    <span class="keyword">for</span> image <span class="keyword">in</span> $(cat <span class="variable">$&#123;IMAGES_LIST&#125;</span>); <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> skopeo inspect --raw docker://<span class="variable">$&#123;image&#125;</span> | jq  -r <span class="string">'.manifests[].digest'</span> &amp;&gt; /dev/null ; <span class="keyword">then</span></span><br><span class="line">            skopeo inspect --raw docker://<span class="variable">$&#123;image&#125;</span> | jq  -r <span class="string">'.manifests[].digest'</span> \</span><br><span class="line">            |  xargs -L1 -P8 -I % sh -c <span class="string">"skopeo inspect --raw docker://<span class="variable">$&#123;image/:*/&#125;</span>@% &gt; manifests/<span class="variable">$&#123;image&#125;</span>@%.json"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            skopeo inspect --raw docker://<span class="variable">$&#123;image&#125;</span> &gt; manifests/<span class="variable">$&#123;image&#125;</span>.json</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get_images_list</span><br><span class="line">get_manifests</span><br></pre></td></tr></table></figure><p>经过一番长时间的刺测试，在获取了 20058   个镜像的 manifest 文件之后依旧没有被限制，于是大胆猜测，runner 里内置的 docker hub 账户 pull library 镜像是没有限制的。估计是 GitHub 和 docker inc 达成了  py 交易，用这个账户去 pull 公共镜像没有限制。</p><p><img src="img/image-20210216173003436.png" alt="image-20210216173003436"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runner@fv-az212-267:~/work/runner-test/runner-test$ ls manifests/ | wc</span><br><span class="line">  20058   20058 1875861</span><br></pre></td></tr></table></figure><h3 id="定时同步镜像"><a href="#定时同步镜像" class="headerlink" title="定时同步镜像"></a>定时同步镜像</h3><p>从上述步骤一可知在 GitHub Action runner 机器里自带的 docker login 账户是没有限制，那我们最终就选定使用它来同步镜像到本地 registry 吧。参照 GitHub Action 照葫芦画瓢搓了个 action 的配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">sync-images</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sync</span></span><br><span class="line">  <span class="comment"># 设置定时任务，每 6 小时运行一次</span></span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cron:</span> <span class="string">"* */6 * * *"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">sync-images:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-20.04</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Clone</span> <span class="string">repository</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">github-actions</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">github-actions@github.com</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Sync</span> <span class="string">images</span></span><br><span class="line">        <span class="attr">shell:</span> <span class="string">bash</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">REGISTRY_DOMAIN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.REGISTRY_DOMAIN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">REGISTRY_USER:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.REGISTRY_USER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">REGISTRY_PASSWORD:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.REGISTRY_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">sudo</span> <span class="string">skopeo</span> <span class="string">login</span> <span class="string">$&#123;REGISTRY_DOMAIN&#125;</span>  <span class="string">-u</span> <span class="string">$&#123;REGISTRY_USER&#125;</span> <span class="string">-p</span> <span class="string">$&#123;REGISTRY_PASSWORD&#125;</span></span><br><span class="line">          <span class="string">sudo</span> <span class="string">bash</span> <span class="string">sync-images.sh</span> <span class="string">$&#123;REGISTRY_DOMAIN&#125;</span></span><br></pre></td></tr></table></figure><p>既然 GitHub runner 的机器里有 docker login 的配置文件，不如把它<strong>偷</strong>过来，复制粘贴到自家的机器上使用😜？不过我认为这种行为有点不厚道😂，还是别干了。在这里只提供一个思路，实际上可行性还待验证。</p><h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><p>默认设置的为 6 小时同步一次上游最新的代码，由于定时更新是使用的增量同步，即通过 git diff 的方式将当前分支最新的 commit 和上游 docker hub 官方的 repo 最新 commit 进行比较，找出变化的镜像。因此如果是首次同步，需要全量同步，在同步完成之后会给 repo 打上一个时间戳的 tag ，下次同步的时候就用这个 tag 和上游 repo 最新 commit 做差异比较。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IMAGES=$(git diff --name-only --ignore-space-at-eol --ignore-space-change \</span><br><span class="line">    --diff-filter=AM $&#123;LAST_TAG&#125; $&#123;CURRENT_COMMIT&#125; library | xargs -L1 -I &#123;&#125; sed "s|^|&#123;&#125;:|g" &#123;&#125; \</span><br><span class="line">    | sed -n "s| ||g;s|library/||g;s|:Tags:|:|p;s|:SharedTags:|:|p" | sort -u | sed "/$&#123;SKIPE_IMAGES&#125;/d")</span><br></pre></td></tr></table></figure><h2 id="如何食用？"><a href="#如何食用？" class="headerlink" title="如何食用？"></a>如何食用？</h2><p>如果你也想将 docker hub 上 library repo 的镜像搞到本地镜像仓库，可以参考如下方法：</p><h3 id="劝退三连😂"><a href="#劝退三连😂" class="headerlink" title="劝退三连😂"></a>劝退三连😂</h3><ul><li>首先要本地部署好镜像仓库并配置好 SSL 证书。镜像仓库建议使用 docker registry 或者 harbor，具体的部署方法可以在互联网上找到。</li><li>需要个大盘鸡（大硬盘机器），当前 docker hub 上还在维护的 tag 镜像总大小为 128 GB 左右。</li><li>如果是长期使用，本地镜像仓库的存储空间至少 1TB 以上。</li><li>由于是使用 GitHub action 的机器将镜像 push 到本地镜像仓库，因此本地镜像仓库需要有个公网IP以及域名 + SSL 证书</li></ul><h3 id="增加配置"><a href="#增加配置" class="headerlink" title="增加配置"></a>增加配置</h3><p>首先 fork 官方的 repo <a href="https://github.com/docker-library/official-images" target="_blank" rel="noopener">docker-library/official-images</a>  到自己的 GitHub 账户下；</p><p>然后 fork 这个 repo <a href="https://github.com/muzi502/sync-library-images" target="_blank" rel="noopener">muzi502/sync-library-images</a> 到自己的 GitHub 账户下；</p><p>最后在自己的 sync-library-images 这个 repo 的 <code>Settings &gt;  Secrets</code> 中配置好如下三个变量：</p><ul><li>REGISTRY_DOMAIN 设置为本地镜像仓库的域名</li><li>REGISTRY_USER 本地镜像仓库的用户名</li><li>REGISTRY_PASSWORD 设置为本地镜像仓库的密码</li></ul><p><img src="img/image-20210216163441719.png" alt="image-20210216163441719"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://docs.docker.com/docker-hub/official_images/" target="_blank" rel="noopener">Official Images on Docker Hub</a></p></li><li><p><a href="https://hub.docker.com/support/doc/how-do-i-authenticate-with-the-v2-api" target="_blank" rel="noopener">How do I authenticate with the V2 API?</a></p></li><li><p><a href="https://docs.docker.com/docker-hub/download-rate-limit/" target="_blank" rel="noopener">Download rate limit</a></p></li><li><p><a href="https://moelove.info/2020/09/20/%E7%AA%81%E7%A0%B4-DockerHub-%E9%99%90%E5%88%B6%E5%85%A8%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E6%9C%8D%E5%8A%A1/" target="_blank" rel="noopener">突破 DockerHub 限制，全镜像加速服务</a></p></li><li><p><a href="https://nova.moe/bypass-docker-hub-429/" target="_blank" rel="noopener">绕过从 Docker Hub pull 镜像时的 429 toomanyrequests</a></p></li><li><p><a href="https://www.chenshaowen.com/blog/how-to-cross-the-limit-of-dockerhub.html" target="_blank" rel="noopener">如何绕过 DockerHub 拉取镜像限制</a></p></li><li><p><a href="https://p3terx.com/archives/ssh-to-the-github-actions-virtual-server-environment.html" target="_blank" rel="noopener">SSH 连接到 GitHub Actions 虚拟服务器</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;恰烂钱？&quot;&gt;&lt;a href=&quot;#恰烂钱？&quot;
        
      
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.k8s.li/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="registry" scheme="https://blog.k8s.li/tags/registry/"/>
    
      <category term="images" scheme="https://blog.k8s.li/tags/images/"/>
    
  </entry>
  
  <entry>
    <title>docker registry 迁移至 harbor</title>
    <link href="https://blog.k8s.li/docker-registry-to-harbor.html"/>
    <id>https://blog.k8s.li/docker-registry-to-harbor.html</id>
    <published>2021-01-30T16:00:00.000Z</published>
    <updated>2021-02-24T13:42:05.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><h3 id="Docker-Distribution"><a href="#Docker-Distribution" class="headerlink" title="Docker Distribution"></a>Docker Distribution</h3><p><a href="https://github.com/distribution/distribution" target="_blank" rel="noopener">Docker Distribution</a> 是第一个是实现了打包、发布、存储和镜像分发的工具，起到 Docker registry 的作用。（目前 Distribution 已经捐赠给了 CNCF）。其中 Docker Distribution 中的 <a href="https://github.com/distribution/distribution/tree/main/docs/spec" target="_blank" rel="noopener">spec 规范</a> 后来也就成为了 OCI <a href="https://github.com/opencontainers/distribution-spec" target="_blank" rel="noopener">distribution-spec</a> 规范。可以认为 Docker Distribution 实现了大部分 OCI 镜像分发的规范，二者在很大程度上也是兼容的。 OCI 的指导思想时先有工业界的实践，再将这些实践总结成技术规范，因此尽管 OCI 的 <a href="https://github.com/opencontainers/distribution-spec" target="_blank" rel="noopener">distribution-spec</a> 规范还没有正式发布（目前版本是<a href="https://github.com/opencontainers/distribution-spec/releases/tag/v1.0.0-rc1" target="_blank" rel="noopener">v1.0.0-rc1</a>），但以 Docker Distribution 作为基础的镜像仓库已经成为普遍采用的方案，Docker registry HTTP API V2 也就成为了事实上的标准。</p><h3 id="Harbor"><a href="#Harbor" class="headerlink" title="Harbor"></a>Harbor</h3><p>Harbor 也是采用了 Docker Distribution （docker registry）作为后端镜像存储服务，在 Harbor 2.0 之前的版本，镜像相关的功能大部分是由 Docker Distribution 来处理，镜像和 OCI 等制品的元数据是 harbor 组件从 docker registry 中提取出来的；Harbor 在 2.0 版本之后，镜像等 OCI 制品相关的元数据由 Harbor 自己来维护，而且<strong>元数据是在 PUSH 这些制品时写入到 harbor 的数据库中的</strong>。也正因得益于此，Harbor 不再仅仅是个用来存储和管理镜像的服务，而一个云原生仓库服务，能够存储和管理符合 OCI 规范的 Helm Chart、CNAB、OPA Bundle 等多种 Artifact 。</p><h3 id="docker-registry-to-harbor"><a href="#docker-registry-to-harbor" class="headerlink" title="docker registry to harbor"></a>docker registry to harbor</h3><p>好了，扯了这么多没用的概念，回到本文要解决的问题：<strong>如何将 docker registry 中的镜像迁移至 harbor？</strong></p><p>假如内网环境中有两台机器，一台机器上运行着 docker registry，域名假设为 registry.k8s.li 。另一台机器运行着 harbor，假设域名为 harbor.k8s.li。现在 docker registry 中存放了五千个镜像。harbor 是刚刚部署的，里面还没有镜像。在磁盘和网络没有限制的情况下，如何高效地将 docker registry 中的镜像迁移到 harbor 中呢？</p><h2 id="获取-registry-所有镜像的列表"><a href="#获取-registry-所有镜像的列表" class="headerlink" title="获取 registry 所有镜像的列表"></a>获取 registry 所有镜像的列表</h2><p>首先在迁移之前我们要拉清单，获取一份 docker registry 中镜像的列表，这样我们才能保证迁移后没有镜像丢失。根据木子在 <a href="https://blog.k8s.li/Exploring-container-image.html">深入浅出容器镜像的一生🤔</a> 文章中提到的 registry 的存储目录结构。在 registry 存储目录中，每个镜像的 tag 都是由 <code>current/index</code> 这个文件指向该 tag 镜像的 manifests 文件的，由此我们可以通过遍历 registry 存储目录中 <code>current/index</code> 文件的方式来得到所有镜像的 tag，由此得到该 registry 中所有镜像的列表。注意，这样只能得到有 tag 的镜像，其他没 tag 的镜像无法获取到。</p><p><img src="img/registry-storage.jpeg" alt="img"></p><p>可通过如下命令在 registry 存储目录下获取镜像列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先进入到 registry 存储的主目录下</span></span><br><span class="line"><span class="built_in">cd</span>  /var/lib/registry</span><br><span class="line">find docker -<span class="built_in">type</span> d -name <span class="string">"current"</span> | sed <span class="string">'s|docker/registry/v2/repositories/||g;s|/_manifests/tags/|:|g;s|/current||g'</span> &gt; images.list</span><br></pre></td></tr></table></figure><h2 id="harbor-创建-project"><a href="#harbor-创建-project" class="headerlink" title="harbor 创建 project"></a>harbor 创建 project</h2><p>对于新部署的 harbor 来说，上面只会有一个默认的 library 的 project，需要手动在 harbor 上创建 docker registry 中对应的 project。docker registry 中镜像的 project 就是 registry 存储目录中 <code>repositories</code> 下的目录名。</p><p>得到了镜像列表，以及在 harbor 上完成了对应 project 的创建，我们就可以做正式的迁移工作啦。根据不同的场景，可使用如下几种方案：</p><h2 id="方案一：docker-retag"><a href="#方案一：docker-retag" class="headerlink" title="方案一：docker retag"></a>方案一：docker retag</h2><p>方案一可能是大多数人首先想到的办法，也是最简单粗暴的方法。就是在一台机器上使用 docker pull 下 docker  registry 中的所有镜像，然后再 docker retag 一下，再 docker push 到 harbor 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设其中的一个镜像为 library/alpine:latest</span></span><br><span class="line"></span><br><span class="line">docker pull registry.k8s.li/library/alpine:latest</span><br><span class="line"></span><br><span class="line">docker tag registry.k8s.li/library/alpine:latest harbor.k8s.li/library/alpine:latest</span><br><span class="line"></span><br><span class="line">docker push harbor.k8s.li/library/alpine:latest</span><br></pre></td></tr></table></figure><p>如果你之前读过木子曾经写过的 <a href="https://blog.k8s.li/Exploring-container-image.html">深入浅出容器镜像的一生🤔</a> 和 <a href="https://blog.k8s.li/skopeo.html">镜像搬运工 skopeo 初体验</a> 并且已经在日常生活中使用 skopeo ，你一定会很觉着这个方案很蠢，因为 docker pull –&gt; docker tag –&gt; docker pull 的过程中会对镜像的 layer 进行解压缩。对于只是将镜像从一个 registry 复制到另一个 registry 来说，这些 docker 在这些过程中做了很多无用功。详细的原理可以翻看一下刚提到的两篇文章，在此就不再赘述。</p><p>那么为了追求高效，肯定不会使用 docker retag 这么蠢的办法啦，下面就讲一下方案二：</p><h2 id="方案二：skopeo"><a href="#方案二：skopeo" class="headerlink" title="方案二：skopeo"></a>方案二：skopeo</h2><p>在 <a href="https://blog.k8s.li/skopeo.html">镜像搬运工 skopeo 初体验</a> 中介绍过可以使用 skopeo copy 直接从一个 registry 中复制镜像原始 blobs 到另一个 registry 中，在此期间不会涉及镜像 layer 解压缩操作。至于性能和耗时，比使用 docker 的方式高到不知道哪里去了😂。</p><ul><li>使用 skopeo copy</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skopeo copy --insecure-policy --src-tls-verify=<span class="literal">false</span> --dest-tls-verify=<span class="literal">false</span> --src docker://registry.k8s.li/library/alpine:latest docker://harbor.k8s.li/library/alpine:latest</span><br></pre></td></tr></table></figure><ul><li>使用 skopeo sync</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skopeo sync --insecure-policy --src-tls-verify=<span class="literal">false</span> --dest-tls-verify=<span class="literal">false</span> --src docker --dest docker registry.k8s.li/library/alpine:latest harbor.k8s.li/library/alpine:latest</span><br></pre></td></tr></table></figure><p>但还有没有更好的办法？要知道无论是 docker 和 skopeo 本质上都是通过 registry 的 HTTP API 下载和上传镜像的，在这过程中还是多了不少 HTTP 请求的，如果走的是 HTTPS 的话，还涉及了 HTTPS 加密和解密的过程，这期间也是做了很多<del>无用功</del>的。那么还有没有更好的办法？</p><h2 id="方案三：迁移存储目录"><a href="#方案三：迁移存储目录" class="headerlink" title="方案三：迁移存储目录"></a>方案三：迁移存储目录</h2><p>文章开篇提到 harbor 的后端镜像存储也是使用的  docker registry，对于一个 registry 来说，只要是使用的是 Docker Distribution V2 ，它后端的存储目录结构都是长得一摸一样的。那为何不直接将 registry 的存储目录打包复制并解压到 harbor 的 registry 存储目录呢？这样又能保证所有的镜像都迁移过去，不会落下任何一个。</p><p>对于 harbor 1.x 版本来讲，将 docker registry 的存储目录直接迁移到 harbor 的 registry 存储目录，然后删除 harbor 的 redis 数据（因为 harbor 的 redis 缓存了镜像的元数据信息），重启 harbor 就完事儿了。重启 harbor 之后，harbor 会调用后端的 registry 去提取镜像的元数据信息并存储到 redis 中。这样就完成了迁移的工作。</p><p>在 docker registry 机器上备份 registry 存储目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到 docker registry 的存储目录</span></span><br><span class="line"><span class="built_in">cd</span>  /var/lib/registry</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，进行备份时无需进行压缩，因为 registry 中镜像的 layer 都是压缩过的</span></span><br><span class="line">tar -cpf docker.tar docker</span><br></pre></td></tr></table></figure><p>备份完成之后将 docker.tar scp 到 harbor 机器上，然后在 harbor 机器上恢复 registry 存储目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到 harbor 的存储目录</span></span><br><span class="line"><span class="built_in">cd</span> /data/harbor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将备份的 docker 目录解压到 harbor 的 registry 目录下，目录层级一定要对应好</span></span><br><span class="line">tar -xpf docker.tar -C ./registry</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 harbor 的 regis 数据，重启 harbor 后会重建 redis 数据。</span></span><br><span class="line">rm -f redis/dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 harbor 的安装目录重启 harbor</span></span><br><span class="line"><span class="built_in">cd</span> /opt/harbor</span><br><span class="line">docker-compose restart</span><br></pre></td></tr></table></figure><p>这样迁移之后可能会遇到无法往 harbor push 镜像的问题。因为 docker registry 容器内 registry 存储目录的所属和所属组为 root ，而 harbor registry 容器内 registry 存储目录的所属和所属组为 10000:10000 ,二者权限并不相同，会导致 harbor 无法 push 镜像。因此在迁移完成之后需要修改一下 harbor registry 目录的所属和所属组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到 harbor 的存储目录</span></span><br><span class="line"><span class="built_in">cd</span> /data/harbor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 registry 存储目录的所属和所属组为 10000</span></span><br><span class="line">chown -R 10000:10000 ./registry</span><br></pre></td></tr></table></figure><h2 id="方案四："><a href="#方案四：" class="headerlink" title="方案四："></a>方案四：</h2><p>对于 harbor 2.x 来讲，由于 harbor 强化了 Artifact 的元数据管理能力，即元数据要在 push 或者 sync 到 harbor 时写入到 harbor 自身的数据库中。在 harbor 看来只要数据库中没有这个 Artifact 的 manifest 信息或者没有这一层 layer 的信息，harbor 都会认为该 Artifact 或者 layer 不存在，返回 404 的错误。按照方案三直接而将 docker registry 存储目录解压到 harbor 的 registry 存储目录的方法行不通的。因为是将镜像解压到 registry 存储中的，虽然在 harbor 的 registry 容器看来是有镜像的，但因为 harbor 的数据库中没有镜像，harbor 就会认为没有镜像。那么现在看来只能通过方案二使用 skopeo 将镜像一个一个地 push 到 harbor 中了。</p><p>但对于某些特定的场景下，不能像方案二那样拥有一个 docker registry 的 HTTP 服务，只有一个 docker registry 的压缩包，这如何将 docker registry 的存储目录中的镜像迁移到 harbor 2.0 中呢？</p><p>在 <a href="https://blog.k8s.li/skopeo.html">镜像搬运工 skopeo 初体验</a> 中提到过 skopeo 支持的<code>镜像格式</code>有如下几种：</p><table><thead><tr><th align="left">IMAGE NAMES</th><th align="left">example</th></tr></thead><tbody><tr><td align="left"><strong>containers-storage:</strong></td><td align="left">containers-storage:</td></tr><tr><td align="left"><strong>dir:</strong></td><td align="left">dir:/PATH</td></tr><tr><td align="left"><strong>docker://</strong></td><td align="left">docker://k8s.gcr.io/kube-apiserver:v1.17.5</td></tr><tr><td align="left"><strong>docker-daemon:</strong></td><td align="left">docker-daemon:alpine:latest</td></tr><tr><td align="left"><strong>docker-archive:</strong></td><td align="left">docker-archive:alpine.tar (docker save)</td></tr><tr><td align="left"><strong>oci:</strong></td><td align="left">oci:alpine:latest</td></tr></tbody></table><p>需要注意的是，这几种镜像的名字，对应着镜像存在的方式，不同存在的方式对镜像的 layer 处理的方式也不一样，比如 <code>docker://</code> 这种方式是存在 registry 上的；<code>docker-daemon:</code> 是存在本地 docker pull 下来的；再比如 <code>docker-archive</code> 是通过 docker save 出来的镜像；而 <code>dir:</code> 是镜像以文件夹的形式保存的。同一个镜像有这几种存在的方式就像水有气体、液体、固体一样。可以这样去理解，他们表述的都是同一个镜像，只不过是存在的方式不一样而已。</p><p>既然镜像是存放在 registry 存储目录里的，那么使用 dir 的形式直接从文件系统读取镜像，理论上来讲会比方案二要好一些。虽然 skopeo 支持 dir 格式的镜像，但 skopeo 目前并不支持直接使用 registry 的存储目录，所以还是需要想办法将 docker registry 存储目录里的每一个镜像转换成 skopeo dir 的形式。</p><h3 id="skopeo-dir"><a href="#skopeo-dir" class="headerlink" title="skopeo dir"></a>skopeo dir</h3><p>那么先来看一下 skopeo dir 是什么样子的？</p><p>为了方便测试方案的可行性，先使用 skopeo 命令先从 docker hub 上拉取一个镜像，并保存为 dir，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skopeo copy docker://alpine:latest dir:./alpine</span><br></pre></td></tr></table></figure><p>使用 tree 命令查看一下 alpine 文件夹的目录结构，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry</span><br><span class="line">╰─# tree -h alpine</span><br><span class="line">alpine</span><br><span class="line">├── [2.7M]  4c0d98bf9879488e0407f897d9dd4bf758555a78e39675e72b5124ccf12c2580</span><br><span class="line">├── [1.4K]  e50c909a8df2b7c8b92a6e8730e210ebe98e5082871e66edd8ef4d90838cbd25</span><br><span class="line">├── [ 528]  manifest.json</span><br><span class="line">└── [  33]  version</span><br><span class="line"></span><br><span class="line">0 directories, 4 files</span><br><span class="line">╭─root@sg-02 /var/lib/registry</span><br><span class="line">╰─# file alpine/e50c909a8df2b7c8b92a6e8730e210ebe98e5082871e66edd8ef4d90838cbd25</span><br><span class="line">alpine/e50c909a8df2b7c8b92a6e8730e210ebe98e5082871e66edd8ef4d90838cbd25: ASCII text, with very long lines, with no line terminators</span><br><span class="line"></span><br><span class="line">╭─root@sg-02 /var/lib/registry</span><br><span class="line">╰─# file alpine/4c0d98bf9879488e0407f897d9dd4bf758555a78e39675e72b5124ccf12c2580</span><br><span class="line">alpine/4c0d98bf9879488e0407f897d9dd4bf758555a78e39675e72b5124ccf12c2580: gzip compressed data</span><br></pre></td></tr></table></figure><p>从文件名和大小以及文件的内省我们可以判断出，manifest 文件对应的就是镜像的 manifests 文件；类型为 <code>ASCII text</code> 的文件正是镜像的 image config 文件，里面包含着镜像的元数据信息。而另一个 <code>gzip compressed data</code> 文件不就是经过 gzip 压缩过的镜像 layer 嘛。看一下 manifest 文件的内容也再次印证了这个结论：</p><ul><li>镜像的 config 字段对应的正是 e50c909a8df2，而文件类型正是 <code>image.v1+json</code> 文本文件。</li><li>镜像的 layer 字段对应的也正是  4c0d98bf9879 而文件类型正是  <code>.tar.gzip</code> gzip 压缩文件。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">alpine/4c0d98bf9879488e0407f897d9dd4bf758555a78e39675e72b5124ccf12c2580: gzip compressed data</span><br><span class="line">╭─root@sg-02 /var/lib/registry</span><br><span class="line">╰─# cat alpine/manifest.json</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"schemaVersion"</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.distribution.manifest.v2+json"</span>,</span><br><span class="line">   <span class="attr">"config"</span>: &#123;</span><br><span class="line">      <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.container.image.v1+json"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">1471</span>,</span><br><span class="line">      <span class="attr">"digest"</span>: <span class="string">"sha256:e50c909a8df2b7c8b92a6e8730e210ebe98e5082871e66edd8ef4d90838cbd25"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"layers"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.image.rootfs.diff.tar.gzip"</span>,</span><br><span class="line">         <span class="attr">"size"</span>: <span class="number">2811321</span>,</span><br><span class="line">         <span class="attr">"digest"</span>: <span class="string">"sha256:4c0d98bf9879488e0407f897d9dd4bf758555a78e39675e72b5124ccf12c2580"</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从-registry-存储目录中捞镜像出来"><a href="#从-registry-存储目录中捞镜像出来" class="headerlink" title="从 registry 存储目录中捞镜像出来"></a>从 registry 存储目录中捞镜像出来</h3><p>接下来到本文的较为精彩的地方了。如何从 registry 存储里的 <code>捞</code> 镜像出来，转换成 skopeo 所支持的 dir 格式。</p><p><img src="img/registry-storage.jpeg" alt="img"></p><ul><li>首先要得到镜像的 manifests 文件，从 manifests 文件中可以得到该镜像的所有 blob 文件。例如对于 registry 存储目录中的 <code>library/alpine:latest</code> 镜像来讲，它在 registry 中是这样存放的：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2</span><br><span class="line">╰─# tree</span><br><span class="line">.</span><br><span class="line">├── blobs</span><br><span class="line">│   └── sha256</span><br><span class="line">│       ├── 21</span><br><span class="line">│       │   └── 21c83c5242199776c232920ddb58cfa2a46b17e42ed831ca9001c8dbc532d22d</span><br><span class="line">│       │       └── data</span><br><span class="line">│       ├── a1</span><br><span class="line">│       │   └── a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590</span><br><span class="line">│       │       └── data</span><br><span class="line">│       └── be</span><br><span class="line">│           └── be4e4bea2c2e15b403bb321562e78ea84b501fb41497472e91ecb41504e8a27c</span><br><span class="line">│               └── data</span><br><span class="line">└── repositories</span><br><span class="line">    └── library</span><br><span class="line">        └── alpine</span><br><span class="line">            ├── _layers</span><br><span class="line">            │   └── sha256</span><br><span class="line">            │       ├── 21c83c5242199776c232920ddb58cfa2a46b17e42ed831ca9001c8dbc532d22d</span><br><span class="line">            │       │   └── link</span><br><span class="line">            │       └── be4e4bea2c2e15b403bb321562e78ea84b501fb41497472e91ecb41504e8a27c</span><br><span class="line">            │           └── link</span><br><span class="line">            ├── _manifests</span><br><span class="line">            │   ├── revisions</span><br><span class="line">            │   │   └── sha256</span><br><span class="line">            │   │       └── a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590</span><br><span class="line">            │   │           └── link</span><br><span class="line">            │   └── tags</span><br><span class="line">            │       └── latest</span><br><span class="line">            │           ├── current</span><br><span class="line">            │           │   └── link</span><br><span class="line">            │           └── index</span><br><span class="line">            │               └── sha256</span><br><span class="line">            │                   └── a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590</span><br><span class="line">            │                       └── link</span><br><span class="line">            └── _uploads</span><br><span class="line"></span><br><span class="line">26 directories, 8 files</span><br></pre></td></tr></table></figure><ol><li>通过 <code>repositories/library/alpine/_manifests/tags/latest/current/link</code> 文件得到 alpine 镜像 lasts 这个 tag 的 manifests 文件的 sha256 值，然后根据这个 sha256 值去 blobs 找到镜像的 manifests 文件;</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2/repositories/library/alpine/_manifests/tags/latest/current/</span><br><span class="line">╰─# cat link</span><br><span class="line">sha256:39eda93d15866957feaee28f8fc5adb545276a64147445c64992ef69804dbf01#</span><br></pre></td></tr></table></figure><ol start="2"><li>根据 <code>current/link</code> 文件中的 sha256 值在 blobs 目录下找到与之对应的文件，blobs 目录下对应的 manifests 文件为 blobs/sha256/39/39eda93d15866957feaee28f8fc5adb545276a64147445c64992ef69804dbf01/data;</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2/repositories/library/alpine/_manifests/tags/latest/current</span><br><span class="line">╰─# cat /var/lib/registry/docker/registry/v2/blobs/sha256/39/39eda93d15866957feaee28f8fc5adb545276a64147445c64992ef69804dbf01/data</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"schemaVersion"</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.distribution.manifest.v2+json"</span>,</span><br><span class="line">   <span class="attr">"config"</span>: &#123;</span><br><span class="line">      <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.container.image.v1+json"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">1507</span>,</span><br><span class="line">      <span class="attr">"digest"</span>: <span class="string">"sha256:f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"layers"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.image.rootfs.diff.tar.gzip"</span>,</span><br><span class="line">         <span class="attr">"size"</span>: <span class="number">2813316</span>,</span><br><span class="line">         <span class="attr">"digest"</span>: <span class="string">"sha256:cbdbe7a5bc2a134ca8ec91be58565ec07d037386d1f1d8385412d224deafca08"</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用正则匹配，过滤出 manifests 文件中的所有 sha256 值，这些 sha256 值就对应着 blobs 目录下的 image config 文件和 image layer 文件;</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2/repositories/library/alpine/_manifests/tags/latest/current</span><br><span class="line">╰─<span class="comment"># grep -Eo "\b[a-f0-9]&#123;64&#125;\b" /var/lib/registry/docker/registry/v2/blobs/sha256/39/39eda93d15866957feaee28f8fc5adb545276a64147445c64992ef69804dbf01/data</span></span><br><span class="line">f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a</span><br><span class="line">cbdbe7a5bc2a134ca8ec91be58565ec07d037386d1f1d8385412d224deafca08</span><br></pre></td></tr></table></figure><ol start="4"><li>根据 manifests 文件就可以得到 blobs 目录中镜像的所有 layer 和 image config 文件，然后将这些文件拼成一个 dir 格式的镜像，在这里使用 cp 的方式将镜像从 registry 存储目录里复制出来，过程如下：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先创建一个文件夹，为了保留镜像的 name 和 tag，文件夹的名称就对应的是 NAME:TAG</span></span><br><span class="line">╭─root@sg-02 /var/lib/registry/docker</span><br><span class="line">╰─# mkdir -p skopeo/library/alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制镜像的 manifest 文件</span></span><br><span class="line">╭─root@sg-02 /var/lib/registry/docker</span><br><span class="line">╰─# cp /var/lib/registry/docker/registry/v2/blobs/sha256/39/39eda93d15866957feaee28f8fc5adb545276a64147445c64992ef69804dbf01/data skopeo/library/alpine:latest/manifest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制镜像的 blob 文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cp /var/lib/registry/docker/registry/v2/blobs/sha256/f7/f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a/data skopeo/library/alpine:latest/f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cp /var/lib/registry/docker/registry/v2/blobs/sha256/cb/cbdbe7a5bc2a134ca8ec91be58565ec07d037386d1f1d8385412d224deafca08/data skopeo/library/alpine:latest/cbdbe7a5bc2a134ca8ec91be58565ec07d037386d1f1d8385412d224deafca08</span></span><br></pre></td></tr></table></figure><p>最终得到的镜像格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker</span><br><span class="line">╰─<span class="comment"># tree skopeo/library/alpine:latest</span></span><br><span class="line">skopeo/library/alpine:latest</span><br><span class="line">├── cbdbe7a5bc2a134ca8ec91be58565ec07d037386d1f1d8385412d224deafca08</span><br><span class="line">├── f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a</span><br><span class="line">└── manifest</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br></pre></td></tr></table></figure><p>和上面的 skopeo copy 出来的 dir 文件夹对比一下，除了一个无关紧要的 version 文件，其他的都一摸一样。</p><ol start="5"><li>再优化一下，将步骤 4 中的 cp 操作修改成硬链接操作，能极大减少磁盘的 IO 操作。需要注意：硬链接文件不能跨分区，所以要和 registry 存储目录在同一个分区下才行。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker</span><br><span class="line">╰─# ln /var/lib/registry/docker/registry/v2/blobs/sha256/39/39eda93d15866957feaee28f8fc5adb545276a64147445c64992ef69804dbf01/data skopeo/library/alpine:latest/manifest</span><br><span class="line"><span class="meta">#</span><span class="bash"> ln /var/lib/registry/docker/registry/v2/blobs/sha256/f7/f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a/data skopeo/library/alpine:latest/f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ln /var/lib/registry/docker/registry/v2/blobs/sha256/cb/cbdbe7a5bc2a134ca8ec91be58565ec07d037386d1f1d8385412d224deafca08/data skopeo/library/alpine:latest/cbdbe7a5bc2a134ca8ec91be58565ec07d037386d1f1d8385412d224deafca08</span></span><br><span class="line">╭─root@sg-02 /var/lib/registry/docker</span><br><span class="line">╰─# tree skopeo/library/alpine:latest</span><br><span class="line">skopeo/library/alpine:latest</span><br><span class="line">├── cbdbe7a5bc2a134ca8ec91be58565ec07d037386d1f1d8385412d224deafca08</span><br><span class="line">├── f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a</span><br><span class="line">└── manifest</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br></pre></td></tr></table></figure><p>然后使用 skopeo copy 或者 skopeo sync 将捞出来的镜像 push 到 harbor</p><ul><li>使用 skopeo copy</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">skopeo copy  --insecure-policy --src-tls-verify=false --dest-tls-verify=false \</span><br><span class="line">dir:skopeo/library/alpine:latest docker://harbor.k8s.li/library/alpine:latest</span><br></pre></td></tr></table></figure><ul><li>使用 skopeo sync</li></ul><p>需要注意的是，skopeo sync 的方式是同步 project 级别的，镜像的 name 和 tag 就对应的是目录的名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">skopeo sync --insecure-policy --src-tls-verify=false --dest-tls-verify=false \</span><br><span class="line">--src dir --dest docker skopeo/library/ harbor.k8s.li/library/</span><br></pre></td></tr></table></figure><h3 id="实现脚本"><a href="#实现脚本" class="headerlink" title="实现脚本"></a>实现脚本</h3><p>大叫一声 shell 大法好！😂</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">REGISTRY_DOMAIN="harbor.k8s.li"</span><br><span class="line">REGISTRY_PATH="/var/lib/registry"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到 registry 存储主目录下</span></span><br><span class="line">cd $&#123;REGISTRY_PATH&#125;</span><br><span class="line"></span><br><span class="line">gen_skopeo_dir() &#123;</span><br><span class="line"><span class="meta">   #</span><span class="bash"> 定义 registry 存储的 blob 目录 和 repositories 目录，方便后面使用</span></span><br><span class="line">    BLOB_DIR="docker/registry/v2/blobs/sha256"</span><br><span class="line">    REPO_DIR="docker/registry/v2/repositories"</span><br><span class="line">    # 定义生成 skopeo 目录</span><br><span class="line">    SKOPEO_DIR="docker/skopeo"</span><br><span class="line">    # 通过 find 出 current 文件夹可以得到所有带 tag 的镜像，因为一个 tag 对应一个 current 目录</span><br><span class="line">    for image in $(find $&#123;REPO_DIR&#125; -type d -name "current"); do</span><br><span class="line">        # 根据镜像的 tag 提取镜像的名字</span><br><span class="line">        name=$(echo $&#123;image&#125; | awk -F '/' '&#123;print $5"/"$6":"$9&#125;')</span><br><span class="line">        link=$(cat $&#123;image&#125;/link | sed 's/sha256://')</span><br><span class="line">        mfs="$&#123;BLOB_DIR&#125;/$&#123;link:0:2&#125;/$&#123;link&#125;/data"</span><br><span class="line">        # 创建镜像的硬链接需要的目录</span><br><span class="line">        mkdir -p "$&#123;SKOPEO_DIR&#125;/$&#123;name&#125;"</span><br><span class="line">        # 硬链接镜像的 manifests 文件到目录的 manifest 文件</span><br><span class="line">        ln $&#123;mfs&#125; $&#123;SKOPEO_DIR&#125;/$&#123;name&#125;/manifest.json</span><br><span class="line">        # 使用正则匹配出所有的 sha256 值，然后排序去重</span><br><span class="line">        layers=$(grep -Eo "\b[a-f0-9]&#123;64&#125;\b" $&#123;mfs&#125; | sort -n | uniq)</span><br><span class="line">        for layer in $&#123;layers&#125;; do</span><br><span class="line">          # 硬链接 registry 存储目录里的镜像 layer 和 images config 到镜像的 dir 目录</span><br><span class="line">            ln $&#123;BLOB_DIR&#125;/$&#123;layer:0:2&#125;/$&#123;layer&#125;/data $&#123;SKOPEO_DIR&#125;/$&#123;name&#125;/$&#123;layer&#125;</span><br><span class="line">        done</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sync_image() &#123;</span><br><span class="line">    # 使用 skopeo sync 将 dir 格式的镜像同步到 harbor</span><br><span class="line">    for project in $(ls $&#123;SKOPEO_DIR&#125;); do</span><br><span class="line">        skopeo sync --insecure-policy --src-tls-verify=false --dest-tls-verify=false \</span><br><span class="line">        --src dir --dest docker $&#123;SKOPEO_DIR&#125;/$&#123;project&#125; $&#123;REGISTRY_DOMAIN&#125;/$&#123;project&#125;</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gen_skopeo_dir</span><br><span class="line">sync_image</span><br></pre></td></tr></table></figure><p>其实魔改一下 skopeo 的源码也是可以无缝支持 registry 存储目录的，目前正在研究中😃</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table><thead><tr><th></th><th>方法</th><th>适用范围</th><th>缺点</th></tr></thead><tbody><tr><td>一</td><td>docker retag</td><td>两个 registry 之间同步镜像</td><td></td></tr><tr><td>二</td><td>skopeo</td><td>两个 registry 之间同步镜像</td><td></td></tr><tr><td>三</td><td>解压目录</td><td>registry 存储目录到另一个 registry</td><td>harbor 1.x</td></tr><tr><td>四</td><td>skopeo dir</td><td>registry 存储目录到另一个 registry</td><td>适用于 harbor 2.x</td></tr></tbody></table><p>对比总结一下以上几种方案：</p><ul><li>方案一：上手成本低，适用于镜像数量比较多少，无需安装 skopeo 的情况，缺点是性能较差；</li><li>方案二：适用于两个 registry 之间同步复制镜像，如将 docker hub 中的一些公共镜像复制到公司内网的镜像仓库中。</li><li>方案三：适用于镜像仓库之间进行迁移，性能是所有方案里最好的，需要额外注意的是如果目的镜像仓库是 harbor 2.x，是无法使用这种方式的。</li><li>方案四：是方案三的妥协版，为了适配 harbor 2.0 ，因为需要重新将镜像 push 到 harbor ，所以性能上要比方案三差一些。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="">《harbor权威指南</a></li><li><a href="https://goharbor.io/blog/harbor-2.0/" target="_blank" rel="noopener">Harbor 2.0 takes a giant leap in expanding supported artifacts with OCI support</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;Registry&quot;&gt;&lt;a
        
      
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.k8s.li/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="registry" scheme="https://blog.k8s.li/tags/registry/"/>
    
      <category term="harbor" scheme="https://blog.k8s.li/tags/harbor/"/>
    
      <category term="镜像" scheme="https://blog.k8s.li/tags/%E9%95%9C%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>2020 年读书笔记和思考</title>
    <link href="https://blog.k8s.li/2020-booklist.html"/>
    <id>https://blog.k8s.li/2020-booklist.html</id>
    <published>2020-12-30T16:00:00.000Z</published>
    <updated>2021-01-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先给各位关注我博客的小伙伴说声抱歉，已经很长时间（将近 4 个月）没有更新博客了，实在是对不住大家，自己一直在偷懒没能坚持创作。2021 年刚开始，决定决定以后还是要坚持创作下去，于是最近抽出点时间整理了下 2020 年读过的书分享给大家，希望能帮助到大家找到些有意思的书来读。内容有点多，大概 2 万多字🙃。</p><h2 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h2><p>由于疫情的影响，节假日和周末都不怎么出去，一直宅在家里，所以大部分的闲暇时间都是捧着 kindle 看会书，亦或者刷一会 Pixiv 和 Twitter 收集一些纸片人插画，俨然成了一个标准的死肥宅。2020 年一整年留给自己的时间比较多，所以总体上来讲 2020 年读过的书比 2019 年多了将近一倍，有兴趣的可以翻开一下 2019 年的读书总结 <a href="https://blog.k8s.li/2019-reading-notes.html">2019 年读书笔记和思考</a> 。下面的表格是我参考 kindle 上的标注时间整理的 2020 年读完的书（共计 68 本书）。</p><table><thead><tr><th align="center">书名</th><th align="center">作者</th><th align="center">start</th><th align="center">end</th><th align="center">时长</th></tr></thead><tbody><tr><td align="center">论人类不平等的起源和基础</td><td align="center">【法】让-雅克·卢梭</td><td align="center">01-01</td><td align="center">01-05</td><td align="center">6h</td></tr><tr><td align="center">社会主义：经济学与社会学的分析</td><td align="center">【奥】 路德维希·冯·米瑟斯</td><td align="center">01-01</td><td align="center">01-10</td><td align="center">10h</td></tr><tr><td align="center">心理测量者</td><td align="center">【日】深真见</td><td align="center">01-03</td><td align="center">01-05</td><td align="center">6h</td></tr><tr><td align="center">论革命</td><td align="center">【德】汉娜·阿伦特</td><td align="center">01-05</td><td align="center">01-20</td><td align="center">12h</td></tr><tr><td align="center">新常识：一党专政的性质和后果</td><td align="center">张雪忠</td><td align="center">01-15</td><td align="center">01-20</td><td align="center">4h</td></tr><tr><td align="center">论科学与艺术的复兴是否有助于使风俗日趋纯朴</td><td align="center">【法】让-雅克·卢梭</td><td align="center">01-21</td><td align="center">01-25</td><td align="center">4h</td></tr><tr><td align="center">地球脉动：前所未见的自然之美</td><td align="center">【英】阿拉斯泰尔·福瑟吉尔</td><td align="center">01-22</td><td align="center">01-25</td><td align="center">2h</td></tr><tr><td align="center">社会契约论 (译林人文精选)</td><td align="center">【法】让-雅克·卢梭</td><td align="center">01-23</td><td align="center">01-25</td><td align="center">4h</td></tr><tr><td align="center">中国国家治理的制度逻辑：一个组织学研究</td><td align="center">周雪光</td><td align="center">01-28</td><td align="center">02-07</td><td align="center">8h</td></tr><tr><td align="center">病毒星球</td><td align="center">【美]】尔·齐默</td><td align="center">01-28</td><td align="center">01-30</td><td align="center">4h</td></tr><tr><td align="center">病毒来袭</td><td align="center">【美】内森•沃尔夫</td><td align="center">01-29</td><td align="center">01-31</td><td align="center">2h</td></tr><tr><td align="center">血疫：埃博拉的故事</td><td align="center">理查德·普雷斯顿</td><td align="center">02-01</td><td align="center">02-08</td><td align="center">8h</td></tr><tr><td align="center">远古的葱茏：古植物王国</td><td align="center">周志炎</td><td align="center">02-05</td><td align="center">05-08</td><td align="center">4h</td></tr><tr><td align="center">古生物学简明教程</td><td align="center">朱才伐</td><td align="center">02-06</td><td align="center">02-10</td><td align="center">3h</td></tr><tr><td align="center">上帝造人有多难：生命的密钥</td><td align="center">朱钦士</td><td align="center">02-07</td><td align="center">02-12</td><td align="center">6h</td></tr><tr><td align="center">朱钦士的个人博客</td><td align="center">朱钦士</td><td align="center">02-08</td><td align="center">03-30</td><td align="center">8h</td></tr><tr><td align="center">远古的辉煌：生物大幅射</td><td align="center">戎嘉余</td><td align="center">02-13</td><td align="center">05-15</td><td align="center">6h</td></tr><tr><td align="center">牛津通识读本：地球</td><td align="center">【英】马丁·雷德芬</td><td align="center">02-13</td><td align="center">02-15</td><td align="center">6h</td></tr><tr><td align="center">生命活动的摇篮：细胞</td><td align="center">王耀发</td><td align="center">02-16</td><td align="center">02-18</td><td align="center">4h</td></tr><tr><td align="center">地球脉动2：奇迹世界</td><td align="center">【英】胡·科里</td><td align="center">02-24</td><td align="center">02-27</td><td align="center">3h</td></tr><tr><td align="center">一想到还有95<em>%的</em>问题留给人类，我就放心了</td><td align="center">【巴拿马】豪尔赫•陈</td><td align="center">03-07</td><td align="center">03-15</td><td align="center">4h</td></tr><tr><td align="center">历史的终结及最后之人</td><td align="center">【美】弗朗西斯·福山</td><td align="center">03-03</td><td align="center">03-10</td><td align="center">10h</td></tr><tr><td align="center">我無罪：劉曉波傳</td><td align="center">余杰</td><td align="center">03-13</td><td align="center">03-20</td><td align="center">8h</td></tr><tr><td align="center">神奇的生物化学</td><td align="center">神奇的生物化学</td><td align="center">03-23</td><td align="center">03-25</td><td align="center">4h</td></tr><tr><td align="center">费马最终定理</td><td align="center">【日】日冲樱皮</td><td align="center">03-26</td><td align="center">03-28</td><td align="center">3h</td></tr><tr><td align="center">被讨厌的勇气</td><td align="center">【日】岸見一郎</td><td align="center">03-28</td><td align="center">03-30</td><td align="center">4h</td></tr><tr><td align="center">鸟瞰古文明</td><td align="center">【法】 让-克劳德·戈尔万</td><td align="center">04-03</td><td align="center">04-10</td><td align="center">8h</td></tr><tr><td align="center">自由宪章</td><td align="center">【奥】弗里德里希·哈耶克</td><td align="center">04-01</td><td align="center">04-20</td><td align="center">16h</td></tr><tr><td align="center">盗火者：中国教育革命静悄悄</td><td align="center">邓康延 梁罗兴</td><td align="center">04-11</td><td align="center">04-20</td><td align="center">6h</td></tr><tr><td align="center">我们最幸福：北韩人民的真实生活</td><td align="center">【美】芭芭拉·德米克</td><td align="center">04-23</td><td align="center">04-26</td><td align="center">6h</td></tr><tr><td align="center">哈维尔文集</td><td align="center">【捷克】哈维尔</td><td align="center">04-24</td><td align="center">04-30</td><td align="center">8h</td></tr><tr><td align="center">布达佩斯往事：冷战时期一个东欧家庭的秘密档案</td><td align="center">【美】 卡蒂·马顿</td><td align="center">04-26</td><td align="center">04-30</td><td align="center">6h</td></tr><tr><td align="center">致命的自负：社会主义的谬误</td><td align="center">【奥】弗里德里希·哈耶克</td><td align="center">05-01</td><td align="center">05-30</td><td align="center">10h</td></tr><tr><td align="center">地球的演变故事</td><td align="center">姚建明</td><td align="center">05-02</td><td align="center">05-05</td><td align="center">4h</td></tr><tr><td align="center">图解科技译丛：漫画元素118</td><td align="center">【日】斋腾胜裕</td><td align="center">05-02</td><td align="center">05-03</td><td align="center">2h</td></tr><tr><td align="center">颓废与沉默：透视犬儒文化</td><td align="center">徐贲</td><td align="center">05-02</td><td align="center">05-10</td><td align="center">4h</td></tr><tr><td align="center">统治与教育：从国民到公民</td><td align="center">徐贲</td><td align="center">05-03</td><td align="center">05-25</td><td align="center">8h</td></tr><tr><td align="center">三角距离无限为零1-4</td><td align="center">【日】岬鹭宫</td><td align="center">05-05</td><td align="center">05-25</td><td align="center">10h</td></tr><tr><td align="center">被禁锢的头脑</td><td align="center">【立】切斯瓦夫·米沃什</td><td align="center">05-05</td><td align="center">05-10</td><td align="center">6h</td></tr><tr><td align="center">人以什么理由来记忆</td><td align="center">徐贲</td><td align="center">05-02</td><td align="center">05-10</td><td align="center">10h</td></tr><tr><td align="center">宇宙从一粒尘埃开始：9堂极简宇宙课</td><td align="center">【英】布莱恩•考克斯</td><td align="center">05-25</td><td align="center">05-30</td><td align="center">5h</td></tr><tr><td align="center">通往尊严的公共生活</td><td align="center">徐贲</td><td align="center">05-25</td><td align="center">05-30</td><td align="center">10h</td></tr><tr><td align="center">宇宙从起源到未来</td><td align="center">【美】约翰·布罗克曼</td><td align="center">06-18</td><td align="center">06-25</td><td align="center">5h</td></tr><tr><td align="center">kubernetes 网络权威指南</td><td align="center">杜军</td><td align="center">06-20</td><td align="center">06-27</td><td align="center">6h</td></tr><tr><td align="center">Linux开源网络全栈详解：从DPDK到OpenFlow</td><td align="center">英特尔亚太研发有限公司</td><td align="center">06-20</td><td align="center">06-23</td><td align="center">3h</td></tr><tr><td align="center">大话处理器</td><td align="center">万木杨</td><td align="center">06-21</td><td align="center">06-21</td><td align="center">2h</td></tr><tr><td align="center">三角的距离无限为零5</td><td align="center">【日】岬鹭宫</td><td align="center">06-24</td><td align="center">06-25</td><td align="center">2.5h</td></tr><tr><td align="center">大话存储</td><td align="center">张冬</td><td align="center">06-27</td><td align="center">07-21</td><td align="center">18h</td></tr><tr><td align="center">布拉格精神</td><td align="center">【捷】伊凡·克里玛</td><td align="center">07-01</td><td align="center">07-10</td><td align="center">6h</td></tr><tr><td align="center">徐贲文集</td><td align="center">徐贲</td><td align="center">07-10</td><td align="center">07-30</td><td align="center">30h</td></tr><tr><td align="center">生命通史</td><td align="center">朱钦士</td><td align="center">04-10</td><td align="center">08-20</td><td align="center">60h</td></tr><tr><td align="center">Kubernetes 源码剖析</td><td align="center">郑东旭</td><td align="center">08-01</td><td align="center">08-10</td><td align="center">10h</td></tr><tr><td align="center">Kubernetes 指南第四版</td><td align="center">龚正，吴治辉，崔秀龙</td><td align="center">08-10</td><td align="center">08-30</td><td align="center">8h</td></tr><tr><td align="center">媒介批判三部曲</td><td align="center">【美】尼尔·波兹曼</td><td align="center">09-01</td><td align="center">09-30</td><td align="center">20h</td></tr><tr><td align="center">时光沙漏</td><td align="center">【日】さと(</td><td align="center">09-13</td><td align="center">09-13</td><td align="center">1h</td></tr><tr><td align="center">Just Because!</td><td align="center">【日】鸭志田一</td><td align="center">09-13</td><td align="center">09-14</td><td align="center">4h</td></tr><tr><td align="center">我的青春戀愛物語果然有問題</td><td align="center">【日】渡航</td><td align="center">09-15</td><td align="center">09-30</td><td align="center">30h</td></tr><tr><td align="center">kubernetes 源码分析</td><td align="center">郑东旭</td><td align="center">10-01</td><td align="center">10-07</td><td align="center">15h</td></tr><tr><td align="center">安达与岛村 1-8</td><td align="center">【日】入间人间</td><td align="center">11-15</td><td align="center">11-20</td><td align="center">20h</td></tr><tr><td align="center">复杂生命的起源</td><td align="center">【英】 尼克·莱恩</td><td align="center">11-30</td><td align="center">12-07</td><td align="center">15h</td></tr><tr><td align="center">来自新世界</td><td align="center">【日】贵志祐介</td><td align="center">11-30</td><td align="center">12-10</td><td align="center">20h</td></tr><tr><td align="center">政宗君的復仇</td><td align="center">【日】竹冈叶月</td><td align="center">12-05</td><td align="center">12-07</td><td align="center">6h</td></tr><tr><td align="center">星际穿越</td><td align="center">【美】基普·索恩</td><td align="center">12-10</td><td align="center">12-12</td><td align="center">4h</td></tr><tr><td align="center">Life 生命</td><td align="center">【美】约翰·布罗克曼</td><td align="center">12-12</td><td align="center">12-23</td><td align="center">8h</td></tr><tr><td align="center">美丽新世界</td><td align="center">【英】阿道司·赫胥黎</td><td align="center">12-14</td><td align="center">12-18</td><td align="center">8h</td></tr><tr><td align="center">樱花庄的宠物女孩</td><td align="center">【日】鸭志田一</td><td align="center">12-13</td><td align="center">12-21</td><td align="center">36h</td></tr><tr><td align="center">生命的跃升</td><td align="center">【英]】尼克·莱恩</td><td align="center">12-22</td><td align="center">12-26</td><td align="center">8h</td></tr><tr><td align="center">消失的微生物：滥用抗生素引发的危机</td><td align="center">【美】马丁•布莱泽</td><td align="center">12-28</td><td align="center">01-02</td><td align="center">8h</td></tr></tbody></table><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><ul><li>社会契约论</li><li>论人类不平等的起源和基础</li><li>论科学与艺术的复兴是否有助于使风俗日趋纯朴</li><li>致命的自负：社会主义的谬误</li><li>社会主义：经济学与社会学的分析</li><li>中国国家治理的制度逻辑：一个组织学研究</li><li>我们最幸福：北韩人民的真实生活</li><li>布达佩斯往事：冷战时期一个东欧家庭的秘密档案</li><li>被讨厌的勇气</li><li>颓废与沉默：透视犬儒文化</li><li>统治与教育：从国民到公民</li><li>人以什么理由来记忆</li><li>通往尊严的公共生活</li><li>布拉格精神</li><li>徐贲文集</li><li>生命通史</li><li>复杂生命的起源</li><li>生命的跃升</li><li>来自新世界</li></ul><h2 id="政治-哲学"><a href="#政治-哲学" class="headerlink" title="政治/哲学"></a>政治/哲学</h2><h3 id="社会主义：经济学与社会学的分析"><a href="#社会主义：经济学与社会学的分析" class="headerlink" title="社会主义：经济学与社会学的分析"></a>社会主义：经济学与社会学的分析</h3><p>这本书是 2020 年读的第一本书，这本书可以和哈耶克的《通往奴役之路》结合着读。本书出版于 1922 年，分别从多个领域（政治、经济、文化、伦理、宗教…）论述了社会主义必定失败的悲惨结局，对当时的社会尤其青年学生来讲冲击相当的大，那时候 CCP 刚刚成立才 1 年哦。</p><p>先说一下作者，路德维希·冯·米塞斯作为“<a href="https://zh.wikipedia.org/wiki/奧地利經濟學派" target="_blank" rel="noopener">奥地利经济学派</a>的院长”，现代<a href="https://zh.wikipedia.org/wiki/自由意志主義" target="_blank" rel="noopener">自由意志主义</a>运动的主要领导人，也是<a href="https://zh.wikipedia.org/wiki/古典自由主義" target="_blank" rel="noopener">古典自由主义</a>第一把交椅，其影响力不言而喻。他的学生更是青出于蓝胜于蓝：弗里德里希·冯·哈耶克、弗里茨·马克卢普、戈特弗里德·冯·哈伯勒、奥斯卡·摩根斯坦、威廉·勒普克、理查德·冯·施特里戈尔、艾尔弗雷德·舒茨、费里克斯·考夫曼、埃里克·沃格林、格奥尔格·哈尔姆、保罗·罗森斯坦-罗丹、莱昂内尔·罗宾斯。在他的学生当中，哈耶克获诺贝尔经济学奖，弗里茨·马克卢普、戈特弗里德·冯·哈伯勒曾先后任美国经济学会会长。</p><blockquote><p>我们感到，我们成长于其中的那个文明已经崩溃。我们立志建设一个更美好的世界，而正是这种再造社会的渴望，鞭策我们投身经济学研究。社会主义许诺给我们一个更加理性、更加公正的世界。此时，《社会主义》问世了，我们的信念坍塌了。《社会主义》对我们说，我们的方向错了。</p></blockquote><p><code>摘抄</code> <a href="https://t.co/mSj0qay7jW" target="_blank" rel="noopener">社会主义：经济学与社会学的分析</a></p><blockquote><p>米塞斯在书中分别从多个领域（政治、经济、文化、伦理、宗教…）对【各种流派】的社会主义进行猛烈批判。其抨击的火力之猛，实属罕见。</p></blockquote><p>另外推荐读一下 <a href="https://program-think.blogspot.com/2018/09/Book-Review-The-Errors-of-Marxism-Leninism.html" target="_blank" rel="noopener">为什么马克思是错的？——全面批判马列主义的知名著作导读</a> 。</p><blockquote><p>作者<a href="https://zh.wikipedia.org/wiki/路德維希·馮·米塞斯" target="_blank" rel="noopener">路德维希·冯·米塞斯</a>是奥地利学派的干将，并对同一学派的哈耶克有重大影响。在哈耶克的很多著作和理论中，都可以看到米塞斯的影子。<br>　　米塞斯的成就长期被学术界忽视（甚至是排斥）。一方面是他的理论太超前，另一方面是他的性格太激烈——与人交流时总是一针见血，不留情面，毫不顾忌他人感受。<br>　　说到【超前性】，他可能是经济学界最早意识到“【博弈论】重要性”的那个人（时间是20世纪初期）。几十年后，与冯·诺依曼共同发表划时代论文《博弈论与经济行为》的那个摩根斯坦（前面俺提过此人），就是米塞斯的学生。</p></blockquote><h3 id="论人类不平等的起源和基础"><a href="#论人类不平等的起源和基础" class="headerlink" title="论人类不平等的起源和基础"></a>论人类不平等的起源和基础</h3><p>这本书是我在看《心理测量者》动画的时候提到的，在看小说的时候也见到过。于是就拿来读了一下，<code>Kindle Unlimited</code>  的会员可以在 Amazon 商店免费借阅到。</p><p>《论人类不平等起源和基础》是卢梭应法国第戎科学院的征文而撰写的第二论文，第一篇论文是《论科学与艺术的复兴是否有助于使风俗日趋纯朴》。在本书中，卢梭阐发了自身的政治哲学，为《社会契约论》的写作奠定了基础。卢梭将人类历史的发展过程视作进步与退化的矛盾统一体。他一方面借助当时有关自然状态下人的人类学材料，一方面展开辩证的想象，回顾了人类由自然状态向社会状态过渡的历史进程，指出人类的进步史同时也是人类的堕落史，因为人类每向前发展一步，不平等的程度即加深一步。而私有制的确立，是造成人类不平等及其后果的关键环节。</p><p>正是这样的假设，使人们得以明白“我们并非生来如此”，只是“已然如此”。既然处于自然状态下的人类只是一个抽象化的形象，即一种“无”的境界，那么我们当然不能说卢梭的目的是让人类回到这个本就不存在的形象了。他只是企图以这个“无”的境界为起点，向人们展示出人类是如何一步步变成现在的样子，从而进一步思考，要想摆脱现在的困境，我们所需要做出的努力。本文为我们提供的反思就像那高速路上的缓冲带，只有停留在缓冲带上的那一秒钟，人类才终于真正地思考。</p><p><code>摘抄</code> <a href="https://t.co/oTmpnrHLKS" target="_blank" rel="noopener">论人类不平等的起源和基础</a></p><h3 id="论科学与艺术的复兴是否有助于使风俗日趋纯朴"><a href="#论科学与艺术的复兴是否有助于使风俗日趋纯朴" class="headerlink" title="论科学与艺术的复兴是否有助于使风俗日趋纯朴"></a>论科学与艺术的复兴是否有助于使风俗日趋纯朴</h3><p><code>摘抄</code> <a href="https://t.co/Vsq6Lc1FeW" target="_blank" rel="noopener">论科学与艺术的复兴是否有助于使风俗日趋纯朴</a></p><h3 id="社会契约论"><a href="#社会契约论" class="headerlink" title="社会契约论"></a>社会契约论</h3><p>按照卢梭的第一篇论文《论科学与艺术的复兴是否有助于使风俗日趋纯朴》和第二篇论文《论人类不平等的起源和基础 》的分析，人本来是纯朴善良的，由于有缺陷的社会制度，生活于社会中的人才变坏，并堕入罪恶的深渊。由文明引发的问题必须通过新的政治组织形式来加以克服。《社会契约论》要做的工作是，通过建立一个健全的社会政治制度，帮助人们恢复自然良善（natural goodness）。</p><p>《社会契约论》的核心思想是：合法的国家必须根据普遍意志来进行管理。想要读懂这本书还需要读卢梭的另外两篇论文，第一论文（《论艺术与科学》）和第二论文论人类不平等的起源和基础》，卢梭主要思考的是文明社会中种种罪恶与不幸，并解释它们的起源；那么，从《社会契约论》开始，卢梭则致力于思考如何改变这种状况。</p><p>什么样的社会政治制度才是健全的呢？这就要追问一个核心问题：正义与合法的政治秩序及其基础是什么？《社会契约论》所有其他的问题均是从这里生发出来，并与之关联在一起的。《社会契约论》共有四卷，第一卷讨论的是合法的政治秩序的基础；第二卷讨论的主题是法律和立法；第三卷的主题是普遍意志运用于特定情形即政府的机制；第四卷，这一卷以对罗马的政治制度的描述为核心内容，以此来探讨政治共同体的凝聚力问题，最后以公民宗教结束全书。</p><p>《社会契约论》的核心思想就是<strong>合法的国家必须根据普遍意志来进行管理，即已提出</strong>。《爱弥儿》背后的一个基本预设是：没有文化做支撑，制度是没有办法有效运行的。因此，最重要的任务是：通过教育，将“人”转变为“公民”，像爱弥儿一样的公民。唯其如此，普遍意志才有可能，正义而合法的政治秩序才有可能。</p><p>按照第一论文和第二论文的分析，人本来是纯朴善良的，由于有缺陷的社会制度，生活于社会中的人才变坏，并堕入罪恶的深渊。由文明引发的问题必须通过新的政治组织形式来加以克服。《社会契约论》要做的工作是，<strong>通过建立一个健全的社会政治制度，帮助人们恢复自然良善。</strong> 找到一种结合形式，凭借它可以运用所有共同的力量来捍卫和保护每个结合者的人身和财产，这种形式使得每个结合者虽然与所有人结合在一起，但是只服从自己，并且一如既往地自由。”这就是社会契约所要解决的根本性问题。社会契约可以简化为如下词句：<strong>我们中的每个人将其自身及其所有的力量共同置于普遍意志的最高领导之下，而将每个成员作为整体不可分割的部分纳入整体。</strong> 在《爱弥儿》背后的一个基本预设是：没有文化做支撑，制度是没有办法有效运行的。因此，最重要的任务是：通过教育，将“人”转变为“公民”，像爱弥儿一样的公民。唯其如此，普遍意志才有可能，正义而合法的政治秩序才有可能。所依理解卢梭的思想，最好是从第一篇论文、第二篇论文、社会契约论、爱弥尔 这样的顺序读完。</p><p>所以卢梭的这几本书连贯性很强，都读完才能理解卢梭的政治哲学思想。</p><p><code>摘抄</code> <a href="https://kindle.502.li/" target="_blank" rel="noopener">社会契约论</a></p><h3 id="新常识：一党专政的性质与后果"><a href="#新常识：一党专政的性质与后果" class="headerlink" title="新常识：一党专政的性质与后果"></a>新常识：一党专政的性质与后果</h3><p>这本书是张雪忠教授写的，写作风格和张千帆、许章润、张维迎他们一样。比较喜欢这样的老师，关于张雪忠教授，维基百科上有一段：</p><blockquote><p>2013年5月，张雪忠首先在网络公开一份中国官方的“<a href="https://zh.wikipedia.org/wiki/七不讲" target="_blank" rel="noopener">七不讲</a>”的内部材料的内容。其后得到其他学者和教授的证实。“七不讲”是中共中央在2013年在意识形态领域的指令，确定七个领域为禁区：<a href="https://zh.wikipedia.org/wiki/普世价值" target="_blank" rel="noopener">普世价值</a>、<a href="https://zh.wikipedia.org/wiki/新闻自由" target="_blank" rel="noopener">新闻自由</a>、<a href="https://zh.wikipedia.org/wiki/公民社会" target="_blank" rel="noopener">公民社会</a>、<a href="https://zh.wikipedia.org/wiki/公民权利" target="_blank" rel="noopener">公民权利</a>、中国共产党的历史错误、<a href="https://zh.wikipedia.org/wiki/权贵资产阶级" target="_blank" rel="noopener">权贵资产阶级</a>、<a href="https://zh.wikipedia.org/wiki/司法獨立" target="_blank" rel="noopener">司法独立</a>。随后“七不讲”成为网络禁词，张的新浪微博再次被删号。<a href="https://zh.wikipedia.org/wiki/张雪忠#cite_note-rfa2-6" target="_blank" rel="noopener">[6]</a></p></blockquote><p>这一件事不得报道、那一本书不得出版、这句话不能讲，删贴封号等，表面上言论审查是在侵犯言论自由，但实质上却是在贬低全体国民的人格和尊严。言论审查完全是在向全体国民宣告：“你们这帮屁民根本就没有资格了解这件事情的真相，也没有资格去思考和辨别信息的真假。”，价值判断的标准由真理部说了算。一个人与一头猪的最大区别，就在于人具有猪所没有的理智，而言论审查恰恰是在剥夺人们自由运用理智的资格，也就是尽量缩小人与猪之间的差别。专制统治者确实希望国民忘记自己是有理智的动物，并能像猪一样容易满足，只需有足以果腹的食物，就会对统治者感恩戴德。</p><blockquote><p>全体国民作为主权者组建政府并选任执政者，本是为了更好地保护自己的生命、财产和自由。政府的目的和执政者的使命，是保护主权者本来就享有的权利和自由，而不是赐予主权者本来不享有的权利和自由。执政者认为国民的权利和追求幸福的机会，是源于自己的赏赐，就像子女认为父母的存在是出于自己的意志一样荒谬和悖理。</p></blockquote><p><code>摘抄</code> <a href="https://t.co/1vyK1t0NMr" target="_blank" rel="noopener">新常识：一党专政的性质与后果</a></p><h3 id="中国国家治理的制度逻辑：一个组织学研究"><a href="#中国国家治理的制度逻辑：一个组织学研究" class="headerlink" title="中国国家治理的制度逻辑：一个组织学研究"></a>中国国家治理的制度逻辑：一个组织学研究</h3><p>这本书是春节的时候在家读完的，较之于张雪忠教授的《新常识：一党专政的性质和后果》，周雪光教授从组织学角度来进行分析中共国家治理得逻辑。对于这次得疫情来讲，再一次印证了书中所阐释的内容。<strong>即一统体制与有效治理：中国国家治理的一个深刻矛盾</strong>。不做过多评论，此书如同推特上的一些人推荐一样，很适合当下去看看，去分析一下这个官僚体制是多么地腐败和无能。就如《心理测量者》中所说的，<strong>我们始终承担着政府强加给我们的风险</strong>，这是权力集中化的必然结果。那些已经集中起来的权力绝对不会因为他美好的愿景而变得无害。那些死在武汉肺炎病毒之外的人不正是我们每个人都要承担的风险吗</p><p>在专制国家，权力不受约束的统治者，是普遍的政府腐败和各种社会问题的根由，也是人类文明社会最大的<code>病毒</code> 。也正是正是这个腐败无能的官僚体制欺上瞒下、删帖封号、维稳抓人、封杀言论、拘留记者、抓捕律师、造谣式辟谣等等作恶行为才导致的全球疫情大爆发。其实这些时刻伴随着我们，只不过是这次的病毒将这个体制的一个阴暗面揭露了出来而已，它腐烂到根里已经很久很久……</p><p>在极权主义体制下，国家一方面用意识形态蛊惑和麻醉人民，另一方面又用利用国家机器限制社会内部的直接交往，使之保持有利于国家控制的“原子化”状态。基于国家的绝对权力和整个社会的非结构化，国家能够根据自己的意志发起任何行动，包括政治或社会运动。这次的<code>疫情防卫战疫</code>不就是这个官僚体制发起的政治运动嘛？感染死亡人数作假，公信力不断地丧失。你能在这本书里找到很好的解释，书中也提到过上级来视察的时候，地方政府如何忽悠中央，以及各种权利关系之间如何共谋达到<strong>上有政策下有对策的</strong>。</p><p>『卡理斯玛权威的核心是，领袖以其超凡禀赋而得到追随者的拥戴和服从；而领袖则通过不断地创造“奇迹”来显示其超凡禀赋，以延续和强化这一合法性基础。 在经过了战争动荡，民生凋敝，丧权辱国的民族危机之后，中国大地有期冀奇迹、崇尚伟人的卡理斯玛权威的肥沃土壤。』</p><p>『任何挑战卡理斯玛权威的话语都会弱化甚至瓦解其合法性基础，因此话语垄断权是维系卡理斯玛权威的关键所在。建国以后，国家逐步通过官僚体制介入、控制以至垄断意识形态相关的领域，有效地杜绝了质疑或挑战卡理斯玛权威的潜在可能性』 这也是言论审查的根本原因吧，维护统治者的权力合法性。</p><p>在政治运行过程中，我们不难看到地方政府的各种做法（如在拆迁、严打、城管、信访等等过程中的具体所为）常常与法律条文相悖。地方政府的这些做法在很大程度上增强了基层政府解决实际问题的能力，但与此同时，它们不断地侵蚀弱化法治基础和法理观念。</p><p><code>摘抄</code> <a href="https://t.co/tl1mmh7z3t" target="_blank" rel="noopener">中国国家治理的制度逻辑：一个组织学研究</a></p><h3 id="国家建设与政府行为"><a href="#国家建设与政府行为" class="headerlink" title="国家建设与政府行为"></a>国家建设与政府行为</h3><p>读完《中国国家治理的制度逻辑：一个组织学研究》后在 Amazon 上搜索周雪光作者找到的书。与其说是一本书，其实更像是一册研究中国官僚体制的论文集，从学术角度来分析一些体制问题。</p><blockquote><p>作为所有权力集于一身的中央政府，主要需要完成两项基本任务：一是为广大百姓提供基本的公共服务，维持政权的长期稳定；二是保证下放给行政代理人的权力不被滥用，中央的政令能够畅通无阻。这两项任务本质上是冲突的：一方面，为了给广大百姓更好地提供公共服务，就必须尽可能把权力下放给基层政府，因为基层政府相对来说更了解当地民众对公共服务的偏好，更了解当地的具体条件；从公共服务的角度，集权者应该尽可能选择分权。另一方面，给定下级政府的官员目标和利益不同于中央政府，下级官员的行为不易监督，权力下放就意味着权力被滥用的危险，甚至被架空，而且权力下放越是到基层，监督就越困难，权力被滥用的威胁也就越大。</p><p>当政府默许或鼓励下级政府因地制宜时，后者可能按自己意图解读实施政策，随着政策实施过程的展开，执行灵活性越来越大，与这一主线的偏差距离越来越大，导致与原政策相去甚远的结果。</p></blockquote><p>结合这次疫情，不难理解为什么地方政府擅自封路封城的举措，即便这些举措已经明显地违反了法律（国务院颁布的规定），即便是因为封路而造成人员意外身亡，即便是一家四口在家打麻将也要被拉上街被<code>批斗</code>……中央政府也不会处罚地方政府。在这次疫情中，地方政府的一些行为已经违反了宪法，简称违宪行为，而所谓的<code>红袖章</code>仗着点手中的特权肆意侵犯着公民的权力。就如剩余价值被封杀的那期中罗新老师提到的：</p><blockquote><p>我们现在听很多人大谈<strong>战时状态</strong>，但随便一个行政官员就能够宣布”战时状态”吗？这必须是要经过最高立法机构决定的。封城或者诸如此类的极端措施带来的伤害，一定会比病毒本身还要大。</p></blockquote><p><code>摘抄</code> <a href="https://t.co/7oYY1ZTdAL" target="_blank" rel="noopener">国家建设与政府行为</a></p><h3 id="我们最幸福：北朝鲜人民的真实生活"><a href="#我们最幸福：北朝鲜人民的真实生活" class="headerlink" title="我们最幸福：北朝鲜人民的真实生活"></a>我们最幸福：北朝鲜人民的真实生活</h3><p>读完这本书就感觉到当今的朝鲜就如上世纪的中国<strong>十年文革基础上再加上三年大饥荒</strong>一样悲惨，这种纪实类的写作和《切尔诺贝利的悲鸣》以及《十个人的一百年》一样，沉重的历史感。我们都是被共产主义的极权专制独裁暴政统治蹂躏过的民族，感同身受的历史记忆，彷佛就在映射着当下一样，让人有种身在历史中感受它的存在一样。看看下面这几段摘抄，和文革时期的我们以及当下的我们又是何其的相似：</p><blockquote><p>  由于北韩太贫困，电力供应不足以维持电子监控，所以国家安全必须仰赖人力情报——告密。报纸偶尔会出现文情并茂的报导，描述勇敢的孩子纠举父母的违法行为。由此看来，因发表对当局不满的言论而被邻居告发也就不觉得奇怪了。</p></blockquote><blockquote><p>  北韩人学会吞下自己的自尊与捏住自己的鼻子。他们从农村动物的排泄物中挑出来未被消化的玉米粒。船厂工人发展处一种技术，原本储存粮食的货仓底部残留着腐臭黏腻的东西，他们将这些东西刮起了，放在地面晾干，从中可以拾取一点未烹煮过的稻米与其他可食用的谷物。</p></blockquote><blockquote><p>  孩子睡觉时要提防其他帮派偷走他们的少许余粮。此外也流传着许多诡异的故事，提到成年人把孩子当成猎物。不只用来发泄性欲，也当成食物。金赫听说有人对孩子下毒，杀死孩子，大卸八块吃下肚。在火车站后面，靠近铁道边，有些小贩在小火炉上煮汤煮面，据说浮在上面的灰色肉块就是人肉。</p></blockquote><blockquote><p>  各级督导例行性地捏造农业生产与工业产出的统计数据，因为他们不敢告诉长官实情。为了圆谎，只好说更多的谎，从基层传达到高层的讯息没有一件是真的，所以可以想见金日成本人恐怕完全不知道经济的状况有多糟。</p></blockquote><p>看完这本书也可以去看另外一本书《黄长烨回忆录》</p><blockquote><p>  我在一个充满了虚伪和欺骗的社会生活了很久，一开始我以为虚伪和欺骗是为了解放勤劳的人民大众，即为了取得与剥削阶级斗争的胜利而必须采用的手段。 但是，后来我意识到，虚伪与欺骗已经与独裁者的利己主义结合起来。独裁者的利己主义集中体现为个人崇拜思想，北朝鲜是全世界个人崇拜和阶级主义最严重的国家。 我身处北朝鲜统治体制的中枢，是整个虚伪宣传的动员和组织者（作者是北朝鲜马克思主义和意识形态领域的权威，译者注）。虚伪曾经一度取代真理占据一个学者的良心，与学者的灵魂对立。 我（在书中）不会因为讨厌我和让我讨厌的人而夸大、丑化事实，也不会因为爱我和让我爱的人而毫无原则的美化现实。 历史就摆在那里，对历史来说，歪曲是最大的犯罪。我不认为我说的就是绝对（正确），我反倒更希望读者带着批判的态度来阅读本书。 对于与大众利益毫无关系的个人生活，或者有干涉它国内政之嫌的言论，我会尽量避免。来到韩国之后，我在努力学习新事物，开始新的体验。 但是，我已经老了，学到的新知识和新经验对我思考方法的影响有限。在本书中，我还是想将在北朝鲜经历过的、体验过的写出来。</p></blockquote><p>摘抄<a href="https://t.co/LWaF4VeGVq" target="_blank" rel="noopener">我们最幸福：北朝鲜人民的真实生活</a></p><h3 id="哈维尔文集"><a href="#哈维尔文集" class="headerlink" title="哈维尔文集"></a>哈维尔文集</h3><p>三月份在读《我无罪：刘晓波传》的时候意外收获到的这本书。这本书并没有在大陆公开出版，只能找到一点电子版的来看。本书的作者是哈维尔，大陆的译者是崔卫平。先说一下作者哈维尔，他是东欧人民战胜共产主义之后，1989年12月当选的总统。在他主持下，捷克和斯洛伐克和平分离，他又当选为捷克共和国首任总统，直到2003年连任期满，才卸任总统职务。</p><p>作为一位戏剧家、作家和哲学家，他是著名《七七宪章》运动的发起者和最早的发言人之一，他的思想深刻地影响了中国自由知识界。1998年一批中国的自由知识分子，要出版《哈维尔文集》，八九民主运动中“不在枪口下做官”的前中国社会科学院副院长 <a href="https://zh.wikipedia.org/wiki/%E6%9D%8E%E6%85%8E%E4%B9%8B" target="_blank" rel="noopener">李慎之</a>，为该书写了序——<a href="http://www.aisixiang.com/data/1724.html" target="_blank" rel="noopener">《无权者的权力和反政治的政治：后极权主义时代的人生哲学》</a>。</p><p>李慎之称哈维尔是“我们时代杰出的思想家”。 哈维尔提出“无权者的权利”的哲学命题，揭示了“<strong>因为恐惧，整个社会的谎言有了最现实也最妥当的理由，其结果就是责任感，对自己的良知的责任感，对社会正义的责任感的丧失</strong>。”李慎之认为哈维尔的这一学说“至今仍旧是对极权制度最深刻的批判。”哈维尔发动的《七七宪章》运动，就是公民行使自己的权利，敢于讲真话的运动。李慎之称赞哈维尔：“他最大的功绩就在于教导人们如何在后极权主义社会尊严地生活，做一个真正的人。”</p><blockquote><p>  因为恐惧。每个人都有东西可以失去，因此每个人都有理由恐惧：“因为害怕失去自己的工作。中学老师讲授他自己并不相信的东西，因为怕自己的前途不稳；学生跟在老师后面重复他的话，因为怕自己不被允许继续学业；青年人加入共青团，参加不论是否必要的活动。在这种畸形的制度下，因为恐惧自己的儿子或女儿无法在学校里取得必要的升学总分，使得父亲采用‘自愿’的方式去做每一件被要求的事。恐惧的结果，导致人们参加选举、给推荐出来的候选人投票，并且假装他们认为这种形同虚设的走过场是真正的选举。出于对生计、地位或者前程的恐惧，他们投票赞成每一项决议，或者至少保持沉默……。”</p><p>  怎样才能打破这种因处于恐惧之中而凭借谎言生活的现实呢?哈维尔的答案十分简单，即“在真实中生活”，或曰“在真理中生活”，英文是Living in Truth!这句话看起来太理想、太虚无飘渺，但是我倒也不想建议译者改变译文，因为如果用大白话来说，它无非是指“过说真话的日子”或者是“生活在真话中”、“做一个说真话的人”而已。</p></blockquote><p>摘抄<a href="https://t.co/3yjW5T3OW4" target="_blank" rel="noopener">哈维尔文集</a></p><h3 id="布达佩斯往事：冷战时期一个东欧家庭的秘密档案"><a href="#布达佩斯往事：冷战时期一个东欧家庭的秘密档案" class="headerlink" title="布达佩斯往事：冷战时期一个东欧家庭的秘密档案"></a>布达佩斯往事：冷战时期一个东欧家庭的秘密档案</h3><p>在二月份的时候剩余价值里的一期节目中提到过《布达佩斯往事：冷战时期一个东欧家庭的秘密档案》。本书通过冷战时期匈牙利秘密警察长达20年的档案，所揭开的是一部隐藏了几十年的家庭历史和时代侧记。</p><p>冷战时期，苏联集团中的匈牙利，秘密警察通过庞大的告密网，试图全面渗透控制匈牙利的政治生活。作者的父母原是匈牙利著名记者，他们的报道是西方了解匈牙利的重要信息来源。因此他们被视为“人民的敌人”，长期受秘密警察的监控，终因叛国和间谍罪而先后入狱。一家移居美国后，匈牙利政府却又异想天开地试图招募他们当间谍，而美国也对他们进行了几年的监控。书中不只还原了马顿夫妇被告密者包围的经历和遭遇，他们的抗争、坚守、脆弱和勇气，也展现了他们情感和内心的矛盾——夫妻之间相互的感情背叛与灾难中的支撑，父母子女之间的爱与亲情，人性的坚强与软弱，从而使得这本书更为丰富、复杂，具有血肉。</p><p>值得一提的是这本书，而这本书的序言正是徐贲老师写的。</p><blockquote><p>  这种统治下的恐惧、屈辱、压抑和绝望，这样的苦难让熬过来的和还未熬过来的人们都更加期待一个能让所有人自由、平等、有尊严的生活世界，也更加期待一种人与人能够彼此信任，而不是相互背叛、出卖的生存方式。这种期待中包含着对人类未来的希望，《布达佩斯往事》之所以感人，正是因为它传递了这样的希望讯息。</p></blockquote><p>摘抄 <a href="https://t.co/NmRoJATcau" target="_blank" rel="noopener">布达佩斯往事：冷战时期一个东欧家庭的秘密档案</a></p><h3 id="人以什么理由来记忆"><a href="#人以什么理由来记忆" class="headerlink" title="人以什么理由来记忆"></a>人以什么理由来记忆</h3><p>之前我也读过徐贲的论文 <a href="https://matters.news/@philosophia1979/徐贲-中国的-新极权主义-及其末世景象-野兽荐读-bafyreiegbg5tti3ljc7newaah5wp36ncf7fvb2oaovd6p7elc4xqfhbcd4" target="_blank" rel="noopener">《中国的“新极权主义”及其末世景象》</a>) ，所以对他关注的内容也有所了解。总感觉这本书更像是阿伦特、加缪、萨特、哈维尔等人对于极权主义著作及思想的解析。就像在剩余价值里提到的，我们读这些历史的时候，而当下就仿佛置身于历史之中一样。书中记录苏联和纳粹德国极权统治改造人性的言论审查、秘密警察、集中营、无言论自由和新闻自由、党媒愚民洗脑等，这些描述极权统治的历史，再看一看当下，我们不正置身于其中吗？</p><ul><li><strong>比瘟疫更可怕的是謊言，比災難更可怕的是遺忘</strong></li></ul><blockquote><p>  <strong>剩余价值：</strong> 李海鹏之前发了一条微博，大概是说，一个举国体制的隐患到最后可能又会变成一个举国体制的胜利。</p><p>  <strong>罗新：</strong>历史学者认为，在西方，你看到所有的战争、灾难性的革命或者是体制性的崩溃，其后果可能是引起了一波新的历史上升期。比如美国在经济大萧条之后，经济反而有所回升，反而开通了一条向上爬的新的道路。但是研究者也发现，在东方不一定是这样，灾难之后可能是更大的灾难，更大的灾难后面还有更大的灾难，引发灾难的那些因素不仅得不到修正，还得到了加强化。这是我们要注意的。人们说，都发生了这么大的事，我们该不该反思了？要小心，可能没有反思，可能是强化。</p></blockquote><p>一场灾难变成了一场举国体制的胜利，是我们的悲哀也是全世界被新冠病毒折磨人的不幸。一些无耻的人丧尽天良还在宣传什么正确的集体记忆，抗疫主旋律，好多人的生命就这样被宏大叙事抹杀掉了。</p><blockquote><p>  因为抗疫叙事不能被谎言误导玷污，而应留下正确的人类集体记忆</p></blockquote><p><img src="img/image-20210106235706623.png" alt="image-20210106235706623"></p><p><img src="img/image-20210106235547786.png" alt="image-20210106235547786"></p><blockquote><p>  “对于一个民族来说，记忆对遗忘的抗拒，首先是知识精英的良知对强权的抗拒。否则的话，我们非但无法把六四大屠杀的真相、进而把独裁制度的罪恶变成民众的历史常识，也无法防止类似大悲剧的重演。难道中国历史在专制下恶性循环的时间还不够长吗？”</p></blockquote><p>最终，因为遗忘罪恶历史而受害的，只会是中国人自己。</p><p><strong>“用民间记忆抗拒官方的强制遗忘，就是为我们这个历尽苦难的民族保存记忆和良知。”</strong></p><blockquote><p>  人民“获得”的“国家历史”是那些记录下来，或者说被权力允许记录下来的“事件”，而那些没有被记录或不被允许记录下来的事件，就此被武断地从国家历史中剔除，也从族群记忆中排斥出去了。因此，对历史真实保持沉默，虽然是从改写历史开始，但最终却表现为族群的集体忘却。每个沉默的个人，每个在族群中按权力意志来记忆或忘却的人，都参与在以沉默代替真实，以沉默维持谎言的共谋之中。</p></blockquote><p>想起了 《1984》 里的一段话，或许用极权主义来解释当下最适合不过了：<strong>极权最有效的统治术是仇恨教育，塑造一个远在天边的外在敌人，人们就会忘记身边的痛苦。</strong></p><p>摘抄 <a href="https://t.co/qZ2ID5XeuR" target="_blank" rel="noopener">人以什么理由来记忆</a></p><h3 id="颓废与沉默：透视犬儒文化"><a href="#颓废与沉默：透视犬儒文化" class="headerlink" title="颓废与沉默：透视犬儒文化"></a>颓废与沉默：透视犬儒文化</h3><p>恰好读完这本书之后不久 B 站就上映了后浪洗脑宣传片，不料微博评论区也是翻车现场🤣</p><p>第一次听说到后浪的时候我就觉着，这类身居高位的犬儒知识份子，如胡锡进、胡鞍钢、金灿荣、张维为这类，为当权者歌功赞德、拍马溜须、谄媚献媚、阿谀奉承。这类人应该比任何人都清楚在这太平盛世的背后，抓捕了多少维权律师、迫害了多少异议人士、关押了多少公民记者、处分了多少直言教师。然这些知识分子、教授、专家在说假话，用所谓的”学术”来取悦和投靠权力和当权者,谋取私利，以貌似高深、渊博、精致的理论包装普通人用常识就能看穿的慌言，有的甚至还相当”富有创意”，善于”理论更新”,或有”理论建树”。</p><p><img src="img/image-20210106235133212.png" alt="image-20210106235133212"></p><p>在政治意识形态主导一切,权力可以操控一切的社会里,不存在所谓的”独立学术”,尤其不存在独立的人文学术。一些知识分子因为不得已而做”纯学问”,是一种憋屈的学术”自宫”。权力的咸胁与利诱造就体制性的”学术义儒”,它往往是一种在清醒状态下的装傻——一面自嘲,一面配合体制,积极自我审査；一面咒骂,一面迎合体制的无理要求；一面鄙视不懂学术的顶头上司,一面顺从他们的领导权威；一面嘲笑,一面参与为官员授予各种真的假学位和假头衔。</p><blockquote><p>  阿伦特在1963年7月24日给友人卡斯贝尔（Gerhard Casper）的信里写道:”人们经常发现,洗脑欺骗最肯定的长期后果就是造成犬儒主义——绝对不相信任何事情可能是真的,哪怕是确有实据的真实,也照样不相信。换言之,完全用谎言来代替事实真相的结果不是人们会把谎言当作真实,或者真实会被当作为谎言,而是我们赖以在真实世界里存在的知觉会被完全摧毁。人类为了生存,必须具备基本知觉,其中就有对真和假的识别。”</p></blockquote><blockquote><p>  阿伦特认为,社会中的多数人集体投向犬儒主义,是因为政治权力长期用谎言来代替真实,大规模地对群众进行洗脑并欺骗他们。这是20世纪才有的统治方式,最典型的例子就是斯大林统治时期否认托洛茨基曾对俄罗斯革命有过任何贡献。阿伦特称此为”极权谎言”,它要编造的是一种完全虚假的,因此彻底颠覆真伪区别的”真实”。</p></blockquote><p><strong>犬儒主义：</strong></p><ul><li>（1）娱乐至死（没有目标或信仰,得过且过）；</li><li>（2）看客心态（看穿、冷漠、围观,管了也没用,不如不管）；</li><li>（3）习惯性怀疑（上至政府,下至朋友,对谁都不信任,都不相信）；</li><li>（4）审丑心理（在一个是非不分的环境里,美丑、善恶、真假也无法辨别,何必要坚持真、善、美）；</li><li>（8）”鸵鸟心态”（多一事不如少一事,被宣传的现实反正是假的,不如”躲进小楼成一统”）;</li><li>（9）思考恐惧症（多思多惹事,有的是前车之鉴,你要我怎么说,我就怎么说,这才是安身保命之道）；</li><li>（11）炫富心态（看穿一些道德、理想、未来展望的虚妄,只有钱才是实在的,才是世人认可的唯一价值）；</li><li>（12）初老症（没有前途、没有未来、没有追求,过一天算一天,坐吃等死）；</li><li>（13）自虐心态（这个说法并不确实,因为一般人既非共产党又非体制,不是”自虐”,这种顾左右而言他的说法,明白人说糊涂话,既不诚实,也不真实,它本身就是犬儒主义的）。</li></ul><blockquote><p>  对犬儒的现代定义是有代表性的:一、挑刺、嘲笑、讽刺；二、不相信或装着不相信普通人接受的道德价值观和人类行为真诚的善良动机,把自私自利认作唯一可能的动机；轻蔑、鄙视、嘲讽的怀疑和不相信。</p></blockquote><p>刘晓波曾在 <a href="http://www.liu-xiaobo.org/blog/archives/12412" target="_blank" rel="noopener">刘晓波：在刀锋上行走——狱中读《布拉格精神》</a> 写过：</p><blockquote><p>  据克里玛的介绍，在前苏东极权下的捷克知识分子群体中，不仅出现了哈维尔这样的道义示范，而且有95％以上的人为了自由和良知而进行着各种形式的拒绝，只有不到5%的人甘愿堕落为卖身投靠者。这当然是让中国知识分子自觉羞愧的表现。我们没有捷克人那种清醒和坚韧，仅仅十年的时间，六四的伤口便被遗忘，这不光是因为官方的强制，也是民族灵魂的冷漠。知识分子群体不能以言行来洗刷耻辱，既源于外在的政治恐怖，更源于他们生命中洗刷耻辱的冲动已经死亡。</p></blockquote><p>摘抄<a href="https://t.co/3C2OUjki3P" target="_blank" rel="noopener">颓废与沉默：透视犬儒文化</a></p><h3 id="统治与教育：从国民到公民"><a href="#统治与教育：从国民到公民" class="headerlink" title="统治与教育：从国民到公民"></a>统治与教育：从国民到公民</h3><blockquote><p>  极权政体彻底控制与思想、言论、新闻有关的要害领域，教育是被管制得最严厉的领域之一，和宣传一样，被严格控制。这样的教育虽然与民主国家的教育一样被称为“教育”，但实际上已经成为政治权力控制国民思想和培养子民的工具。这与民主国家中学校教育作为公民社会文化机制的一部分，起到培养民主公民的作用，是完全不同的。</p></blockquote><blockquote><p>  纳粹统治德国，依靠的不仅是完全由纳粹控制和操纵的国家机器，政府、各级纳粹党组织、党卫军、冲锋队、警察等，而且更是无处不在的纳粹意识形态，它渗透到德国社会、文化、教育和家庭生活的每一个角落，确保纳粹政党成为德国主权的内核。正是由于纳粹政党实际上已经成为德国主权的内核，德国的国家主义才会按照纳粹的意志转变为符合纳粹党利益，并为它的利益服务的党国主义。</p></blockquote><blockquote><p>  在纳粹的极权统治制度中，学校进行的是一种由统治政党意识形态指挥的党化教育。这种党化教育渗透到教育的每一个环节之中，而在每一个环节中使这种党化意识形态顺利发生作用的正是无数直接从事教学工作的教师。党化教育迫使人们不断进行思想的相互纯洁和自我纯洁，它在课堂里发生之前，早就先已经在许多教师的头脑中发生了，并成为他们的思维和行为习惯。没有这样的教师，党化教育是不可能在学校里有效贯彻的。</p></blockquote><blockquote><p>  在极权国家里，国民必须有相同的正确表现，教师在学校里的行为被完全模式化了。教师们都忠于党，按党的要求去做，他们在学校的行为并不仅仅是“好教师”行为，同时也是“好国民”行为。当一个“好国民”，就是像所有其他国民一样对领袖、党和党国表现绝对的忠诚。“</p></blockquote><blockquote><p>  纳粹德国实行的是一种彻底的以国家主义为旗号的党化教育，这种教育从儿童开始，在课程、教学、教材、师生关系的每一个环节上都贯彻纳粹的极权统治原则。</p></blockquote><blockquote><p>  在《极权主义的起源》一书中，汉娜·阿伦特从极权主义原型的特点中概括出它成功统治的三大要素，它们分别是暴力和恐惧的统治，迫使人民成为相互隔绝的、无助无援的散沙个体，以及充分运用“组织”和“宣传”的力量。阿伦特亲身经历过她所思考的极权主义中最为成功的一种，那就是德国纳粹的极权。她对极权主义三要素的总结便是从她的直接经验中观察得出的。</p></blockquote><blockquote><p>  党的宣传要求新闻从“正面报道”，所以总是尽量不让坏消息曝光。它认为，坏消息不利于稳定人心，也可能被别人利用，所以，坏消息也成为一种不能泄露的“国家机密”。</p></blockquote><p>摘抄 <a href="https://t.co/PoWTqUQOQ7" target="_blank" rel="noopener">统治与教育：从国民到公民</a></p><h3 id="我無罪：劉曉波傳"><a href="#我無罪：劉曉波傳" class="headerlink" title="我無罪：劉曉波傳"></a>我無罪：劉曉波傳</h3><p>这本书是我在 <a href="https://twitter.com/linyujing" target="_blank" rel="noopener">林愈靜</a> 立场新闻的文章里上发现的。之前我是知道刘晓波是诺贝尔和平奖得主，也知道他的一些事迹，但通过这本传记才真真切切地了解到刘晓波是一位多么坚强的知识份子。包括独立中文笔会的发展，都离不开刘晓波先生的付出。</p><blockquote><p>劉曉波承認：「類似的殘忍行為以及對殘忍的自得其樂，我小時候沒少幹。這種行為與專門打砸搶、揪鬥別人的紅衛兵沒有什麼實質的區別。我們這些人，在一種野蠻的制度和教育之下長大，它崇尚暴力、培養仇恨、鼓勵殘忍、縱容無情，教給孩子們一種從娘胎裡帶出來的不拿人當人的殘暴兇狠。在視生命如草芥的年代，我們都在不同的程度上充當過劊子手和幫兇，誰也脫不掉責任，洗不清自己！」</p></blockquote><blockquote><p>我的整個青春期生長於文化沙漠之中，我所賴以寫作的文化滋養，除了仇恨、暴力、狂妄，就是說謊、無賴、犬儒，這些黨文化的毒素餵養了整整幾代人，我便是其中之一，即便在思想解放的八○年代，也並沒有完全擺脫黨文化。</p></blockquote><blockquote><p>劉曉波強調了言論自由的重要性：「一個政權不可能靠壓抑不同政見來建立合法性，也不可能靠文字獄來達成長治久安。」他呼籲中國早日告別文字獄：「只有從制度上根絕文字獄，憲法所規定的言論自由權利才能落實到每一位國民身上；只有當國民的言論自由權利得到制度化的現實保障，文字獄才會在中國大地上滅絕。」</p></blockquote><p><code>摘抄</code> <a href="https://t.co/eefs4gZspV" target="_blank" rel="noopener">我無罪：劉曉波傳</a></p><h3 id="Age-of-Ambition"><a href="#Age-of-Ambition" class="headerlink" title="Age of Ambition"></a>Age of Ambition</h3><p><code>摘抄</code> <a href="https://t.co/uvCqxbUb0i" target="_blank" rel="noopener">Age of Ambition</a></p><h3 id="自由宪章"><a href="#自由宪章" class="headerlink" title="自由宪章"></a>自由宪章</h3><p>《自由宪章》是这大半年来最难啃的书，哈耶克的书对于木子这种菜鸡来说读起来就是头大啊，和我在一月份读的《自由与繁荣的国度》味道一样。</p><p><strong>弗里德里希·哈耶克</strong>（Friedrich A·Hayek）是奥地利经济学家和政治哲学家。身为1974年的诺贝尔经济学奖的获得者之一，他主张以市场为基础的自由资本主义和有限的政府。此外，他还于1991年获得了总统自由勋章。</p><p>在这本书中，单单法治概念的含义，哈耶克本人就罗列引用了 30 多本著作！可见当时哈耶克本人的学术水平相当高滴！</p><blockquote><ul><li>《法律与秩序》</li><li>《教会、国家与研究》</li><li>《新利维坦》</li><li>《美国的行政司法及法律的最高地位》</li><li>《宪政政治与民主》</li><li>《政治与行政》</li><li>《现代共同体的基础》</li><li>《对良好社会原则探索》</li><li>《宪政与变动中的世界》</li><li>《民主国家与集权国家》</li><li>《行政与法治》</li><li>《现代政治诸要素》</li><li>《法治：保守的伦敦律师公会与工会协会进行的研究》</li><li>《法律：有关民主之中的权威的理论的论文》</li><li>《个人主义与法律》</li><li>《宪法学》</li><li>《宪法之保卫者》</li><li>《法治国家，还是独裁？》</li><li>《政治学》《法治国家有效性的界限》</li><li>《法治国家还是威权国家？》</li><li>《自由主义作为一种意识形态的没落》</li><li>《波恩基本法中的社会法治国家概念》</li><li>《作为刑法最新发展的中心概念的法治国家》</li><li>《法、国家、经济》</li><li>《从法律国家到法官国家》</li><li>《瑞士联邦国家法》</li><li>《德国行政法的体制》</li><li>《瑞士联邦法院的宪法管辖权》</li><li>《法制国家民主制》</li><li>《美国与瑞士宪法管辖权的政治意识形态上与法律意识形态上的根据》</li><li>《作为国家根本法律秩序的宪法》</li><li>《瑞士法律中的公民自由》</li><li>《法治国家的秩序》</li><li>《1955年雅典国际法学家大会报告》</li></ul></blockquote><p>虽然这本书早在1960年就已出版，但其深刻的见解时至今日仍然盛行。他所倡导的经济和个人自由理论适用于很多当今的热议话题，从物价上涨到累进税制。在书中，作者对比了建立有限政府的益处和实施中央计划经济的弊端。限制政府权力将会有利于提升个体能动性和创造力，进而推动人类知识和文明的进步。哈耶克论证了法律法规、合法程序和宪法政府对自由的积极作用，并指出个人自由所面临的严峻的潜在威胁。以下是本书的几个要点：</p><ul><li>有限的政府通过激发人的个体主动性来推动社会的进步。</li><li>财产权利和个人自由这一宽泛的政治概念有着密切的联系。</li><li>只有那些与约定俗成的道德观念相符的法律才能经得住时间的考验。</li><li>多数裁定原则自然很有必要，但仅仅依靠它还不足以建立一个自由社会。</li><li>宪政是美国追求自由事业最有力的武器。</li><li>社会主义是一种失败的政府形式，但它至今依然影响着公共政策的制定。</li><li>通过收入再分配来缓解贫困会带来意想不到的负面效应，比如“福利国家”的出现。</li><li>基于市场状况的奖励制度比基于个人优点的奖励制度更加有效。</li><li>比起通货紧缩，政府更倾向于通货膨胀。但过度的膨胀会威胁到自由。</li><li>限制政府对教育的干涉有利于社会保持思想活力。</li></ul><p><img src="img/image-20210106235239532.png" alt="image-20210106235239532"></p><p>摘抄 <a href="https://t.co/t1GhiJgIsa" target="_blank" rel="noopener">自由宪章</a></p><h3 id="一想到还有百分之九十五的问题留给人类-我就放心了"><a href="#一想到还有百分之九十五的问题留给人类-我就放心了" class="headerlink" title="一想到还有百分之九十五的问题留给人类,我就放心了"></a>一想到还有百分之九十五的问题留给人类,我就放心了</h3><p><code>摘抄</code> <a href="https://t.co/HX1EXtz2oZ" target="_blank" rel="noopener">一想到还有百分之九十五的问题留给人类,我就放心了</a></p><h3 id="被讨厌的勇气"><a href="#被讨厌的勇气" class="headerlink" title="被讨厌的勇气"></a>被讨厌的勇气</h3><p>无意间在 <a href="https://sanshiliuxiao.top/talkSelf/20191212/" target="_blank" rel="noopener">椎咲良田|想不到啥标题</a> 发现了这本书。</p><blockquote><p>书里面有很多的观点一开始都挺让人难以接受的，就像那位去寻求哲人帮助的青年，不去接受哲人的观点，心里想着根本就不是哲人说的那样，决定要去好好反驳他。可是仔细想想，哲人说的话也算是蛮有道理的。整本书中哲人说的一些言论，如果单单只拆出一段或一句，就会觉得这个哲人是在强词夺理，可是他的话里面有着是有很多的前置条件，如何结合着一起看，那就会感觉不一样。</p></blockquote><p>先说一下我自己的感受吧，读完这本书确实改变了我一些根深蒂固的观念。我承认我有点极端心理，并且我很长时间把它归因于童年时期的家庭暴力，我觉着是老爸的暴脾气影响了我的性格，以至于性格偏激、寡言少语、不善社交、自卑内向等。很长很长一段时间我都把这一切归责于老爸对我的家庭暴力，长久不能释怀。就在今年过年时在家还和老爸争吵怪他小时候打我才导致我性格偏激。</p><p>直到读完这本书，我才改变了这种幼稚的想法。<strong>我们并非因为自身经历中的刺激——所谓的心理创伤——而痛苦，事实上我们会从经历中发现符合自己目的的因素。决定我们自身的不是过去的经历，而是我们自己赋予经历的意义。</strong>经历本身不会决定什么。我们给过去的经历“赋予了什么样的意义”，这直接决定了我们的生活。不可以从过去中找原因；要否定精神创伤；人不是受过去原因支配的存在，人是为了达成某种目的而采取行动的。</p><p><code>摘抄</code> <a href="https://t.co/o6cc1csJI2" target="_blank" rel="noopener">被讨厌的勇气</a></p><h3 id="布拉格精神"><a href="#布拉格精神" class="headerlink" title="布拉格精神"></a>布拉格精神</h3><p>本书的作者是这本书的译者同样也是《哈维尔文集》的译者崔卫平。提到布拉格就不得不提 <a href="https://zh.wikipedia.org/zh-hans/%E5%B8%83%E6%8B%89%E6%A0%BC%E4%B9%8B%E6%98%A5" target="_blank" rel="noopener">布拉格之春</a> </p><p>推荐阅读 <a href="http://www.liu-xiaobo.org/blog/archives/5381" target="_blank" rel="noopener">刘晓波：读《布拉格精神》——狱中读书笔记</a> 和 <a href="http://www.liu-xiaobo.org/blog/archives/12412" target="_blank" rel="noopener">刘晓波：在刀锋上行走——狱中读《布拉格精神》</a></p><h2 id="自然-科学"><a href="#自然-科学" class="headerlink" title="自然/科学"></a>自然/科学</h2><h3 id="病毒星球"><a href="#病毒星球" class="headerlink" title="病毒星球"></a>病毒星球</h3><p>极为简短的一本科普，大概用了两个小时的时间就读完了。主要科普了一下病的性质以及入侵人体细胞的机理等。感觉读起来海星吧，没有太多精彩的地方，就像回顾了一下高中生物学。</p><p><code>摘抄</code> <a href="https://t.co/Op5GTfaOch" target="_blank" rel="noopener">病毒星球</a></p><h3 id="病毒来袭"><a href="#病毒来袭" class="headerlink" title="病毒来袭"></a>病毒来袭</h3><p>感觉没《病毒星球》要好一些，总之推荐前一本。</p><p><code>摘抄</code> <a href="https://t.co/kfTZIY7Zt0" target="_blank" rel="noopener">病毒来袭</a></p><h3 id="血疫：埃博拉的故事"><a href="#血疫：埃博拉的故事" class="headerlink" title="血疫：埃博拉的故事"></a>血疫：埃博拉的故事</h3><p>疫情期间在家看完的书，也有同名的纪录片，推荐两者都看一下。</p><p><code>摘抄</code> <a href="https://kindle.502.li/" target="_blank" rel="noopener">血疫：埃博拉的故事</a></p><h3 id="远古的葱茏：古植物王国"><a href="#远古的葱茏：古植物王国" class="headerlink" title="远古的葱茏：古植物王国"></a>远古的葱茏：古植物王国</h3><p>这本书主要讲了植物的起源、光合作用、叶绿体、孢子生殖以及一些远古时期的生态环境等。总之对于咱这种对古生物学感兴趣的来说算是一顿科普盛宴，学到很多知识耶，极大得满足了咱的好奇心😂。</p><p><code>摘抄</code> <a href="https://t.co/5KOfa96qlr" target="_blank" rel="noopener">远古的葱茏：古植物王国</a></p><h3 id="古生物学简明教程"><a href="#古生物学简明教程" class="headerlink" title="古生物学简明教程"></a>古生物学简明教程</h3><p>课本教材，枯燥、只是了解了一下基本的概念，感觉我不适合读这种枯燥的课本(￣▽￣)”</p><p><code>摘抄</code> <a href="https://t.co/G6oMMnAAji" target="_blank" rel="noopener">古生物学简明教程</a></p><h3 id="朱钦士的个人博客"><a href="#朱钦士的个人博客" class="headerlink" title="朱钦士的个人博客"></a>朱钦士的个人博客</h3><p>这并不是一本书，而是我在 <a href="http://blog.sciencenet.cn/home.php?mod=space&uid=582158" target="_blank" rel="noopener">朱钦士 </a>博士的个人博客上复制下来整理成的电子书，在 kindle 上读起来比较方便。对于只具备高中生物知识得咱来说，读起朱院士写的文章还是有些吃力的，感觉这基本上就是论文的注释版。里面的一些学术用语有很多都不懂，只能自己搜索了解一下。讲到了真核生物的起源，以及动物细胞和植物细胞的起源。咱们人类（动物）是从单鞭毛的原生生物领鞭毛虫（Choanoflagellate）演化而来，而植物则由双鞭毛原生生物中的双星藻（Zygmematales）演化而来，原来咱们的祖先是只鞭毛虫😂？</p><p>摘抄 <a href="https://t.co/50HX5FvBPk" target="_blank" rel="noopener">朱钦士的个人博客</a></p><h3 id="生命通史"><a href="#生命通史" class="headerlink" title="生命通史"></a>生命通史</h3><p>生命通史这本书是今年花了相当长的时间来读完的，之前在 <a href="http://blog.sciencenet.cn/home.php?mod=space&uid=582158" target="_blank" rel="noopener">朱钦士 </a>博士的个人博客上读了很多文章一直与犹未尽。</p><p>真核细胞是怎样形成的呢，书中解释为：真核细胞是先获得线粒体，再发展出细胞核。线粒体的出现给真核生物带来充足能源的同时，也带来了内含子的入侵。为蛋白质编码的基因中内含子的出现，又迫使细胞形成细胞核以把DNA和核糖体分隔开来。这大概就是真核细胞出现的根本原因。其它的改变都是在这个基础上进行的。转录和蛋白质合成必须在空间上分开，而这正是细胞核的作用。细胞核的膜能够防止完整的核糖体进入细胞，而mRNA在剪接完成前，又不会离开细胞核，这样核糖体能够接触的，就只能是加工完毕的 mRNA。</p><p>读这本书只需要基本的高中生物和化学知识就能读懂。从分子生物学和基因角度解释一些宏观的生命现象，比如有氧呼吸电子的传递；线粒体和叶绿体如何工作；三羧酸循环；基因表达如何控制控制个体的形成等等，都分析的十分精彩，总之相当于一本生命科学的“源码分析”。</p><p>另外值得令人倾佩的是《生命通史》这本书并没有任何人的推荐序，没有花里胡哨的吹嘘只有严谨务实的学术知识，在这浮躁的年代，很少能见到这样的书了。这本书在我心中的地位远高于《人类简史》等畅销书，因为这真的是一本适合自己来读的书😀。</p><p><code>摘抄</code> <a href="https://t.co/6PBLon5t09" target="_blank" rel="noopener">朱钦士的个人博客</a></p><h3 id="上帝造人有多难：生命的密钥"><a href="#上帝造人有多难：生命的密钥" class="headerlink" title="上帝造人有多难：生命的密钥"></a>上帝造人有多难：生命的密钥</h3><p>读完了朱院士的博客上的文章，就像打开了我的好奇心潘多拉魔盒，越来越像知道关于生命科学的知识，就在 Amazon 上搜了一下他的书，还真的有一本，就 get 到啦。</p><blockquote><p>这是一本从分子细胞尺度上讲解生命奥秘的科普小书。用平实浅显的语言解释了复杂生命系统的一些基本知识。 让我了解了人体是由60万亿个细胞组成的复杂系统，蛋白质对生命体的重要意义，了解了所有生物从分子层面上是基本一致的、具有共同的祖先。书中解释了先有蛋再有鸡的结论，解释了对牛弹琴的科学依据。给这些“千古奇案”以“科学定论”。还有很多平时我们体会到了但是没有深想的生命现象，作者都给出了有意思的描述和解释。 最后一章解释了神经系统的复杂程度，让我从生物学意义上了解了时下大热的人工智能深度学习技术的生物学基础。 不过，最后一章在全书中占了大约四分之一的篇幅，个人感觉用力不均。我是跳着看了些片段。 然而瑕不掩瑜，对于生物学小白来说，会让你入迷的。感谢作者！</p></blockquote><p>看这本书和他的博客一样精彩，另外还出了另一本书《生命通史》，看了一下目录和他博客里写的内容及其相似，等到以后再买本纸质版的看。想起来了大学时曾读过的一本书《生命的跃升》，我觉着二者之间比较相似。</p><p><code>摘抄</code> <a href="https://t.co/tjOSuGPhu7" target="_blank" rel="noopener">上帝造人有多难：生命的密钥</a></p><h3 id="牛津通识读本：地球"><a href="#牛津通识读本：地球" class="headerlink" title="牛津通识读本：地球"></a>牛津通识读本：地球</h3><p>牛津通识读本系列的书籍大概有三十几本，在 Amazon 上 Kindle Unlimited 会员是可以免费借阅。基本上都是一些一两百页子。这本关于地球科普小册子简单地介绍了一下地球的地球的形成、内核、地磁场、火山运动等知识。总之读起来可以满足一下自己的好奇心啦😋</p><p><code>摘抄</code> <a href="https://t.co/ExJxAKtv8d" target="_blank" rel="noopener">牛津通识读本：地球</a></p><h3 id="七堂极简物理课"><a href="#七堂极简物理课" class="headerlink" title="七堂极简物理课"></a>七堂极简物理课</h3><p>虽然被捧得很好，但觉着没啥好看的……🙄</p><h3 id="鸟瞰古文明"><a href="#鸟瞰古文明" class="headerlink" title="鸟瞰古文明"></a>鸟瞰古文明</h3><p>这本书是朋友送的，也是 2020 年读过最喜欢的书，书中的插图相当精美</p><p>书中提到过庞贝古城，当时找了两期纪录片来看：</p><ul><li><a href="https://www.bilibili.com/video/BV1aK4y1e7k7" target="_blank" rel="noopener">【纪录片】庞贝古城 揭秘被冻结于时光中的人【双语特效字幕】【纪录片之家字幕组】</a></li><li><a href="https://www.bilibili.com/video/BV1jT4y1373W" target="_blank" rel="noopener">【纪录片】庞贝 尘埃落定【1080p】【双语特效字幕】【纪录片之家字幕组】</a></li></ul><blockquote><p>  130幅城市复原图，重现古文明全景</p><p>  借由细腻画笔，溯着时间之流，触碰千年前的繁华巨梦</p><p>  以地中海沿岸为中心，横跨九大地域，近百座建筑群跃然眼前</p><p>  它们是古代统治者雄心与抱负的见证</p><p>  也是我们理解古希腊、罗马、埃及文明的最佳途径</p><p>  🌟 所有伟大的城市，都是在信念与梦想中建构而成。</p><p>  它们并不只辉煌于历史，其光芒也照耀了后世前进之路。</p><p>  🌟 古代城市复原领域巨擘让-克劳德·戈尔万凭借集绘画、建筑与考古学于一身的天赋， 将那些化为尘土，颓成残垣的古老废墟重新修葺。</p></blockquote><p><img src="img/20200403_043253117_iOS.jpg" alt=""><br><img src="img/20200405_162332630_iOS.jpg" alt=""><br><img src="img/20200405_162437116_iOS.jpg" alt=""><br><img src="img/20200406_101134106_iOS.jpg" alt=""><br><img src="img/20200406_102610423_iOS.jpg" alt=""></p><h3 id="宇宙从一粒尘埃开始：9堂极简宇宙课"><a href="#宇宙从一粒尘埃开始：9堂极简宇宙课" class="headerlink" title="宇宙从一粒尘埃开始：9堂极简宇宙课"></a>宇宙从一粒尘埃开始：9堂极简宇宙课</h3><p>不错的天体物理学科普，是著名的全球畅销书作家布莱恩·考克斯和杰夫·福修的全新力作。这是一本关于宇宙历史的科普读物。全书分为宇宙的故事、太阳有多老、给地球称重、到恒星的距离、爱因斯坦引力论、大爆炸、给宇宙秤重、大爆炸之前发生了什么、我们的世界九部分组成。书中用到的方法耶十分有趣，例如利用帆布背包里装上两个GPS 接收器来测量太阳有多老；利用在布里斯托尔海峡的海平面上的一个浮标，来给地球的大小做一个大致的测量😂</p><p><code>摘抄</code> <a href="https://t.co/qDg3uQqKW5" target="_blank" rel="noopener">宇宙从一粒尘埃开始：9堂极简宇宙课</a></p><h3 id="宇宙从起源到未来"><a href="#宇宙从起源到未来" class="headerlink" title="宇宙从起源到未来"></a>宇宙从起源到未来</h3><p><code>摘抄</code> <a href="https://t.co/zDlbJOshP1" target="_blank" rel="noopener">宇宙从起源到未来</a></p><h3 id="Life-生命"><a href="#Life-生命" class="headerlink" title="Life 生命"></a>Life 生命</h3><p><code>摘抄</code> <a href="https://t.co/d1FD3UtnXV" target="_blank" rel="noopener">Life 生命</a></p><h3 id="复杂生命的起源"><a href="#复杂生命的起源" class="headerlink" title="复杂生命的起源"></a>复杂生命的起源</h3><p>这本书是从 Twitter 上发现的，2020 年 11 月份刚出版，Kindle 商店里有电子版，看到作者是<strong>尼克·莱恩</strong>时就想到之前读过他的《生命的跃升》，就毫不犹豫地买了花了一周的时间读完了。因为读过他的《生命的跃升》，在读读这本书的时候很多内容就似曾相识。</p><ul><li>线粒体果真是名副其实的“发电机”😂</li></ul><blockquote><p>  质子还是带电粒子，带一个单位的正电荷。所以把质子泵过一层封闭的膜产生了两个效果：第一，在膜的两边制造了质子的浓度差；第二，膜的两边形成了电位差，外部环境相对于内部是正电位，膜内膜外的电位差是150～200毫伏。不要小看这个数字，因为膜本身非常薄（厚度为6纳米左右），在这么短的距离上，这是非常强大的电势能场。你可以再次变回ATP的大小去体验一下。如果待在膜附近，你感受到的电场强度是每米三千万伏特，相当于一道闪电，或者是普通家用电的1,000倍。</p></blockquote><ul><li>在读《生命通史》的时候里面也谈到过真核细胞演化出细胞核的原因：</li></ul><blockquote><p>  细胞核膜就是这道障碍，可以把转录和转译两个过程分开。在细胞核中，基因被转录成RNA转录本；在细胞核外，核糖体会读取RNA，再转译成蛋白质。最重要的是，缓慢的剪接过程在细胞核内进行，在核糖体有机会接触到RNA之前已经处理完毕。这就是细胞核真正的意义：把干劲冲天的核糖体挡在外面。这就解释了为什么真核生物需要细胞核，而原核生物不需要。原核生物根本没有内含子的麻烦。</p></blockquote><blockquote class="twitter-tweet"><p lang="zh" dir="ltr"><a href="https://twitter.com/hashtag/%E9%89%B4%E4%B9%A6?src=hash&amp;ref_src=twsrc%5Etfw" target="_blank" rel="noopener">#鉴书</a> 终于出中文版了！我还没有读过，不知道翻译得怎样。原书的英文版是我读过的最棒的科普书之一，在我心目中的地位和《自私的基因》、《枪炮病菌与钢铁》和《无穷的开始》差不多。在我看来，这4本书是现代知识分子的必读书，缺一本你都不完整。 <a href="https://t.co/ohO7iID6be" target="_blank" rel="noopener">pic.twitter.com/ohO7iID6be</a></p>&mdash; immusoul (@ayuan1000) <a href="https://twitter.com/ayuan1000/status/1332641409510215680?ref_src=twsrc%5Etfw" target="_blank" rel="noopener">November 28, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><p>另外推荐下面几期视频节目，也与这本书的内容有很大关系。</p><ul><li><a href="https://www.bilibili.com/video/BV185411h79H" target="_blank" rel="noopener">【鬼谷闲谈】在那充满毒与火的深渊中，科学家发现了生命本源的线索</a></li><li><a href="https://www.bilibili.com/video/BV1Qh411R7Zf" target="_blank" rel="noopener">【鬼谷闲谈】紫色地球：一个杀生以护生的故事</a></li><li><a href="https://www.bilibili.com/video/BV1NT4y1w7vD" target="_blank" rel="noopener">【鬼谷闲谈】一次改写生命演化的邂逅</a></li><li><a href="https://www.youtube.com/watch?v=GPYn1vJh1Q0" target="_blank" rel="noopener">科学声音：生命起源</a></li><li><a href="https://www.bilibili.com/video/BV1N54y1R7CM" target="_blank" rel="noopener">《宇宙时空之旅：未知世界》03：失落的生命之城</a> 墙裂推荐😊</li></ul><p>另外再推荐豆瓣小组上的篇文章 <a href="https://www.douban.com/group/topic/33656795/" target="_blank" rel="noopener">1978年化学诺奖：ATP、线粒体结构和有氧呼吸</a></p><p><code>摘抄</code> <a href="https://t.co/soPnC8gnbs" target="_blank" rel="noopener">复杂生命的起源</a></p><h3 id="生命的跃升"><a href="#生命的跃升" class="headerlink" title="生命的跃升"></a>生命的跃升</h3><p>这本书在大学的时候读过一遍，那时候是看的 <a href="https://www.bilibili.com/video/BV1wx41177Tm" target="_blank" rel="noopener">柴知道：六分钟速读《生命的跃升》</a> 才认识到这本书，在读完 </p><p>《复杂生命的起源》的起源后又决定重新回顾一下这本书，重读了一遍。</p><p><code>摘抄</code> <a href="https://t.co/50bSWvIOAd" target="_blank" rel="noopener">生命的跃升</a></p><p>关于作者尼克·莱恩，剽窃一段豆瓣上的简介：</p><blockquote><p>  尼克·莱恩（Nick Lane），演化生物学家，英国伦敦大学学院教授。他的研究方向为演化生物学与生物能量学，聚焦于生命的起源与复杂细胞的演化。他还是伦敦大学学院线粒体研究学会的创始成员，也是生命起源研究计划的项目领头人。2010年，他以《生命的跃升》荣获英国皇家学会科学图书奖。尼克本人因为在分子生物学研究上的卓越贡献，于2015年荣获英国生物化学学会奖。他不仅深耕自己的学术研究领域，还孜孜不倦地参与公众科学普及。2016年，尼克因为在科学传播上的深入付出而荣获英国皇家学会迈克尔·法拉第奖章。</p></blockquote><p>最近也在读他的<a href="https://search.books.com.tw/redirect/move/key/尼克‧連恩/area/mid/item/0010730616/page/1/idx/2/cat/001/pdf/1" target="_blank" rel="noopener">生命之源：能量、演化與複雜生命的起源</a>，台湾貓頭鷹出版出版的，大陆还没有，只能买繁体的纸质书来看。另外还有一本《<a href="https://search.books.com.tw/redirect/move/key/尼克‧連恩/area/mid/item/0010874343/page/1/idx/1/cat/001/pdf/1" target="_blank" rel="noopener">能量、性、死亡：粒線體與我們的生命(15周年新版)</a>》。这两本都能在某宝上代购买到，或者通过 <a href="https://www.books.com.tw/products/0010730616?sloc=main" target="_blank" rel="noopener">博客来</a> 代购买到。</p><p><img src="img/image-20210109225801483.png" alt="image-20210109225801483"></p><h3 id="消失的微生物：滥用抗生素引发的危机"><a href="#消失的微生物：滥用抗生素引发的危机" class="headerlink" title="消失的微生物：滥用抗生素引发的危机"></a>消失的微生物：滥用抗生素引发的危机</h3><p>当胎儿通过阴道的时候，后者就像一只富有弹性的手掌，紧紧地包裹住婴儿柔软的身体，抚摸过每一寸肌肤。就是在这个过程中，细菌转移发生了。婴儿的皮肤就像海绵，吸收了它周围的乳酸杆菌。胎儿的脑袋朝下，而且面对着母亲的背部，恰好贴合着产道。婴儿吸入的第一口汁液包含了母亲阴道里的微生物，也不排除有一定的肠道微生物。天然的分娩并不是一个无菌的过程，但是它从来都是这种状态——从我们最早的哺乳动物祖先算起，至少7000万年了。</p><p><code>摘抄</code> <a href="https://t.co/CpTb1LusIP" target="_blank" rel="noopener">消失的微生物：滥用抗生素引发的危机</a></p><h2 id="漫画-小说"><a href="#漫画-小说" class="headerlink" title="漫画/小说"></a>漫画/小说</h2><h3 id="心里测量者"><a href="#心里测量者" class="headerlink" title="心里测量者"></a>心里测量者</h3><p>读后感可以参见 <a href="https://blog.k8s.li/PSYCHO-PASS-booklist.html">PSYCHO-PASS 心理测量者小说读后感</a>，这部改编自动漫的小说基本上还原了整个第一部动画完整的剧情，总之也是关于一个如何构建人类社会题材的小说。小说中也提到了很多书籍，也有网友总结了一份心理测量者中提到的书籍，书单如下:</p><p>其中卢梭的书也是我看了这部小说之后才开始读的，还有一本是福柯的《规训与惩罚：监狱的诞生》，剩余价值那期被封杀的节目里罗新老师也提到过这本书。马克思·韦伯的书在《中国国家治理的制度逻辑：一个组织学研究》中提到不少，尤其是关于官僚政治的，而且马克思·韦伯还和前文提到的路德维希·冯·米塞斯也是一对学术上的好基友。</p><p><code>摘抄</code> <a href="https://t.co/gp1upTv3IK" target="_blank" rel="noopener">心里测量者</a></p><h3 id="费马最终定理"><a href="#费马最终定理" class="headerlink" title="费马最终定理"></a>费马最终定理</h3><p>日系狗粮小说🐕，第一次读这本书还是大三的时候，<del>那时候咱刚刚开始了人生的第一次初恋，并把这本书送给了前女友</del>🤣。同样的小说还有《数学女孩》，后者的评价很高，但想要通过小说来学习数学是痴心妄想啦。嘛，小说就是兴趣读物，给这些枯燥会色的数学公式增加一点色彩~~</p><p>虽然对于数学来讲，咱木子简直是个学脆😭，高考数学考了 60 几分，这也让咱与名牌大学失之交臂，只能去读第六级本科院校😑，多少有点遗憾吧。不过纳，对于那些枯燥无比的计算公式求积分解微分方程等，咱更喜欢知道数学这本学科背后的历史：想知道牛顿和莱布尼茨之间的撕逼大战，想知道伯努力家族的恩仇怨恨，想知道笛卡尔与公主的爱情故事，想知道欧拉奋笔疾书非凡的一生，想知道庞加莱猜想与<code>宇宙的形状</code>等等。这也是咱即便毕业离开大学之后，不再是一名学生但也是像学生时代的自己那样好奇心如此地旺盛😂</p><blockquote><p>『我一直觉得，费马、欧拉、哥德巴赫等人与现代人相比，他们具有格外旺盛的好奇心和丰富的想象力，并且充满了生机与活力。随着社会发展的日益成熟，好奇心和想象力不可避免地不断降低，但并不代表现代社会不再需要好奇心和想象力。』</p></blockquote><p><code>摘抄</code> <a href="https://t.co/UqDfbYRjs7" target="_blank" rel="noopener">费马最终定理</a></p><h3 id="来自新世界"><a href="#来自新世界" class="headerlink" title="来自新世界"></a>来自新世界</h3><p>先是看完的 TV 动画，又看的原创小说。虽然小说称之为是反乌托邦之作，但它与《1984》、《美丽新世界》这类书有着很大的不同。书中并没有符号化一个强势的政府形象，也没有绝对的”坏人“。</p><p><a href="https://t.co/JbLvSP4cP0" target="_blank" rel="noopener">来自新世界</a></p><h3 id="樱花庄的宠物女孩"><a href="#樱花庄的宠物女孩" class="headerlink" title="樱花庄的宠物女孩"></a>樱花庄的宠物女孩</h3><p>大学的时候看过 TV 动画，花了几个通宵时间又读完了这部小说。</p><h3 id="星际穿越"><a href="#星际穿越" class="headerlink" title="星际穿越"></a>星际穿越</h3><p>和朋友一块去看完星际穿越的电影后又补看的小说，总体上不错，高度还原了电影中的情节。</p><blockquote><p>  事实还不止于此。人类不是一群孤独的生物有机体，而是一个种族发展上百万年的最终结果，蕴含着上百万年的探索、神话、社群、或重要或荒谬的想法、诗歌、哲学、工程、科学。</p></blockquote><blockquote><p>  诚然，借助这件东西，他和布兰德教授能让数千个生物学意义上的人类降生于世，但他们两人就能真正替代错综交织的传承和归属——替代爱吗？这真的是在拯救人类吗？在森林被烧为平地之前抢救出一粒种子，并不意味着拯救了森林。繁复而独特的生态系统永远无法复制。解冻人类胚胎也算不上“拯救”人类。</p></blockquote><p>摘抄 <a href="https://t.co/Hmv8cWVB80" target="_blank" rel="noopener">星际穿越</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;首先给各位关注我博客的小伙伴说声抱歉，已经很长时间（将近
        
      
    
    </summary>
    
    
      <category term="思考" scheme="https://blog.k8s.li/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="阅读" scheme="https://blog.k8s.li/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="读书笔记" scheme="https://blog.k8s.li/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>轻量级容器优化型 Linux 发行版 Photon OS</title>
    <link href="https://blog.k8s.li/Photon-OS.html"/>
    <id>https://blog.k8s.li/Photon-OS.html</id>
    <published>2020-09-24T16:00:00.000Z</published>
    <updated>2020-09-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间捡垃圾东拼西凑搞了台 Homelab 👇玩玩 👉<a href="https://blog.k8s.li/homelab.html">《垃圾佬的 Homelab 折腾记录》</a> 。</p><p><img src="img/20200913_esxi_01.png" alt=""></p><p>总体来讲性价比高，Intel i5-6600T 的性能和 i5-6600 持平，比那种 8250U 之类的低压 U 要高很多，跑一堆虚拟机也不成问题，甚至跑个三 master + 两 node 的 kubernetes 集群也是可以😂。至于功耗，整机待机时不到 30W ，一天不到 1 度电，不用担心电费爆表了；至于价格，一颗 Intel i5-6600T  不到 450 块钱，还不香嘛🙃。</p><p>在 ESXi 运行着一些虚拟机，比如用 WireGuard 打通 VPS 之间的网络，运行在一个 alpine 虚拟机里作为网关机使用；比如使用 <a href="https://pi-hole.net/" target="_blank" rel="noopener">Pi-hole®</a> 来构建自己的 DNS 服务器，用来拦截屏蔽域名；比如运行 time-machine 服务用来定时备份 MacBook ；比如 Windows 虚拟机里运行着一些国产毒瘤软件😡；比如使用 <a href="https://docs.drone.io/" target="_blank" rel="noopener">Drone</a> 跑一套轻量级的 CI 流水线系统，总之可玩性非常高哦，只要你又时间瞎折腾，总能找点乐子玩😂。</p><h2 id="Linux-Container-OS"><a href="#Linux-Container-OS" class="headerlink" title="Linux Container OS ?"></a>Linux Container OS ?</h2><p>有了一台运行着 ESXi 的 Homelab ，今天就玩一下 Linux container OS ，即 Linux 容器  OS 、容器优化型 OS，这是一类专门针对运行容器定制化开发的 Linux 发行版，裁剪掉一些不必要的软件和内核模块，使系统更加轻量一些。虽然来说民用级的 Intel i5-6600T 性能也不算太差，但和 E3  小王子，E5 老大哥比还是差个十万八千里。因此为了节省一些 CPU 资源，减少虚拟化带来的开销，就选择了容器化运行一些应用，同时再为这些容器找一个轻量级的宿主机 OS ，这就是为什么想要使用 Linux container OS 的原因。</p><h3 id="GKE-的-Container-Optimized-OS"><a href="#GKE-的-Container-Optimized-OS" class="headerlink" title="GKE 的 Container-Optimized OS"></a>GKE 的 <a href="https://cloud.google.com/container-optimized-os/docs/" target="_blank" rel="noopener">Container-Optimized OS</a></h3><p>Kubernetes 的亲爸爸 Google 家的 <a href="https://cloud.google.com/kubernetes-engine" target="_blank" rel="noopener">Google Kubernetes Engine</a> 即 GKE 集群中的每个节点都是使用 <a href="https://cloud.google.com/container-optimized-os/docs/" target="_blank" rel="noopener">Container-Optimized OS</a> 来运行工作负载，不过仅仅是针对 GCE 来进行优化的，可能在 OpenStack 或者 vSphere 上运行不起来，(瞎猜😂。</p><blockquote><p>  Container-Optimized OS 是适用于 <a href="https://cloud.google.com/compute" target="_blank" rel="noopener">Compute Engine</a> 虚拟机的操作系统映像，专为运行 Docker 容器而优化。借助 Container-Optimized OS，您可以快速、高效、安全地在 Google Cloud Platform 上启动 Docker 容器。Container-Optimized OS 由 Google 维护，基于 <a href="https://www.chromium.org/chromium-os" target="_blank" rel="noopener">Chromium OS</a> 开放源代码项目。</p></blockquote><p>特点就是不同于其他的 Linux 发行版，这个是基于 <a href="https://www.chromium.org/chromium-os" target="_blank" rel="noopener">Chromium OS</a> 定制化开发的，对内核版本选用的也比较激进，一般是 <code>4.19.112+</code> 或者 <code>5.x</code> 版本，这样你就不用再担心像 CentOS 7.x 系列那样各种内核 bug 了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">items:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Node</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">nodeInfo:</span></span><br><span class="line">      <span class="attr">architecture:</span> <span class="string">amd64</span></span><br><span class="line">      <span class="attr">bootID:</span> <span class="string">0c517083-aaf6-75fc4b2204ba</span></span><br><span class="line">      <span class="attr">containerRuntimeVersion:</span> <span class="string">docker://19.3.1</span></span><br><span class="line">      <span class="attr">kernelVersion:</span> <span class="number">4.19</span><span class="number">.112</span><span class="string">+</span></span><br><span class="line">      <span class="attr">kubeProxyVersion:</span> <span class="string">v1.16.13-gke.1</span></span><br><span class="line">      <span class="attr">kubeletVersion:</span> <span class="string">v1.16.13-gke.1</span></span><br><span class="line">      <span class="attr">machineID:</span> <span class="string">33a96ff3203d88c0a542</span></span><br><span class="line">      <span class="attr">operatingSystem:</span> <span class="string">linux</span></span><br><span class="line">      <span class="attr">osImage:</span> <span class="string">Container-Optimized</span> <span class="string">OS</span> <span class="string">from</span> <span class="string">Google</span></span><br><span class="line">      <span class="attr">systemUUID:</span> <span class="string">33a96ff33d88c0a542</span></span><br></pre></td></tr></table></figure><p>Chromium OS 就是 Google 基于 Linux 内核开发的操作系统，所以 Google 也有这个实力针对自家的 GCP 云平台进行定制化开发个 OS 出来，专门给 kubernetes 集群运行使用，定制化开发的好处就是可以带来更多的新特性，二不受制于上游的 Linux 发行版的限制。比如不久前 Google 宣布将使用 <a href="https://cilium.io/" target="_blank" rel="noopener">Cilium</a> 作为 GKE 的下一代数据面，<a href="https://cloud.google.com/blog/products/containers-kubernetes/bringing-ebpf-and-cilium-to-google-kubernetes-engine" target="_blank" rel="noopener">New GKE Dataplane V2 increases security and visibility for containers</a> ，而 Cilium 这项技术是依赖于对 eBPF 技术，而 eBPF 又依赖于内核特性的支持。</p><h3 id="AWS-的-Bottlerocket-OS"><a href="#AWS-的-Bottlerocket-OS" class="headerlink" title="AWS 的 Bottlerocket OS"></a>AWS 的 <a href="https://github.com/bottlerocket-os/bottlerocket" target="_blank" rel="noopener">Bottlerocket OS</a></h3><p>这个是 AWS 最近开源专门针对  EC2 进行优化的 Linux Container OS，和 GKE 一样，只是针对于自家的 AWS 公有云，由于是最近刚刚推出的，还没来得及关注，所以就不介绍了。同 GKE 的 Container-Optimized OS 一样，一般公有云定制化开发的 Container OS 仅仅只针对自家的云平台。</p><blockquote><h3 id="Optimized-performance-through-AWS-integrations"><a href="#Optimized-performance-through-AWS-integrations" class="headerlink" title="Optimized performance through AWS integrations"></a>Optimized performance through AWS integrations</h3><p>  AWS provided builds of Bottlerocket are optimized to run on Amazon EC2 and include support for the latest Amazon EC2 instance capabilities. They also have built-in integrations with AWS services for container orchestration, registries, and observability.</p></blockquote><h3 id="CoreOS-Container-Linux"><a href="#CoreOS-Container-Linux" class="headerlink" title="CoreOS Container Linux"></a>CoreOS Container Linux</h3><p>来自 CoreOS 团队的 CoreOS Container Linux ，它应该是最古老的 Linux Container OS ，早在 2013 年 10 月就已经 release 第一个版本，那时候的 docker 还没有在 0.x.x 版本。</p><blockquote><p>  <a href="https://github.com/coreos/manifest/releases/tag/v94.0.0" target="_blank" rel="noopener">v94.0.0</a></p><ul><li>Git is now included by default as a number of people use it for shipping around assets, code, etc like a distributed rsync</li><li>Docker is upgraded to 0.6.3</li><li>xz is included to support new compression types</li><li>Custom OEMs can be provided via the cpio on PXE images</li></ul></blockquote><p>它没有像 yum 或 apt 这样的包管理器来安装软件，在 CoreOS 中你不需要安装软件，因为所有的应用程序都要使用 docker 来打包。</p><ul><li>最小化的操作系统： 占用内存很少，比典型的服务器版本 Linux 少占 40%的内存。</li><li>易于升级： CoreOS 采用双系统分区（主动分区/被动分区）设计而不是采用传统的通过升级包来升级系统，这使得每次升级更加快速，可靠和易于回滚。这一点有点像 Android 的 A/B 分区？</li><li>集成 Docker： CoreOS 默认集成 Docker 并作了很好的支持和优化，省去用户安装，配置，优化 Docker 的时间，极大地方便了用户。</li><li>易于集群化： CoreOS 本身提供了大型 Docker 容器集群的整体解决方案，通过内置的 fleet 工具在多台系统中部署容器并进行集群化管理。同时通过提供 Discovery Service，便于动态部署和管理集群，解决方案比较成熟。</li><li>自动化的大规模部署： CoreOS 自身提供的解决方案能够自动地大规模批量部署并操作系统，极大地减少用户工作量。</li><li>使用 systemd 做为系统服务管理工具，性能比较好，systemd 有现代化的日志功能，同时采用 socket 式与 D-Bus 总线式激活服务.</li></ul><p>不过 CoreOS 早在今年四月份就已经 EOF 了，<a href="https://getfedora.org/coreos/" target="_blank" rel="noopener">Fedora CoreOS</a> 成为 CoreOS 的继任者：</p><blockquote><p>  As we’ve <a href="https://groups.google.com/d/msg/coreos-user/zgqkG88DS3U/PFP9yrKbAgAJ" target="_blank" rel="noopener">previously announced</a>, <a href="https://getfedora.org/coreos/" target="_blank" rel="noopener">Fedora CoreOS</a> is the official successor to CoreOS Container Linux. Fedora CoreOS is a <a href="https://fedoramagazine.org/fedora-coreos-out-of-preview/" target="_blank" rel="noopener">new Fedora Edition</a> built specifically for running containerized workloads securely and at scale. It combines the provisioning tools and automatic update model of Container Linux with the packaging technology, OCI support, and SELinux security of Atomic Host. For more on the Fedora CoreOS philosophy, goals, and design, see the <a href="https://fedoramagazine.org/introducing-fedora-coreos/" target="_blank" rel="noopener">announcement of the preview release</a> and the <a href="https://docs.fedoraproject.org/en-US/fedora-coreos/" target="_blank" rel="noopener">Fedora CoreOS documentation</a>.</p></blockquote><h3 id="红帽的-RHCOS"><a href="#红帽的-RHCOS" class="headerlink" title="红帽的 RHCOS"></a>红帽的 <a href="https://docs.openshift.com/container-platform/4.1/architecture/architecture-rhcos.html" target="_blank" rel="noopener">RHCOS</a></h3><p>来自红帽子家的 <a href="https://docs.openshift.com/container-platform/4.1/architecture/architecture-rhcos.html" target="_blank" rel="noopener">Red Hat Enterprise Linux CoreOS (RHCOS)</a>，是基于不过这个 OS 仅仅适用于它自家的 <a href="https://docs.openshift.com/" target="_blank" rel="noopener">OpenShift</a>，而且容器运行时仅支持 CRI-O。</p><blockquote><p>  At the moment, CRI-O is only available as a container engine within OpenShift Container Platform clusters.</p></blockquote><p>因为 CoreOS 团队现如今已经被 Red Hat® 收购了，正如在 <a href="https://access.redhat.com/documentation/zh-cn/openshift_container_platform/4.2/html/architecture/architecture-rhcos" target="_blank" rel="noopener">OpenShift 文档</a> 中提到的： Red Hat Enterprise Linux CoreOS (RHCOS) 代表了下一代单用途容器操作系统技术。RHCOS 由创建了 Red Hat Enterprise Linux Atomic Host 和 CoreOS Container Linux 的同一开发团队打造，它将 Red Hat Enterprise Linux (RHEL) 的质量标准与 Container Linux 的自动化远程升级功能结合在一起。</p><h3 id="RancherOS"><a href="#RancherOS" class="headerlink" title="RancherOS"></a>RancherOS</h3><p>RancherOS 是 Rancher 团队所维护的开源项目，也是对标 CoreOS 一样，专门用来运行容器，并且可以运行在生产环境（至少官方做了这么样的承诺，咱也没在生产用过，不好说。在 RancherOS 中所有的进程（包括系统所有的服务，比如 udev 和 syslog）都是用 docker 来管理，这一点要比 CoreOS 更加激进一些，而 CoreOS 还是使用传统 Linux 发行版中的 systemd 来管理系统中的服务。RancherOS 通过移除传统 Linux 发行版中不必要的服务和库来最小化系统，使他专注单一的功能，即运行 docker 容器。不过之前体验了一番，占用资源比较多😂，好像并没有太大的优势（</p><p><code>Everything in RancherOS is a Docker container.</code> 感觉这个要比 CoreOS 更加容器化，甚至使用 docker 取代了 systemd 来管理系统的各种服务。系统启动后运行两个 docker 服务进程，一个是系统 docker ，在此之上在运行系统服务容器，和用户层面的 docker 。不过看一下下面的这张图你就会明白。总的来讲 RancherOS 是使用 docker 来管理整个系统的服务的，包括用户层面的 docker 。</p><p><img src="img/rancheroshowitworks.png" alt="How it works"></p><h3 id="VMware-的-Photon-OS"><a href="#VMware-的-Photon-OS" class="headerlink" title="VMware 的 Photon OS"></a>VMware 的 <a href="https://vmware.github.io/photon/" target="_blank" rel="noopener">Photon OS</a></h3><p>今天的主角，VMware  开源的 Photon OS，这个 OS 你可能没听说过，但 VMware 开源的 Harbor 想必很熟悉，而 Harbor 的基础镜像使用的就是他家的 Photon OS😂。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root [ /harbor ]# cat /etc/os-release</span><br><span class="line"><span class="attr">NAME</span>=<span class="string">"VMware Photon OS"</span></span><br><span class="line"><span class="attr">VERSION</span>=<span class="string">"2.0"</span></span><br><span class="line"><span class="attr">ID</span>=photon</span><br><span class="line"><span class="attr">VERSION_ID</span>=<span class="number">2.0</span></span><br><span class="line"><span class="attr">PRETTY_NAME</span>=<span class="string">"VMware Photon OS/Linux"</span></span><br><span class="line"><span class="attr">ANSI_COLOR</span>=<span class="string">"1;34"</span></span><br><span class="line"><span class="attr">HOME_URL</span>=<span class="string">"https://vmware.github.io/photon/"</span></span><br><span class="line"><span class="attr">BUG_REPORT_URL</span>=<span class="string">"https://github.com/vmware/photon/issues"</span></span><br></pre></td></tr></table></figure><p>在 Photon OS 的构建脚本 <a href="https://github.com/vmware/photon/blob/master/build.py" target="_blank" rel="noopener">build.py</a> 中可以看到它构建的产物支持 ISO 和 docker 镜像，以及众多公有云的虚拟机格式，两者都是来自相同的源码，根据构建出来的是形式不同，所包含的软件也不同。因为裁剪掉了一些不必要的系统服务， docker 镜像格式的要更精简一些。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">targetList = &#123;</span><br><span class="line">        "image":["iso", "ami", "gce", "azure", "rpi3", "ova", "ova_uefi", "all", "src-iso",</span><br><span class="line">                "photon-docker-image", "k8s-docker-images", "all-images", "minimal-iso", "rt-iso"],</span><br><span class="line"></span><br><span class="line">        "rpmBuild": ["packages", "packages-minimal", "packages-initrd", "packages-docker",</span><br><span class="line">                "updated-packages", "tool-chain-stage1", "tool-chain-stage2", "check",</span><br><span class="line">                "ostree-repo", "generate-yaml-files", "create-repo", "distributed-build"],</span><br><span class="line"></span><br><span class="line">        "buildEnvironment": ["packages-cached", "sources", "sources-cached", "publish-rpms",</span><br><span class="line">                "publish-x-rpms", "publish-rpms-cached", "publish-x-rpms-cached", "photon-stage"]</span><br></pre></td></tr></table></figure><p>总的来讲，上面提到的几种容器优化型 OS 中 ，Photon OS 比较开放一些，虽然来说是针对于自家 vSphere 进行优化的，但其他公有云和私有云也是支持，甚至还支持树莓派🍓！所以个人用户想拿来玩玩，还是不错滴。尤其是针对咱这种玩 ESXi 软路由的垃圾佬，在 Photon OS 上跑一些容器应用，再适合不过了。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table><thead><tr><th align="center">Providers</th><th align="center">Name</th><th align="center">STAR</th><th align="center">FORK</th></tr></thead><tbody><tr><td align="center">Google</td><td align="center"><a href="https://github.com/GoogleCloudPlatform/cos-customizer" target="_blank" rel="noopener">Container-Optimized OS</a></td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">Amazon</td><td align="center"><a href="https://github.com/bottlerocket-os/bottlerocket" target="_blank" rel="noopener">Bottlerocket OS</a></td><td align="center">4.8K</td><td align="center">185</td></tr><tr><td align="center">CoreOS</td><td align="center">CoreOS Container Linux</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">Red Hat</td><td align="center">RHCOS</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">Rancher</td><td align="center"><a href="https://github.com/rancher/os" target="_blank" rel="noopener">Rancher OS</a></td><td align="center">6k</td><td align="center">625</td></tr><tr><td align="center">Flatcar</td><td align="center"><a href="https://github.com/flatcar-linux/Flatcar" target="_blank" rel="noopener">Flatcar Linux</a></td><td align="center">117</td><td align="center">3</td></tr><tr><td align="center">VMware</td><td align="center"><a href="https://github.com/vmware/photon" target="_blank" rel="noopener">Photon OS</a></td><td align="center">2.1k</td><td align="center">591</td></tr></tbody></table><table><thead><tr><th align="center">Providers</th><th align="center">Name</th><th align="center">Runtime</th><th align="center">Support Platform</th></tr></thead><tbody><tr><td align="center">Google</td><td align="center">Container-Optimized OS</td><td align="center">docker</td><td align="center">GCP</td></tr><tr><td align="center">Amazon</td><td align="center">Bottlerocket OS</td><td align="center">docker</td><td align="center">AWS</td></tr><tr><td align="center">CoreOS</td><td align="center">CoreOS Container Linux</td><td align="center">docker</td><td align="center">AWS/GCP/OpenStack/VMware<BR>Alibaba Cloud/Azure/DigitalOcean</td></tr><tr><td align="center">Red Hat</td><td align="center">RHCOS</td><td align="center">CRI-O</td><td align="center">AWS/vSphere/Bare Metal</td></tr><tr><td align="center">Rancher</td><td align="center">Rancher OS</td><td align="center">docker</td><td align="center">AWS/GCP/OpenStack/VMware<BR>Alibaba Cloud/Azure/DigitalOcean</td></tr><tr><td align="center">Flatcar</td><td align="center">Flatcar Linux</td><td align="center">docker</td><td align="center">AWS/GCP/OpenStack/VMware<BR>Alibaba Cloud/Azure/DigitalOcean</td></tr><tr><td align="center">VMware</td><td align="center">Photon OS</td><td align="center">docker</td><td align="center">AWS/GCE/Azure/OpenStack<br>vSphere/bare metal/Raspberry Pi 3</td></tr></tbody></table><p>目前来讲 Photon OS 作为 Harbor 的基础镜像，在容器方面比较突出一些，但作为容器的宿主机 OS ，还有很长的路要走。由于我是使用的 VMware 家的 ESXi 虚拟化，那么选择他家的 Photon OS 是最好的喽，而且 Photon OS 是针对 ESXi 做过优化的，内核都是针对 ESXi 虚拟化进行了定制化的开发，所以理论上选择 Photon OS 应该是最合适的。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Download-Format"><a href="#Download-Format" class="headerlink" title="Download Format"></a><a href="https://github.com/vmware/photon/wiki/Downloading-Photon-OS" target="_blank" rel="noopener">Download Format</a></h3><table><thead><tr><th>Format</th><th>Description</th></tr></thead><tbody><tr><td>ISO Image</td><td>Contains everything needed to install either the minimal or full installation of Photon OS. The bootable ISO has a manual installer or can be used with PXE/kickstart environments for automated installations.</td></tr><tr><td>OVA</td><td>Pre-installed minimal environment, customized for VMware hypervisor environments. These customizations include a highly sanitized and optimized kernel to give improved boot and runtime performance for containers and Linux applications. Since an OVA is a complete virtual machine definition, we’ve made available a Photon OS OVA that has virtual hardware version 11; this will allow for compatibility with several versions of VMware platforms or allow for the latest and greatest virtual hardware enhancements.</td></tr><tr><td>Amazon AMI</td><td>Pre-packaged and tested version of Photon OS made ready to deploy in your Amazon EC2 cloud environment. Previously, we’d published documentation on how to create an Amazon compatible instance, but, now we’ve done the work for you.</td></tr><tr><td>Google GCE Image</td><td>Pre-packaged and tested Google GCE image that is ready to deploy in your Google Compute Engine Environment, with all modifications and package requirements for running Photon OS in GCE.</td></tr><tr><td>Azure VHD</td><td>Pre-packaged and tested Azure HD image that is ready to deploy in your Microsoft Azure Cloud, with all modifications and package requirements for running Photon OS in Azure.</td></tr><tr><td>Raspberry Pi3 Image</td><td>Pre-packaged and tested Raspberry Pi3 Image (Version 3.0 onwards) on ARM64 architecture.</td></tr></tbody></table><p>Photon OS 提供了多种安装方式，其中 ISO 是通用性的，就和安装其他 Linux 发行版的过程差不多，OVA 是虚拟机模板，可以导入到 VMware 虚拟化平台上使用，省区安装的步骤，比较方便。OVA 虚拟机模板的版本为 11 ，根据 <a href="https://kb.vmware.com/s/article/1003746" target="_blank" rel="noopener">Virtual machine hardware versions</a> 中的定义，需要 ESXi 6.0 Fusion 7.x Workstation 11.x Player 7.x 版本以上的虚拟化支持。</p><table><thead><tr><th><strong>Virtual Hardware Version</strong></th><th><strong>Products</strong></th></tr></thead><tbody><tr><td>18</td><td>ESXi 7.0.1</td></tr><tr><td>17</td><td>ESXi 7.0.0</td></tr><tr><td>16</td><td>Fusion 11.x Workstation Pro 15.x Workstation Player 15.x</td></tr><tr><td>15</td><td>VMware Cloud on AWS ESXi 6.7 U2</td></tr><tr><td>14</td><td>ESXi 6.7 Fusion 10.x Workstation Pro 14.x Workstation Player 14.x</td></tr><tr><td>13</td><td>ESXi 6.5</td></tr><tr><td>12</td><td>Fusion 8.x Workstation Pro 12.x Workstation Player 12.x</td></tr><tr><td>11</td><td>ESXi 6.0 Fusion 7.x Workstation 11.x Player 7.x</td></tr><tr><td>10</td><td>ESXi 5.5 Fusion 6.x Workstation 10.x Player 6.x</td></tr></tbody></table><p>另外还支持 <code>Raspberry Pi 3</code> ，不过需要拿源码自行编译镜像，然后刷到树莓派上，你吃灰的树莓派又有用途啦😂。</p><p><a href="https://github.com/vmware/photon/wiki/Downloading-Photon-OS" target="_blank" rel="noopener">下载方式</a> 👇</p><h3 id="Photon-OS-3-0-Revision-2-Update3-Binaries"><a href="#Photon-OS-3-0-Revision-2-Update3-Binaries" class="headerlink" title="Photon OS 3.0 Revision 2 Update3 Binaries"></a>Photon OS 3.0 Revision 2 Update3 Binaries</h3><p>Aug 14, 2020 An update to 3.0 revision 2 Update3 binaries are now available.</p><table><thead><tr><th>Download</th><th>Size</th><th>md5 checksum</th></tr></thead><tbody><tr><td><a href="https://packages.vmware.com/photon/3.0/Rev3/iso/photon-3.0-a383732.iso" target="_blank" rel="noopener">Full ISO x86_64</a></td><td>5.2G</td><td>2dd9f18c5162a7367f2463f4a9bb4890</td></tr><tr><td><a href="https://packages.vmware.com/photon/3.0/Rev3/iso/photon-minimal-3.0-a383732.iso" target="_blank" rel="noopener">Minimal ISO x86_64</a></td><td>299M</td><td>0119f0f275f246fd382d419ff41898a4</td></tr><tr><td><a href="https://packages.vmware.com/photon/3.0/Rev3/iso/photon-rt-3.0-a383732.iso" target="_blank" rel="noopener">ISO x86_64 Real-Time flavour</a></td><td>489M</td><td>d2bfce95b54a29174b5beaef9962dbc1</td></tr><tr><td><a href="https://packages.vmware.com/photon/3.0/Rev3/ova/photon-hw11-3.0-a383732.ova" target="_blank" rel="noopener">OVA-hw11</a></td><td>188M</td><td>ba52abd88c5b22cd4498cf0e88457f28</td></tr><tr><td><a href="https://packages.vmware.com/photon/3.0/Rev3/ova/photon-hw13_uefi-3.0-a383732.ova" target="_blank" rel="noopener">OVA-hw13_uefi</a></td><td>214M</td><td>95614f3b08c1a93306ababcc826572df</td></tr></tbody></table><p>在此使用 OVA-hw11 格式的 OVA 虚拟机模板，后面那个带 uefi 的需要设置虚拟机为 EFI 模式启动，比较麻烦。</p><ul><li>创建虚拟机的时候使用 OVA 文件导入</li></ul><p><img src="img/20200922-esxi_ova_01.png" alt=""></p><ul><li>默认的用户名为 <code>root</code> ，密码为 <code>changeme</code>，登录之后再输入一遍 <code>changeme</code>，然后修改为新的密码。</li></ul><p><img src="img/20200922-esxi_photonos-01.png" alt=""></p><h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><ul><li>内核版本为 <code>4.19.132-5.ph3-esx</code>，4.19 是个 LTS 版本的内核，结尾的 <code>esx</code> 则代表着为 <code>ESXi</code> 虚拟化定制的内核。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux photon-machine 4.19.132-5.ph3-esx #1-photon SMP Wed Aug 12 21:02:13 UTC 2020 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><ul><li>rpm 包数量仅仅为 146 个，一般的 CentOS 发行版自带的 rpm 包数量为 300 个左右。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@photon-machine [ ~ ]# rpm -qa | wc</span><br><span class="line">    146     146    4307</span><br></pre></td></tr></table></figure><ul><li>系统进程信息，还是采用 systemd 来管理进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">root@photon-machine [ ~ ]# systemctl status</span><br><span class="line">● photon-machine</span><br><span class="line">    State: running</span><br><span class="line">     Jobs: 0 queued</span><br><span class="line">   Failed: 0 units</span><br><span class="line">    Since: Tue 2020-09-22 08:07:29 UTC; 10min ago</span><br><span class="line">   CGroup: /</span><br><span class="line">           ├─user.slice</span><br><span class="line">           │   ├─session-c2.scope</span><br><span class="line">           │   │ ├─413 sshd: root@pts/0</span><br><span class="line">           │   │ ├─420 -bash</span><br><span class="line">           │   │ ├─443 systemctl status</span><br><span class="line">           │   │ └─444 systemctl status</span><br><span class="line">           │   └─user@0.service</span><br><span class="line">           │     └─init.scope</span><br><span class="line">           │       ├─393 /lib/systemd/systemd --user</span><br><span class="line">           │       └─394 (sd-pam)</span><br><span class="line">           ├─init.scope</span><br><span class="line">           │ └─1 /lib/systemd/systemd</span><br><span class="line">           └─system.slice</span><br><span class="line">             ├─systemd-networkd.service</span><br><span class="line">             │ └─245 /lib/systemd/systemd-networkd</span><br><span class="line">             ├─systemd-udevd.service</span><br><span class="line">             │ └─124 /lib/systemd/systemd-udevd</span><br><span class="line">             ├─vgauthd.service</span><br><span class="line">             │ └─159 /usr/bin/VGAuthService -s</span><br><span class="line">             ├─systemd-journald.service</span><br><span class="line">             │ └─97 /lib/systemd/systemd-journald</span><br><span class="line">             ├─sshd.service</span><br><span class="line">             │ └─352 /usr/sbin/sshd -D</span><br><span class="line">             ├─vmtoolsd.service</span><br><span class="line">             │ └─161 /usr/bin/vmtoolsd</span><br><span class="line">             ├─systemd-resolved.service</span><br><span class="line">             │ └─247 /lib/systemd/systemd-resolved</span><br><span class="line">             ├─dbus.service</span><br><span class="line">             │ └─157 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation --syslog-only</span><br><span class="line">             ├─systemd-timesyncd.service</span><br><span class="line">             │ └─151 /lib/systemd/systemd-timesyncd</span><br><span class="line">             └─systemd-logind.service</span><br><span class="line">               └─158 /lib/systemd/systemd-logind</span><br></pre></td></tr></table></figure><ul><li>磁盘根目录只使用了不到 600M</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@photon-machine [ ~ ]# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;root        16G  577M   15G   4% &#x2F;</span><br></pre></td></tr></table></figure><ul><li>内存也只使用了 43Mi，启动 dockerd 之后内存占用 108Mi，换成 containerd 将会小一些。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@photon-machine [ ~ ]# free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:          2.0Gi        43Mi       1.8Gi       0.0Ki       103Mi       1.8Gi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 dockerd 守护进程之后内存占用 108Mi</span></span><br><span class="line">root@photon-machine [ ~ ]# free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:          2.0Gi       108Mi       1.6Gi       0.0Ki       298Mi       1.8Gi</span><br></pre></td></tr></table></figure><ul><li>内核模块的数量也比较少 30 个左右，大部分都是一些网络相关的内核模块。常规的 Linux 发行版的内核模块往往在 60 个以上。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">root@photon-machine [ ~ ]# lsmod</span><br><span class="line">Module                  Size  Used by</span><br><span class="line">xt_conntrack           16384  2</span><br><span class="line">ip6table_mangle        16384  0</span><br><span class="line">ip6table_nat           16384  0</span><br><span class="line">nf_nat_ipv6            16384  1 ip6table_nat</span><br><span class="line">iptable_mangle         16384  0</span><br><span class="line">iptable_nat            16384  0</span><br><span class="line">nf_nat_ipv4            16384  1 iptable_nat</span><br><span class="line">nf_nat                 28672  2 nf_nat_ipv6,nf_nat_ipv4</span><br><span class="line">ip6table_filter        16384  1</span><br><span class="line">ip6_tables             24576  3 ip6table_filter,ip6table_nat,ip6table_mangle</span><br><span class="line">iptable_filter         16384  1</span><br><span class="line">xt_LOG                 16384  0</span><br><span class="line">nf_conntrack           90112  4 xt_conntrack,nf_nat,nf_nat_ipv6,nf_nat_ipv4</span><br><span class="line">nf_defrag_ipv6         20480  1 nf_conntrack</span><br><span class="line">nf_defrag_ipv4         16384  1 nf_conntrack</span><br><span class="line">mousedev               20480  0</span><br><span class="line">vfat                   20480  1</span><br><span class="line">fat                    61440  1 vfat</span><br><span class="line">evdev                  20480  1</span><br><span class="line">vmwgfx                253952  1</span><br><span class="line">psmouse                90112  0</span><br><span class="line">drm_kms_helper        106496  1 vmwgfx</span><br><span class="line">ttm                    86016  1 vmwgfx</span><br><span class="line">drm                   323584  4 vmwgfx,drm_kms_helper,ttm</span><br><span class="line">sr_mod                 24576  0</span><br><span class="line">i2c_core               40960  2 drm_kms_helper,drm</span><br><span class="line">cdrom                  49152  1 sr_mod</span><br><span class="line">rdrand_rng             16384  0</span><br><span class="line">rng_core               16384  1 rdrand_rng</span><br><span class="line">ipv6                  368640  16 nf_nat_ipv6,ip6table_mangle</span><br><span class="line">root@photon-machine [ ~ ]# lsmod | wc</span><br><span class="line">     31     109    1273</span><br></pre></td></tr></table></figure><ul><li>系统自带的 docker 版本为 <code>19.03.10</code>，存储驱动使用的是 <code>overlay2</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Client:</span><br><span class="line"> Debug Mode: false</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Containers: 0</span><br><span class="line">  Running: 0</span><br><span class="line">  Paused: 0</span><br><span class="line">  Stopped: 0</span><br><span class="line"> Images: 0</span><br><span class="line"> Server Version: 19.03.10</span><br><span class="line"> Storage Driver: overlay2</span><br><span class="line">  Backing Filesystem: extfs</span><br><span class="line">  Supports d_type: true</span><br><span class="line">  Native Overlay Diff: true</span><br><span class="line"> Logging Driver: json-file</span><br><span class="line"> Cgroup Driver: cgroupfs</span><br><span class="line"> Plugins:</span><br><span class="line">  Volume: local</span><br><span class="line">  Network: bridge host ipvlan macvlan null overlay</span><br><span class="line">  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line"> Swarm: inactive</span><br><span class="line"> Runtimes: runc</span><br><span class="line"> Default Runtime: runc</span><br><span class="line"> Init Binary: docker-init</span><br><span class="line"> containerd version: b34a5c8af56e510852c35414db4c1f4fa6172339</span><br><span class="line"> runc version: d736ef14f0288d6993a1845745d6756cfc9ddd5a</span><br><span class="line"> init version: fec3683</span><br><span class="line"> Security Options:</span><br><span class="line">  apparmor</span><br><span class="line">  seccomp</span><br><span class="line">   Profile: default</span><br><span class="line"> Kernel Version: 4.19.132-5.ph3-esx</span><br><span class="line"> Operating System: VMware Photon OS/Linux</span><br><span class="line"> OSType: linux</span><br><span class="line"> Architecture: x86_64</span><br><span class="line"> CPUs: 1</span><br><span class="line"> Total Memory: 1.951GiB</span><br><span class="line"> Name: photon-machine</span><br><span class="line"> ID: HXBT:Z4LZ:4HZM:3YII:U7ZA:RVOH:Z7CL:L4FA:YGA4:Y2V6:DSVR:NWPD</span><br><span class="line"> Docker Root Dir: /var/lib/docker</span><br><span class="line"> Debug Mode: false</span><br><span class="line"> Registry: https://index.docker.io/v1/</span><br><span class="line"> Labels:</span><br><span class="line"> Experimental: false</span><br><span class="line"> Insecure Registries:</span><br><span class="line">  127.0.0.0/8</span><br><span class="line"> Live Restore Enabled: false</span><br><span class="line"> Product License: Community Engine</span><br></pre></td></tr></table></figure><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><ul><li>查看网卡状态，可使用自带的 <code>networkctl</code> 命令行工具，像 ifconfig、ip、ss 等命令都已经默认安装。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@photon-machine [ /mnt/RPMS ]# networkctl status eth0</span><br><span class="line">● 2: eth0</span><br><span class="line">       Link File: /usr/lib/systemd/network/99-default.link</span><br><span class="line">    Network File: /etc/systemd/network/99-dhcp-en.network</span><br><span class="line">            Type: ether</span><br><span class="line">           State: routable (configured)</span><br><span class="line">            Path: pci-0000:0b:00.0</span><br><span class="line">          Driver: vmxnet3</span><br><span class="line">          Vendor: VMware</span><br><span class="line">           Model: VMXNET3 Ethernet Controller</span><br><span class="line">      HW Address: 00:0c:29:74:13:16 (VMware, Inc.)</span><br><span class="line">         Address: 192.168.0.235</span><br><span class="line">                  fe80::20c:29ff:fe74:1316</span><br><span class="line">         Gateway: 192.168.0.1 (NETGEAR)</span><br><span class="line">             DNS: 119.29.29.29</span><br><span class="line">                  223.6.6.6</span><br><span class="line">        CLIENTID: ffb6220feb00020000ab113bc2c88225c0d29b</span><br><span class="line">    Connected To: n/a on port 00:e0:4c:68:54:12</span><br><span class="line">                  n/a on port 00:e0:4c:68:54:13</span><br><span class="line">                  n/a on port 00:e0:4c:68:54:15</span><br></pre></td></tr></table></figure><ul><li>系统安装时默认使用的 DHCP 获取 IP ，可以使用 systemd 来设置静态 IP</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先修改 DHCP 的 systemd 文件，关闭 DHCP</span></span><br><span class="line">sed -i 's/yes/no/' /etc/systemd/network/99-dhcp-en.network</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建静态 IP 的 systemd 文件</span></span><br><span class="line">cat &gt; /etc/systemd/network/10-static-en.network &lt;&lt; "EOF"</span><br><span class="line"></span><br><span class="line">[Match]</span><br><span class="line">Name=eth0</span><br><span class="line"></span><br><span class="line">[Network]</span><br><span class="line">Address=198.168.0.235/24</span><br><span class="line">Gateway=198.168.0.1</span><br><span class="line">DNS=192.168.0.100</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改以下文件权限为 644 ，不然启动的时候会报错提示权限问题</span></span><br><span class="line">chmod 644 /etc/systemd/network/10-static-en.network</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启一下网络</span></span><br><span class="line">systemctl restart systemd-networkd</span><br></pre></td></tr></table></figure><ul><li>挂载 NFS 文件系统需要安装 <code>nfs-utils</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tdnf install nfs-utils -y</span><br><span class="line">mount 192.168.0.100:/nfs /mnt/nfs</span><br></pre></td></tr></table></figure><h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><p>Photon OS 使用的是 yum/tdnf 作为包管理器，使用方法和 RedHat 系的发行版基本相同，repo 主要有以下几个：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls /etc/yum.repos.d/</span><br><span class="line">lightwave.repo</span><br><span class="line">photon-extras.repo</span><br><span class="line">photon-iso.repo</span><br><span class="line">photon-updates.repo</span><br><span class="line">photon.repo</span><br></pre></td></tr></table></figure><h3 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h3><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><h3 id="Pi-hole"><a href="#Pi-hole" class="headerlink" title="Pi-hole"></a>Pi-hole</h3><blockquote><p>  Pi-hole 是一款开源且免费的 DNS 沉洞服务器（DNS sinkhole），能够在不安装任何客户端侧软件的前提下为设备提供网络内容屏蔽服务，非常轻量易用。搭配上家中吃灰已久的树莓派，我们就能够轻松打造属于自己的广告屏蔽助手。<br>  在<a href="https://pi-hole.net/" target="_blank" rel="noopener">官网</a>的介绍中，Pi-hole 主要具有以下优点：</p><ul><li>易于安装和配置（号称 10 分钟安装配置一条龙）。</li><li>全平台，广告屏蔽服务可作用于任何设备，包括PC、手机、平板电脑。</li><li>轻量，对硬件要求极低。</li><li>功能稳定且强大，能轻松 hold 住百万级别的请求。</li><li>提供了美观的 Web 数据监控仪表盘。</li><li>开源且免费。</li></ul></blockquote><ul><li>首先需要关闭 systemd 自带的 DNS 服务，不然 Pi-hole 坚挺的 53 端口会被占用</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop systemd-resolved</span><br><span class="line">systemctl disable systemd-resolved</span><br></pre></td></tr></table></figure><ul><li>安装 docker-compose，修改 docker-compose.yaml 文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="comment"># More info at https://github.com/pi-hole/docker-pi-hole/ and https://docs.pi-hole.net/</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">pihole:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">pihole</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">pihole/pihole:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"53:53/tcp"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"53:53/udp"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"67:67/udp"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"80:80/tcp"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"443:443/tcp"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">'Asia/Shanghai'</span></span><br><span class="line">      <span class="attr">WEBPASSWORD:</span> <span class="string">'changeme'</span></span><br><span class="line">    <span class="comment"># Volumes store your data between container upgrades</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'./etc-pihole/:/etc/pihole/'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'./etc-dnsmasq.d/:/etc/dnsmasq.d/'</span></span><br><span class="line">    <span class="comment"># Recommended but not required (DHCP needs NET_ADMIN)</span></span><br><span class="line">    <span class="comment">#   https://github.com/pi-hole/docker-pi-hole#note-on-capabilities</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure><ul><li>docker-compose up 走起！</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">root@PhotonOS [ /opt/docker/pihole ]# docker-compose up</span><br><span class="line">Creating network "pihole_default" with the default driver</span><br><span class="line">Creating pihole ... done</span><br><span class="line">Attaching to pihole</span><br><span class="line">pihole    | [s6-init] making user provided files available at /var/run/s6/etc...exited 0.</span><br><span class="line">pihole    | [s6-init] ensuring user provided files have correct perms...exited 0.</span><br><span class="line">pihole    | [fix-attrs.d] applying ownership &amp; permissions fixes...</span><br><span class="line">pihole    | [fix-attrs.d] 01-resolver-resolv: applying...</span><br><span class="line">pihole    | [fix-attrs.d] 01-resolver-resolv: exited 0.</span><br><span class="line">pihole    | [fix-attrs.d] done.</span><br><span class="line">pihole    | [cont-init.d] executing container initialization scripts...</span><br><span class="line">pihole    | [cont-init.d] 20-start.sh: executing...</span><br><span class="line">pihole    |  ::: Starting docker specific checks &amp; setup for docker pihole/pihole</span><br><span class="line">  [✓] Update local cache of available packages</span><br><span class="line">pihole    |   [i] Existing PHP installation detected : PHP version 7.0.33-0+deb9u8</span><br><span class="line">pihole    |</span><br><span class="line">pihole    |   [i] Installing configs from /etc/.pihole...</span><br><span class="line">pihole    |   [i] Existing dnsmasq.conf found... it is not a Pi-hole file, leaving alone!</span><br><span class="line">  [✓] Copying 01-pihole.conf to /etc/dnsmasq.d/01-pihole.conf</span><br><span class="line">pihole    | chown: cannot access '': No such file or directory</span><br><span class="line">pihole    | chmod: cannot access '': No such file or directory</span><br><span class="line">pihole    | chown: cannot access '/etc/pihole/dhcp.leases': No such file or directory</span><br><span class="line">pihole    | ::: Pre existing WEBPASSWORD found</span><br><span class="line">pihole    | Using default DNS servers: 8.8.8.8 &amp; 8.8.4.4</span><br><span class="line">pihole    | DNSMasq binding to default interface: eth0</span><br><span class="line">pihole    | Added ENV to php:</span><br><span class="line">pihole    |                     "PHP_ERROR_LOG" =&gt; "/var/log/lighttpd/error.log",</span><br><span class="line">pihole    |                     "ServerIP" =&gt; "0.0.0.0",</span><br><span class="line">pihole    |                     "VIRTUAL_HOST" =&gt; "0.0.0.0",</span><br><span class="line">pihole    | Using IPv4 and IPv6</span><br><span class="line">pihole    | ::: Preexisting ad list /etc/pihole/adlists.list detected ((exiting setup_blocklists early))</span><br><span class="line">pihole    | https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts</span><br><span class="line">pihole    | https://mirror1.malwaredomains.com/files/justdomains</span><br><span class="line">pihole    | ::: Testing pihole-FTL DNS: FTL started!</span><br><span class="line">pihole    | ::: Testing lighttpd config: Syntax OK</span><br><span class="line">pihole    | ::: All config checks passed, cleared for startup ...</span><br><span class="line">pihole    |  ::: Docker start setup complete</span><br><span class="line">pihole    |   [i] Neutrino emissions detected...</span><br><span class="line">  [✓] Pulling blocklist source list into range</span><br><span class="line">pihole    |</span><br><span class="line">  [✓] Preparing new gravity database</span><br><span class="line">pihole    |   [i] Target: https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts</span><br><span class="line">pihole    |   [i] Received 55654 domains</span><br><span class="line">pihole    |   [i] Target: https://mirror1.malwaredomains.com/files/justdomains</span><br><span class="line">  [✓] Status: No changes detected</span><br><span class="line">pihole    |   [i] Received 26854 domains</span><br><span class="line">  [✓] Storing downloaded domains in new gravity database</span><br><span class="line">  [✓] Building tree</span><br><span class="line">  [✓] Swapping databases</span><br><span class="line">pihole    |   [i] Number of gravity domains: 82508 (82465 unique domains)</span><br><span class="line">pihole    |   [i] Number of exact blacklisted domains: 0</span><br><span class="line">pihole    |   [i] Number of regex blacklist filters: 0</span><br><span class="line">pihole    |   [i] Number of exact whitelisted domains: 0</span><br><span class="line">pihole    |   [i] Number of regex whitelist filters: 0</span><br><span class="line">  [✓] Cleaning up stray matter</span><br><span class="line">pihole    |</span><br><span class="line">pihole    |   [✓] DNS service is running</span><br><span class="line">pihole    |   [✓] Pi-hole blocking is Enabled</span><br><span class="line">pihole    |   Pi-hole version is v5.1.2 (Latest: v5.1.2)</span><br><span class="line">pihole    |   AdminLTE version is v5.1.1 (Latest: v5.1.1)</span><br><span class="line">pihole    |   FTL version is v5.2 (Latest: v5.2)</span><br><span class="line">pihole    | [cont-init.d] 20-start.sh: exited 0.</span><br><span class="line">pihole    | [cont-init.d] done.</span><br><span class="line">pihole    | [services.d] starting services</span><br><span class="line">pihole    | Starting pihole-FTL (no-daemon) as root</span><br><span class="line">pihole    | Starting lighttpd</span><br><span class="line">pihole    | Starting crond</span><br><span class="line">pihole    | [services.d] done.</span><br></pre></td></tr></table></figure><ul><li>打开浏览器，输入 <code>http://ip:port/admin</code> 即可进入 Pi-hole 的后台管理页面，在这里可以查看到 DNS 解析的详细记录，关于 Pi-hole 的使用可以参考一些大佬的博客，比如 <a href="https://wzyboy.im/post/1372.html" target="_blank" rel="noopener">搭建 Pi-Hole 为网上冲浪保驾护航</a>。</li></ul><p><img src="img/20200925-pihole.png" alt=""></p><p>如果想要让内网的机器都走 Pi-hole 来进行 DNS ，可以将路由器的 DHCP 的  DNS 的 IP 设置为 Pi-hole 的 IP。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://cloud.google.com/blog/products/containers-kubernetes/bringing-ebpf-and-cilium-to-google-kubernetes-engine" target="_blank" rel="noopener">New GKE Dataplane V2 increases security and visibility for containers</a></li><li><a href="https://moelove.info/2020/09/02/%E8%A2%AB-Google-%E9%80%89%E6%8B%A9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%95%B0%E6%8D%AE%E9%9D%A2-Cilium-%E6%98%AF%E4%BB%80%E4%B9%88/" target="_blank" rel="noopener">被 Google 选择的下一代数据面 Cilium 是什么</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;前段时间捡垃圾东拼西凑搞了台 Homelab 👇玩玩
        
      
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.k8s.li/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="容器" scheme="https://blog.k8s.li/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="PhotonOS" scheme="https://blog.k8s.li/tags/PhotonOS/"/>
    
      <category term="Linux" scheme="https://blog.k8s.li/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>给阵列卡刷个机，IR 模式转 IT 模式</title>
    <link href="https://blog.k8s.li/lsi-9211-4i-ir-to-it.html"/>
    <id>https://blog.k8s.li/lsi-9211-4i-ir-to-it.html</id>
    <published>2020-09-07T16:00:00.000Z</published>
    <updated>2020-09-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="刷机？"><a href="#刷机？" class="headerlink" title="刷机？"></a>刷机？</h2><p>不久前捡垃圾搞了一台低功耗 Homelab 主机玩玩，由于主板 SATA 口的限制，不能使用大于 2TB 的硬盘，对于咱梦想着这种拥有几十 TB 存储来存放老婆的死肥宅来说，2TB 怎么够了。于是想要突破限制，再给 Homelab 主机增加一块 6TB 的磁盘。于是，在洋垃圾堆里花了 50 块钱捡了这块阵列卡👇。</p><p><img src="img/20200830_9211-4i-01.jpg" alt=""></p><p>买的这块阵列卡型号是 <a href="https://lenovopress.com/tips0831-serveraid-h1110" target="_blank" rel="noopener">ServeRAID H1110 SAS/SATA Controller for IBM System x </a> ，卖家说是 <code>IBM H1110</code> ，其实都差不多啦。由于是第一次玩儿阵列卡，对这种型号也不是很熟悉，之后刷了新的固件又变成了 <code>LSI 9211-4i</code> 。</p><h2 id="翻车？"><a href="#翻车？" class="headerlink" title="翻车？"></a>翻车？</h2><p>收到货后，迫不及待地将存满老婆的硬盘接到阵列卡上，开机的时候，一直卡在阵列卡 BIOS 初始化页面很久很久。顿时觉着，完蛋翻车了，正准备去怼一波卖家，阵列卡启动等了五六分钟后进入了久违的  ESXi 的启动页面。这尼玛，坑我啊，你一个巴掌大的阵列卡启动竟然需要五分钟？内心一万匹草泥马奔腾而过。</p><p><img src="img/20200830_9211-4i-02.png" alt=""></p><h2 id="IR-模式？"><a href="#IR-模式？" class="headerlink" title="IR 模式？"></a>IR 模式？</h2><p>在网上看来一下大佬们的评论，说阵列卡 IR 模式的启动速度要慢一些？然后又找到了 <a href="https://wiki2.xbits.net:4430/hardware:lsi:h1110-it-firmware" target="_blank" rel="noopener">IBM H1110卡刷为LSI 9211-4i IT固件</a> ，里面提到的可以将 IR 模式刷为 IT 直通模式。至于 IR 模式和 IT 模式，自己太菜没找到确切的资料。大概可以理解为 IR 模式适用于使用阵列卡组 RAID 阵列，而 IT 模式就是所谓的直通模式，不适用 RAID ，只使用阵列卡的磁盘控制器？相当于主板上的 SATA 接口。何况我这个是小主机，里面也塞不下那么多的磁盘，所以阵列卡使用 IT 直通模式无疑是最好的选择。</p><p><img src="img/20200828_9211-4i-03.jpg" alt=""></p><h2 id="万物皆可刷？"><a href="#万物皆可刷？" class="headerlink" title="万物皆可刷？"></a>万物皆可刷？</h2><p>参照大佬们的博客，咱也要体验一把刷<del>机</del>卡的痛快了，毕竟折腾这些没用的玩意儿也是咱的一大乐趣。</p><blockquote><p>  我青年时代就刷过：诺基亚、摩托罗拉、三星、黑莓、Lumia、HTC，我还刷过：路由器、交换机、阵列卡、电视盒子……</p></blockquote><p>安卓<del>基</del>机佬们想必对 twrp 再熟悉不过了，它是我们刷机，刷各种 ROM 包最常用的系统，相当于 Windows 中的 PE 系统，对系统分区刷上 ROM 来达到刷机的目的。刷阵列卡的固件和刷机也差不多，也是需要一个底层的系统进去对阵列卡上的存储芯片进行操作。最常见的就是 Dos 和 EFI Shell ，由于 Dos 年代久远，且我的主板对 EFI 支持比较友好，在进行刷机的时候为了稳妥起见选择 EFI shell。</p><h3 id="记录-SAS-地址"><a href="#记录-SAS-地址" class="headerlink" title="记录 SAS 地址"></a>记录 SAS 地址</h3><p>在刷阵列卡之前要线记录下 SAS 的 Address ，进入到阵列卡的 BIOS 中会有这个信息。</p><h3 id="找好固件和文档"><a href="#找好固件和文档" class="headerlink" title="找好固件和文档"></a>找好固件和文档</h3><p>由于我要刷入的固件不是阵列卡原厂的固件，只找到了现成的固件，直接就拿来用了，应该问题不大。而且刷入的流程也是比较简答。<a href="https://wiki2.xbits.net:4430/hardware:lsi:h1110-it-firmware" target="_blank" rel="noopener">IBM H1110卡刷为LSI 9211-4i IT固件</a> :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 备份原卡信息和sbr</span></span><br><span class="line">MegaCli.exe -AdpAllInfo -aAll -ApplogFile bak.txt</span><br><span class="line">MegaRec.exe -readsbr 0 orig.sbr</span><br><span class="line"><span class="meta">#</span><span class="bash">擦写sbr和flash一遍能刷入LSI原厂固件</span></span><br><span class="line">MegaRec -writesbr 0 sbrempty.bin</span><br><span class="line">MegaRec -cleanflash 0</span><br><span class="line"><span class="meta">#</span><span class="bash">重启再次进入DOS</span></span><br><span class="line">reboot</span><br><span class="line"><span class="meta">#</span><span class="bash">刷入对应IT固件和ROM</span></span><br><span class="line">sas2flsh -o -f 2114it.bin -b mptsas2.rom</span><br><span class="line"><span class="meta">#</span><span class="bash">恢复原来的SAS地址</span></span><br><span class="line">sas2flsh -o -sasadd xxxxxxxx</span><br><span class="line"><span class="meta">#</span><span class="bash">查看最新状态</span></span><br><span class="line">sas2flsh -list</span><br><span class="line"><span class="meta">#</span><span class="bash">重启，完成</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>一些官方的文档<a href="https://www.broadcom.cn/support/knowledgebase/1211161495925/flash-upgrading-firmware-on-lsi-sas-hbas-upgraded-firmware-on-92" target="_blank" rel="noopener">Flash upgrading firmware on LSI SAS HBAs; Upgraded firmware on 9211-8i to P8, now duplicated drives</a>：</p><blockquote><p>  Advanced users:</p><p>  To delete the firmware and BIOS in your 9211, then reflash it, follow these steps:</p><ol><li><p>Check to see if there is an also an onboard SATA controller with disk in the system before running the commands below.<br>Run sas2flsh -listall<br>If you see only the 9211, then run the commands as shown below.<br>If you see two controllers (e.g. c0 and c1, then add -c 1 to all of the commands below–&gt; sas2flsh -c 1 -o -e 6</p></li><li><p>Record the SAS address of the 9211 in case you need it later.  To display it, type:<br>sas2flsh -list</p><p>and write down the SAS address.  You can run the is DOS, Windows, Linux, etc.</p></li><li><p>Download 9211_8i_Package_for_P9_Firmware_BIOS_on_MSDOS_and_Windows.zip for the 9211-8i</p></li><li><p>Boot to DOS (create a DOS bootable USB stick from <a href="http://www.bootdisk.com" target="_blank" rel="noopener">http://www.bootdisk.com</a> or <a href="http://www.gocoding.com" target="_blank" rel="noopener">www.gocoding.com</a>).</p></li><li><p>Run from DOS sas2flsh -o -e 6 (this will erase the controller firmware and BIOS).</p></li><li><p>Turn the system off.</p></li><li><p>Turn the system on and boot to DOS (note:  the BIOS won’t post, as you will reflash it in step 8 below).</p></li><li><p>Run from DOS, with files sas2flsh.exe, the .bin and .rom files in the same directory:</p><p>For IR firmware:  sas2flsh -f 9211IRP9.bin -b mptsas2.rom<br>For IT firmware:  sas2flsh -f 9211itp9.bin -b mptsas2.rom</p><p>Note:  you will need to rename 9211-8i_IR_P9.bin to 9211IRP9.bin and 9211-8i-IT_ph9.bin to 9211itp9.bin</p></li><li><p>The controller will now work normally, with the P9 firmware and BIOS.</p></li><li><p>Check to make sure you have a SAS address:<br>sas2flsh -list<br>If you see the same SAS address that you had in step 2, then you are done.<br>If you don’t see the same SAS address, or you don’t see a SAS address, type:<br>sas2flsh -o -sasadd <SAS address></p></li></ol></blockquote><p>上面提到的都是基于 Dos 系统上操作的，不过我试了一下都翻车了🤣</p><h3 id="制作-EFI-shell-系统"><a href="#制作-EFI-shell-系统" class="headerlink" title="制作 EFI shell 系统"></a>制作 EFI shell 系统</h3><p>如果主板支持 EFI 的话，建议使用 EFI shell 刷入固件，在 Dos 下会有些奇怪的问题。</p><p>按照 <a href="https://superuser.com/questions/1057446/how-do-i-boot-to-uefi-shell" target="_blank" rel="noopener">How do I “Boot to UEFI shell”?</a> 中提到的：</p><blockquote><p>It depends on whether your UEFI has a shell builtin. If it does, there should be an option in its settings / boot menu for you to launch it. Some motherboard also provide an option to launch a shell from the EFI System Partition (ESP). You should consult the manual of your motherboard for the path it will look for (the instruction is often vague though). Usually they are looking for a file named <code>Shell.efi</code> in the ESP root folder.</p><p>Another way is to launch it just like you launch any other EFI binary (e.g. bootloader). Since it’s not really accessible to register a EFI binary to your UEFI or put the shell binary to your ESP in Windows, so the easiest way is probably to put it as <code>\EFI\Boot\bootx64.efi</code> <strong>(also put the <code>update.nsh</code> you need to run and the files it requires under <code>\EFI\Boot\</code>)</strong> in a FAT(32)-formatted USB drive (It shouldn’t matter whether it’s MBR or GPT as long as your UEFI is standard-conforming enough). <strong>Then reboot and boot the USB in UEFI mode from your UEFI boot menu.</strong></p><p>You can obtain the EFI shell binary from the EDK2 project repo:</p><ul><li><p><a href="https://github.com/tianocore/edk2/releases/download/edk2-stable202002/ShellBinPkg.zip" target="_blank" rel="noopener">version 2</a></p></li><li><p><a href="https://github.com/tianocore/edk2/blob/UDK2018/EdkShellBinPkg/FullShell/X64/Shell_Full.efi?raw=true" target="_blank" rel="noopener">version 1 (no longer updated, only for old UEFI that does not work with v2)</a></p><p>(<strong>Note:</strong> some older EFI tools like [sas2flash.efi](<a href="https://www.broadcom.com/site-search?q=Installer" target="_blank" rel="noopener">https://www.broadcom.com/site-search?q=Installer</a> for UEFI) only work with such an old EFI shell (which works on current mainboards with current UEFI))</p></li></ul></blockquote><p>首先需要一个 U 盘，对容量没有闲置，几十兆足够，把分区格式化为 FAT32 文件系统格式，然后下载一个 EFI shell 的 efi 文件 <a href="https://github.com/tianocore/edk2/blob/UDK2018/EdkShellBinPkg/FullShell/X64/Shell_Full.efi?raw=true" target="_blank" rel="noopener">version 1 </a>，把该文件保存在 FAT32 分区下的 <code>\EFI\Boot\bootx64.efi</code> 路径下。</p><blockquote><p>  Download from Github Tianocore the precompiled UEFI version 1 Shell: <a href="https://github.com/tianocore/edk2/tree/master/EdkShellBinPkg/FullShell/X64" target="_blank" rel="noopener">Shell_Full.efi</a>. (Only v1 is applicable, later versions are not compatible with the flash tool and end up with the message: “InitShellApp: Application not started from Shell”.)</p></blockquote><p>由于刷固件的工具 <code>sas2flash.efi</code> 只和 EFI shell v1 版本的兼容，我第一次刷的时候时使用的 v2 版本，提示 <code>“InitShellApp: Application not started from Shell”</code> 错误😂</p><p>然后还需要把固件 <code>2114it.bin</code> ，以及刷固件用到的工具 <code>sas2flash.efi</code> 放入到 FAT32 跟目录下，其中固件根据阵列卡的型号不同需要自行找到相应的固件版本，我这个虽然是 IBM H1110 型号的，但是可以刷成 LSI 9211 的，所以就没去找原厂的固件。</p><h3 id="进入-EFI-shell-刷入新的固件"><a href="#进入-EFI-shell-刷入新的固件" class="headerlink" title="进入 EFI shell 刷入新的固件"></a>进入 EFI shell 刷入新的固件</h3><p>从 <a href="https://www.ixsystems.com/community/threads/how-to-flash-lsi-9211-8i-using-efi-shell.50902/" target="_blank" rel="noopener">How-to: Flash LSI 9211-8i using EFI shell</a> 大佬那里复制粘贴过来的的教程：</p><blockquote><ol><li>Insert the controller card in a PCIe slot. (I’ve used the slot Nr. 3. In case of troubles recognizing the card in your desktop PC try different slots.)</li><li>Boot the PC and prepare the USB stick:</li><li>In the USB stick create and format a FAT or FAT32 partition &gt;= 10 MB. (I’ve created 500 MB FAT32 partition. I wouldn’t recommend large partitions, who knows if the EFI shell will read every big partition.)</li><li>Create the sub-folders for EFI boot. In the web there are two different structures: <code>/boot/efi</code> and <code>/efi/boot</code>. For time saving I’ve created both groups, it works.</li><li>Download from Broadcom following packages: <a href="https://docs.broadcom.com/docs/12350820" target="_blank" rel="noopener">Installer_P20_for_UEFI</a> and <a href="https://docs.broadcom.com/docs/12350530" target="_blank" rel="noopener">9211-8i_Package_P20_IR_IT_Firmware_BIOS_for_MSDOS_Windows</a> and extract them on your PC’s HDD.</li><li>Copy from the downloaded packages three files to the USB stick root folder:</li><li>from the first package the file <code>sas2flash.efi</code> (it is in sub-folder <code>/sas2flash_efi_ebc_rel/</code>);</li><li>from the second package: <code>2118it.bin</code> (it is in sub-folder <code>/Firmware/HBA_9211_8i_IT/</code>) and <code>mptsas2.rom</code> (it is in sub-folder <code>/sasbios_rel/</code>).</li><li>Download from Github Tianocore the precompiled UEFI version 1 Shell: <a href="https://github.com/tianocore/edk2/tree/master/EdkShellBinPkg/FullShell/X64" target="_blank" rel="noopener">Shell_Full.efi</a>. (Only v1 is applicable, later versions are not compatible with the flash tool and end up with the message: “InitShellApp: Application not started from Shell”.)</li><li>Rename the <code>Shell_Full.efi</code> in <code>ShellX64.efi</code> and copy this file to following three USB stick destinations: root folder, <code>/boot/efi/</code>, <code>/efi/boot/</code>. (Again, there are different advices, for time saving it easier to use all three choices.)</li><li>The creative part is completed, it’s time for action. Restart the PC and enter the BIOS. If you use ASUS UEFI BIOS Utility in advanced mode, mouse click on the Exit (not by using keyboard “Esc”), in the next dialog select “Launch EFI Shell from filesystem device”. Other BIOS should behave similarly.</li><li>Next you should see starting shell execution, ending with a prompt: “Shell&gt;” (not the “2.0 Shell&gt;”!).</li><li>Type the command: <code>map –b</code> (+Enter) for listing of available disks. Locate which one is your USB stick. In my case it is the fs6:<br>“fs6 :Removable HardDisk - … USB(…)”</li><li>You can break further execution of the map command by <code>q</code>.</li><li>Switch to the located USB stick by command <code>fsN:</code> (+Enter) (N=6 – in my example = “fs6:”, set N to your USB stick ID).</li><li><code>Dir</code> shows the file list:<br>2118IT.BIN<br>MPTSAS2.ROM<br>sas2flash.efi<DIR> BOOT<DIR> EFIShellX64.efi</li><li>The action can start. During it the power shall not be brocken!</li><li>Erase the controller flash memory: <code>sas2flash.efi -o -e 6</code>.</li><li>Write the new firmware to the flash: <code>sas2flash.efi -o -f 2118it.bin -b mptsas2.rom</code>.</li><li>After a while you’ll see the success message. You can restart the PC and check if the controller BIOS reports the new “IT”-firmware.</li><li>The card is ready to use.</li></ol></blockquote><ul><li>使用 <code>map -b</code> 命令查看 U 盘的路径，一般为 <code>fsX</code> 然后按下 <code>fs0:</code> 路径就切换到了 U 盘的 FAT32 分区下。</li></ul><p><img src="img/20200828_9211-4i-04.jpg" alt=""></p><ul><li>然后使用 <code>sas2flash.efi -o -e 6</code> 命令清空阵列卡的  <code>flash memory</code>。</li><li>接着使用 <code>sas2flsh -o -f 2114it.bin -b mptsas2.rom</code> 命令刷入新的固件。</li></ul><p><img src="img/20200828_9211-4i-05.jpg" alt=""></p><ul><li>恢复 SAS 地址 <code>sas2flsh -o -sasadd xxxxxxxx</code> </li></ul><p>操作完以上步骤后就可以重启了</p><h2 id="IT-模式？"><a href="#IT-模式？" class="headerlink" title="IT 模式？"></a>IT 模式？</h2><p>刷完之后阵列卡的型号就莫名其妙地变成了 <code>LSI® SAS 9211-4i PCI Express® to 6Gb/s Serial Attached SCSI (SAS) Host Bus Adapter</code> ，固件的版本也变成了  IT 模式，开机的速度比以前快了很多，只需要不到 5s 就自检完成进入 ESXi 的启动流程，终于告别原先的龟速启动了。</p><p><img src="img/20200828_9211-4i-06.jpg" alt=""></p><p>在 ESXi 中，阵列卡也被识别为了 <code>LSI2004</code> ，看来是没问题了，插上硬盘也都是识别出来了。</p><p><img src="img/20200908_9211-4i-07.png" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>由于是是第一次给阵列卡刷固件，在网上找到了写资料可以做参考。</p><ul><li><a href="https://wiki2.xbits.net:4430/hardware:lsi:h1110-it-firmware" target="_blank" rel="noopener">IBM H1110卡刷为LSI 9211-4i IT固件</a></li><li><a href="https://www.tfir.io/easiest-way-to-flash-lsi-sas-9211-8i-on-motherboards-without-efi-shell/" target="_blank" rel="noopener">Easiest Way To Flash LSI SAS 9211-8i on Motherboards without EFI Shell</a></li><li><a href="https://www.broadcom.cn/support/knowledgebase/1211161495925/flash-upgrading-firmware-on-lsi-sas-hbas-upgraded-firmware-on-92" target="_blank" rel="noopener">Flash upgrading firmware on LSI SAS HBAs; Upgraded firmware on 9211-8i to P8, now duplicated drives</a></li><li><a href="chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=https%3A%2F%2Fdocs.broadcom.com%2Fdoc%2F12353332">LSI® SAS 9211-4i PCI Express® to 6Gb/s Serial Attached SCSI (SAS) Host Bus Adapter </a></li><li><a href="https://www.ixsystems.com/community/threads/how-to-flash-lsi-9211-8i-using-efi-shell.50902/" target="_blank" rel="noopener">How-to: Flash LSI 9211-8i using EFI shell</a></li><li><a href="https://github.com/bsodmike/s5clouds8-lsi9211-8i-IR-to-IT-EFI-bootable-usb" target="_blank" rel="noopener">s5clouds8-lsi9211-8i-IR-to-IT-EFI-bootable-usb</a></li><li><a href="https://superuser.com/questions/1057446/how-do-i-boot-to-uefi-shell" target="_blank" rel="noopener">How do I “Boot to UEFI shell”?</a></li><li><a href="https://forums.laptopvideo2go.com/topic/29059-sas2008-lsi92409211-firmware-files/" target="_blank" rel="noopener">SAS2008 (LSI9240/9211) Firmware files</a></li><li><a href="https://www.servethehome.com/ibm-serveraid-m1015-part-4/" target="_blank" rel="noopener">IBM ServeRAID M1015 Part 4: Cross flashing to a LSI9211-8i in IT or IR mode</a></li><li><a href="https://web.archive.org/web/20200423162708/http://brycv.com/blog/2012/flashing-it-firmware-to-lsi-sas9211-8i/" target="_blank" rel="noopener">Flashing IT Firmware to the LSI SAS9211-8i HBA</a></li><li><a href="https://forum.openmediavault.org/index.php?thread/2310-ibm-m1015-ir-vs-it/" target="_blank" rel="noopener">IBM M1015 - IR vs. IT</a></li><li><a href="https://marcan.st/2016/05/crossflashing-the-fujitsu-d2607/" target="_blank" rel="noopener">Crossflashing the Fujitsu D2607</a></li><li><a href="https://kc.mcafee.com/corporate/index?page=content&id=KB90801&locale=en_US" target="_blank" rel="noopener">How to create a bootable USB media to access the default EFI shell</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;刷机？&quot;&gt;&lt;a href=&quot;#刷机？&quot;
        
      
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.k8s.li/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="刷机" scheme="https://blog.k8s.li/tags/%E5%88%B7%E6%9C%BA/"/>
    
      <category term="阵列卡" scheme="https://blog.k8s.li/tags/%E9%98%B5%E5%88%97%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>垃圾佬的 Homelab 折腾记录</title>
    <link href="https://blog.k8s.li/homelab.html"/>
    <id>https://blog.k8s.li/homelab.html</id>
    <published>2020-08-20T16:00:00.000Z</published>
    <updated>2021-02-24T13:40:34.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="捡垃圾"><a href="#捡垃圾" class="headerlink" title="捡垃圾"></a>捡垃圾</h2><p>来自 <a href="https://space.bilibili.com/1292029" target="_blank" rel="noopener">@awpak78 </a>的图👇</p><p><img src="img/20200801_150112.jpg" alt="20200801_150112"></p><p>作为一名运维工程师，白天在工地上搬砖养家糊口，晚上下班回家后就开始折腾一堆破铜烂铁自娱自乐😂。最近东拼西凑花了 2000 来块钱捡垃圾整了台 HomeLab 玩玩，折腾一些没用的东西🙃</p><p>其实很早之前就想搞一台低功耗的 HomeLab 主机玩儿了，最早开始选择的是 Dell T1700 SFF + E3-1271V3 +32GB DDR3，但是呢，E3 V3 系列是 Intel 第四代  CPU ，1150 芯片组无法从 M.2 启动，磁盘速度只能达到 SATA III 也就是顶多 600 MB/s 的读写速度，而目前随便一块支持  PCI-e M.2 NVMe 的主板普遍都能达到 3000MB/s 了。所以这一点来讲 E3 V3 已经不值得捡了。而且我想把我台式机上 SN750 500GB 换到这台机器上，所以还是要选择一个支持 PCI-e M.2 NVMe 的主板。</p><table><thead><tr><th align="center">硬件</th><th>配置</th><th align="center">价格</th></tr></thead><tbody><tr><td align="center">CPU</td><td>Intel(R) Core(TM) i5-6600T CPU @ 2.70GHz 35w</td><td align="center">480</td></tr><tr><td align="center">主板</td><td>Dell OptiPlex 7040 准系统：Intel ®Q170</td><td align="center">400</td></tr><tr><td align="center">内存</td><td>镁光 DDR4 16GB 2666MHz</td><td align="center">310</td></tr><tr><td align="center">显卡</td><td>英特尔® 核芯显卡 530</td><td align="center">0</td></tr><tr><td align="center">机箱</td><td>Dell OptiPlex 7040 准系统</td><td align="center">0</td></tr><tr><td align="center">电源</td><td>Dell OptiPlex 7040 准系统：290W 开关电源</td><td align="center">0</td></tr><tr><td align="center">UPS</td><td>某杂牌 UPS 650VA360W</td><td align="center">160</td></tr><tr><td align="center">固态</td><td>三星 970PRO 512GB</td><td align="center">820</td></tr><tr><td align="center">总价</td><td></td><td align="center">2170</td></tr></tbody></table><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>至于 6600T 的性能，在 500 块钱的价位内 35W低功耗的 6600T 还算可以能接受，为什么不买 7200U 这种低压 U 呢？，一是低压 U 的装机成本太高，而且性价比很低，我还要在上面跑一堆虚拟机，低压 U 恐怕扛不住，所以一开始就放弃了低压 U 的装机方案。</p><p><img src="img/HomeLab-1.jpg" alt=""></p><h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><p>由于 Dell SFF 系列的机箱是定制的，和普通的主板不太一样，也只有这样才能塞进这么小的空间，对于 MFF 系列的则更小一点。对于这种小机箱而言，拥有 2个 PCI-e*4 和一个 PIC-e*16 是相当不错了，PCI-e*4可以装一个阵列卡个一个四网口的网卡，PIC-e*16又可以装一个低功耗的刀卡显卡。等到以后台式机升级的硬件的时候再把台式机上的 GT1030 亮机卡放上去。三个 SATA 一个 M.2 有点捉襟见肘，机箱空间就那么点，口子多了硬盘也塞不下呀😂。</p><table><thead><tr><th>Model:</th><th><a href="https://www.dell.com/support/manuals/us/en/04/optiplex-7040-desktop/opti7040_sff_om/specifications?guid=guid-f058d593-d332-479e-9d55-6c6031fa6cba&lang=en-us" target="_blank" rel="noopener"><em>Dell OptiPlex 7040 SFF</em></a></th></tr></thead><tbody><tr><td>Form factor:</td><td>Small Form Factor</td></tr><tr><td>CPU options:</td><td>Intel Gen6 i3/i5/i7</td></tr><tr><td>Chipset:</td><td><a href="https://ark.intel.com/content/www/us/en/ark/products/90587/intel-q170-chipset.html" target="_blank" rel="noopener">Intel Q170</a></td></tr><tr><td>RAM slots:</td><td>(4x) DIMM DDR4-2133</td></tr><tr><td>Max RAM:</td><td>64 GB</td></tr><tr><td>USB Ports:</td><td>(6x) USB3.0; (4x) USB2.0;</td></tr><tr><td>Video Ports:</td><td>(2x) Display Port 1.2; HDMI 1.4;</td></tr><tr><td>Other Ports:</td><td>Serial; (2x) PS2; RJ45; Headset; Line-Out;</td></tr><tr><td>Optional Ports:</td><td>VGA; Media Card Reader;</td></tr><tr><td>SATA:</td><td>(3x) SATA 3.0*</td></tr><tr><td>PCIe:</td><td>PCIe 3.0 x16 (low profile); PCIe 3.0 x4 (low profile);</td></tr><tr><td>M.2 slots:</td><td>M.2 2280 M-key (PCIe 3.0 x4, SATA 3.0)</td></tr><tr><td>Drive bays:</td><td>3.5-inch/(2x)2.5-inch; 5.25-inch (slim);</td></tr><tr><td>Hard Drive:</td><td>max 2TB; RAID 0 &amp; 1;</td></tr><tr><td>PSU:</td><td>180 W</td></tr><tr><td>Weight:</td><td>6.00 kg (13.22 lb)</td></tr></tbody></table><ul><li>从 <a href="https://www.hardware-corner.net/guides/difference-optiplex-3040-vs-5040-vs-7040/" target="_blank" rel="noopener">The difference between Dell OptiPlex 3040 vs. 5040 vs. 7040</a> 偷来的一张图片👇</li></ul><p><img src="img/OptiPlex_5040SFF_motherboard.jpg" alt="img"></p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>两条 8GB DDR4 内从从我台式机上拆下来的，又花了 300 块钱买了个镁光的 16GB DDR4 装了上去，迫于 我的台式机 B350M-K 的缩水板只有两个内存插槽而且支持到 32GB，暂时装一个 16GB 的吧，能以后再装一个上去。</p><h3 id="固态"><a href="#固态" class="headerlink" title="固态"></a>固态</h3><p>其实本来的预算三星 970PRO 512GB没打算买，是我在找 Dell OptiPlex 7040 时意外碰到的一个老哥，而且这块固态是德亚的，还算靠谱一些，于是剁手买了这个块固态。970PRO 系列的都是 MLC 的颗粒的固态硬盘，通 SM961 一样是属于传家宝系列😂，但是 SM961 淘宝上水太深，清零盘占据多数，所以不建议买。</p><p>正好把这块 970PRO 换到我的台式机上，把台式机上的 SN750 512GB 换到 HomeLab 机器上，给 ESXi 上的虚拟机用。在玩儿虚拟化的时候深有感触，宿主机的磁盘是机械硬盘的话，上面的虚拟机达到一定数量时，虚拟机会很卡，所以玩 ESXi 虚拟化，有块固态的体验是非常爽滴😋。</p><h2 id="装机"><a href="#装机" class="headerlink" title="装机"></a>装机</h2><p>其实装机很快，由于是买的 Dell OptiPlex 7040 准系统，所以只需要把 CPU 、内存、硬盘装上去就完事儿了。</p><p>收到准系统后发现没有带 M.2 螺丝，只能临时拿胶带粘糊上去，勉强撑了两天，后来买了个螺丝和散热片完美地解决了。</p><p><img src="img/HomeLab-5.jpg" alt=""></p><p>从以前旧笔记本淘汰下来的 2TB 5400RPM 的石头盘，已经出现坏道了，临时当个下载盘吧，在它还没彻底崩盘之前再压榨一下它吧😂。后面打算再添加一块12TB的氦气盘当仓库盘和备份数据使用，有了 UPS 和这台主机 7*24 小时开机也没啥问题了。</p><p><img src="img/HomeLab-3.jpg" alt=""></p><p>后面那台是我的台式机，也是去年这时候买的，两者比较起来 SFF 的型号确实小很多。Dell 的这种主机还有一种 MFF 型号的，那种更小一些，差不多比路由器大一些而已，不过扩展性不好，而且还需要外置电源，也就没考虑，不过现在想想有点后悔了，当初应该多加点钱买 SFF 的，不过还好也能接受，只不过体积大了些，搬家的时候不太方便。</p><p><img src="img/HomeLab-4.jpg" alt=""></p><h2 id="ESXi"><a href="#ESXi" class="headerlink" title="ESXi"></a>ESXi</h2><p>装完机器之后就开始装 ESXi ，对于虚拟化，ESXi 算是比较熟悉的了，听说 Proxmox VE 也不错🤔，等到后面硬盘到了再折腾一下 Proxmox VE。看到隔壁 <a href="https://wzyboy.im/post/1293.html" target="_blank" rel="noopener">Proxmox VE：优秀的自建虚拟化方案</a> 愈发想玩玩了。</p><blockquote><p>  贯彻「不重复造轮子」的原则，当前版本的 PVE 基于成熟稳定的 Debian 9 “Stretch” 构建。在熟悉和使用 PVE 的过程中，我越发喜欢它「不重复造轮子」的特性。相较之前用过的其他虚拟化方案，PVE 的内部构造和工作原理对我来说不再是一个黑盒，我可以清晰地观测到它在干什么——比如要迁移一台虚拟机到另一个节点，我就可以通过 <code>ps</code> 观察到它启动了一个 <code>dd</code> 进程，对接 <code>ssh</code> 管道，将磁盘数据通过网络复制到目标机器——这种仿佛透明手表一样能看到内部工作原理的感觉真是太棒了！</p></blockquote><p>从 VMware 家下载好 <code>VMware-VMvisor-Installer-7.0.0-15843807.x86_64.iso</code> 镜像，找了两个 U 盘，一个用于 ESXi 的安装盘，一个用于 ESXi 的系统盘，其中一个 U 盘还是我用读卡器+16GB内存卡拼凑而成的，目的是为了把 ESXi 装到 U 盘里方便迁移数据之类的，之后在网上找一个神 KEY 激活一下（🤫小声</p><p><img src="img/HomeLab-6.jpg" alt=""></p><h3 id="Ubuntu-20-04"><a href="#Ubuntu-20-04" class="headerlink" title="Ubuntu 20.04"></a>Ubuntu 20.04</h3><p>当作网关机使用，和我所有的 云主机打通网络，使用 WireGuard 组成一个小内网，关于 WireGuard 的使用建议阅读大佬写得博客 <a href="https://fuckcloudnative.io/posts/wireguard-docs-practice/" target="_blank" rel="noopener">WireGuard 教程：WireGuard 的搭建使用与配置详解</a> 以及 <a href="https://fuckcloudnative.io/posts/wireguard-docs-theory/" target="_blank" rel="noopener">WireGuard 教程：WireGuard 的工作原理</a>。</p><p>顺带用 <a href="https://github.com/Aniverse/ZBench" target="_blank" rel="noopener">ZBench</a> 测了一下虚拟机的磁盘性能，还算勉强说的过去，实际上 SN750 512GB 只有 2GB 左右的缓存，写满换粗之后，写入的性能会直线下降到 800MB/s，读的性能倒是可以达到 3200MB/s 以上，或许是主板的限制，没能达到理想的读写性能。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------------</span><br><span class="line">CPU model            : Intel(R) Core(TM) i5-6600T CPU @ 2.70GHz</span><br><span class="line">Number of cores      : 4</span><br><span class="line">CPU frequency        : 2712.000 MHz</span><br><span class="line">Total size of Disk   : 33.3 GB (7.7 GB Used)</span><br><span class="line">Total amount of Mem  : 3935 MB (306 MB Used)</span><br><span class="line">Total amount of Swap : 3934 MB (0 MB Used)</span><br><span class="line">System uptime        : 4 days, 19 hour 47 min</span><br><span class="line">Load average         : 0.13, 0.08, 0.03</span><br><span class="line">OS                   : Ubuntu 20.04 LTS</span><br><span class="line">Arch                 : x86_64 (64 Bit)</span><br><span class="line">Kernel               : 5.4.0-42-generic</span><br><span class="line">Virt                 : vmware</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">I/O speed(1st run)   :1.3 GB/s</span><br><span class="line">I/O speed(2nd run)   :1.3 GB/s</span><br><span class="line">I/O speed(3rd run)   :1.3 GB/s</span><br></pre></td></tr></table></figure><h3 id="PhotonOS"><a href="#PhotonOS" class="headerlink" title="PhotonOS"></a>PhotonOS</h3><p>这个是系统在我另一篇博客 <a href="https://blog.k8s.li/container-linux-os.html">Container Linux OS 从入坑到爬出来</a> 里提到过，Photon OS™ 是针对 VMware vSphere® 虚拟化平台进行内核优化的容器专用操作系统，就和 CoreOS 一样。十分适合专门用来运行容器，当作 Kubernetes 集群中的工作负载来使用。</p><ul><li>系统初始化启动之后内存仅仅使用了 45Mi</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@photon-machine [ ~ ]# free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:          2.0Gi        45Mi       1.8Gi       0.0Ki        93Mi       1.8Gi</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></table></figure><ul><li>启动 docker 进程之后的占用情况，也仅仅 109Mi</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@photon-machine [ ~ ]# free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:          2.0Gi       109Mi       1.6Gi       0.0Ki       238Mi       1.8Gi</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></table></figure><ul><li>使用 OVA 虚拟机模板启动后的虚拟机，磁盘仅仅占用了 515MB ，确实是相当轻量化，这还是包含了 docker。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@photon-machine [ ~ ]# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/root        16G  515M   15G   4% /</span><br><span class="line">devtmpfs        998M     0  998M   0% /dev</span><br><span class="line">tmpfs          1000M     0 1000M   0% /dev/shm</span><br><span class="line">tmpfs          1000M  532K  999M   1% /run</span><br><span class="line">tmpfs          1000M     0 1000M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs          1000M     0 1000M   0% /tmp</span><br><span class="line">/dev/sda2        10M  2.2M  7.9M  22% /boot/efi</span><br><span class="line">tmpfs           200M     0  200M   0% /run/user/0</span><br></pre></td></tr></table></figure><p>总之，PhotonOS 是个很轻量的 OS ，适合专门用来运行一些容器化的服务，这正好符合我的需求。别问我为什么不用 CoreOS ，CoreOS 已经凉了。</p><h3 id="Alpine-NFS"><a href="#Alpine-NFS" class="headerlink" title="Alpine NFS"></a>Alpine NFS</h3><p>把我一块磁盘直通给这个虚拟机，主要用来给 k8s 集群中的 Pod 挂载 PVC 持久化存储使用。</p><h3 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h3><p>主要是用来运行 K8s 集群，目前只有一个  master 和一个 node 玩玩儿，跑了一些自用的服务。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>当下载机使用，外加运行一些不得不使用的国产毒瘤软件😡</p><h2 id="额外硬件"><a href="#额外硬件" class="headerlink" title="额外硬件"></a>额外硬件</h2><p>捡垃圾的乐趣就在于越折腾越好玩，于是又开始打算折腾一些</p><h3 id="UPS"><a href="#UPS" class="headerlink" title="UPS"></a>UPS</h3><p>由于最近房东家里经常断电，有时一天断电八九次，每次断电我都担心着硬盘里的老婆们会不会挂掉，索性还是买了 UPS ，在马云家看了看，带给 NAS 自动断电的 UPS 普遍在 400块钱以上，而且我这个还是个假的 NAS ，UPS 上的 USB 口不一定支持我的主机。最后为了节省一下预算花儿 160 块钱买了个不支持 USB 的 UPS ，但是又不能没有这个功能，因为家里的 220V 市电断电之后，UPS 的电量只能给主机续命 10~20min 左右，UPS 的电量用完之后就嗝屁了，照阳还是断电。所以在 UPS 用尽电量还是没有来电之前，一定要想办法把主机通过 poweroff 的方式安全优雅滴关机。</p><p>首先要考虑的是怎么知道 220V 市电断电了，起初想有没有个 220V 的传感器，我去，有点难度还是算了吧。最后一想，可以通过 ping 房东家光猫的方式。我的路由器和主机等设备连接 UPS ，房东家的光猫并没有连接 UPS ，我在路由器上设置一个定时任务，每分钟去 ping 房东家的光猫，没有 ping 通说明就是断电了，也有可能是网线被拔掉了，但概率很小。<code>! ping -c 8 A &amp;&amp; ssh B &quot;poweroff&quot;</code> 一行简单的命令就满足了我的需求，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">echo "start" &gt;&gt; /tmp/power_status</span><br><span class="line">if ! ping -c 32 192.168.1.1</span><br><span class="line">then</span><br><span class="line">    sleep 300</span><br><span class="line">    ping -c 32 192.168.1.1 &amp;&amp; exit 0</span><br><span class="line">    sshpass -p "pwd" ssh root@192.168.0.210 "net rpc shutdown -I 192.168.0.240 -U admin%poweroff"</span><br><span class="line">    sshpass -p "pwd" ssh root@192.168.0.200 "sh -c /suspend_vm.sh"</span><br><span class="line">    echo "220v poweroff" &gt;&gt; /tmp/power_status</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>对于 ESXi 上的虚拟机，还是采用了挂起的方式，将虚拟机的内存状态保存在数据存储的磁盘里，这样重新开启虚拟机后就能恢复到之前的状态，这一点有点像 Windows 的休眠。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">for vm in $(/sbin/vmdumper -l | grep -v Alpine |  awk '&#123;print $1&#125;' | sed 's/wid=//g')</span><br><span class="line">do</span><br><span class="line">     /sbin/vmdumper $&#123;vm&#125; suspend_vm</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="网管交换机"><a href="#网管交换机" class="headerlink" title="网管交换机"></a>网管交换机</h3><p>当我从台式机向 ESXI 里的虚拟机传输文件的时候，发现网络速度最快只能达到 700Mbits/sec ，看来应该是路由器的性能瓶颈，于是想着升级一下网络设备，把 R6300V2 路由器当作 AP 来用，将流量都汇聚到网管交换机上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[  4] local 192.168.0.240 port 50718 connected to 192.168.0.123 port 5201</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth</span><br><span class="line">[  4]   0.00-1.00   sec  83.8 MBytes   702 Mbits/sec</span><br><span class="line">[  4]   1.00-2.00   sec  83.4 MBytes   700 Mbits/sec</span><br><span class="line">[  4]   2.00-3.00   sec  83.6 MBytes   701 Mbits/sec</span><br><span class="line">[  4]   3.00-4.00   sec  82.9 MBytes   695 Mbits/sec</span><br><span class="line">[  4]   4.00-5.00   sec  83.8 MBytes   702 Mbits/sec</span><br><span class="line">[  4]   5.00-6.00   sec  83.6 MBytes   701 Mbits/sec</span><br><span class="line">[  4]   6.00-7.00   sec  83.5 MBytes   701 Mbits/sec</span><br><span class="line">[  4]   7.00-8.00   sec  83.8 MBytes   703 Mbits/sec</span><br><span class="line">[  4]   8.00-9.00   sec  83.8 MBytes   702 Mbits/sec</span><br><span class="line">[  4]   9.00-10.00  sec  83.8 MBytes   702 Mbits/sec</span><br><span class="line">[  4]  10.00-11.00  sec  83.8 MBytes   703 Mbits/sec</span><br><span class="line">[  4]  11.00-12.00  sec  83.8 MBytes   703 Mbits/sec</span><br><span class="line">[  4]  12.00-13.00  sec  83.9 MBytes   703 Mbits/sec</span><br><span class="line">[  4]  13.00-14.00  sec  83.8 MBytes   703 Mbits/sec</span><br><span class="line">[  4]  14.00-15.00  sec  83.8 MBytes   703 Mbits/sec</span><br><span class="line">[  4]  15.00-16.00  sec  83.9 MBytes   704 Mbits/sec</span><br><span class="line">[  4]  16.00-17.00  sec  83.4 MBytes   699 Mbits/sec</span><br><span class="line">[  4]  17.00-18.00  sec  83.9 MBytes   703 Mbits/sec</span><br><span class="line">[  4]  18.00-19.00  sec  83.6 MBytes   702 Mbits/sec</span><br><span class="line">[  4]  19.00-20.00  sec  83.8 MBytes   702 Mbits/sec</span><br><span class="line">[  4]  20.00-21.00  sec  83.9 MBytes   704 Mbits/sec</span><br><span class="line">[  4]  21.00-22.00  sec  83.8 MBytes   703 Mbits/sec</span><br><span class="line">[  4]  22.00-23.00  sec  83.9 MBytes   704 Mbits/sec</span><br><span class="line">[  4]  23.00-24.00  sec  83.9 MBytes   703 Mbits/sec</span><br><span class="line">[  4]  24.00-25.00  sec  83.9 MBytes   703 Mbits/sec</span><br><span class="line">[  4]  25.00-25.20  sec  16.6 MBytes   698 Mbits/sec</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">╭─debian@debian ~</span><br><span class="line">╰─$ qperf 192.168.0.123 -t 30 -vvu tcp_lat udp_lat tcp_bw udp_bw conf</span><br><span class="line">tcp_lat:</span><br><span class="line">    latency   =  98.7 us</span><br><span class="line">    msg_size  =     1 bytes</span><br><span class="line">    time      =    30 sec</span><br><span class="line">    timeout   =     5 sec</span><br><span class="line">udp_lat:</span><br><span class="line">    latency   =  98 us</span><br><span class="line">    msg_size  =   1 bytes</span><br><span class="line">    time      =  30 sec</span><br><span class="line">    timeout   =   5 sec</span><br><span class="line">tcp_bw:</span><br><span class="line">    bw        =  87.9 MB/sec</span><br><span class="line">    msg_size  =    64 KiB (65,536)</span><br><span class="line">    time      =    30 sec</span><br><span class="line">    timeout   =     5 sec</span><br><span class="line">udp_bw:</span><br><span class="line">    send_bw   =  56.7 MB/sec</span><br><span class="line">    recv_bw   =  56.7 MB/sec</span><br><span class="line">    msg_size  =    32 KiB (32,768)</span><br><span class="line">    time      =    30 sec</span><br><span class="line">    timeout   =     5 sec</span><br><span class="line">conf:</span><br><span class="line">    loc_node   =  debian</span><br><span class="line">    loc_cpu    =  16 Cores: AMD Ryzen 7 1700 Eight-Core   3.0GHz</span><br><span class="line">    loc_os     =  Linux 4.4.0-18362</span><br><span class="line">    loc_qperf  =  0.4.11</span><br><span class="line">    rem_node   =  gateway</span><br><span class="line">    rem_cpu    =  4 Cores: Intel Core i5-6600T @ 2.70GHz</span><br><span class="line">    rem_os     =  Linux 5.4.0-42-generic</span><br><span class="line">    rem_qperf  =  0.4.11</span><br></pre></td></tr></table></figure><p>准备买 GS108E V2 或者 GS105E V2，</p><h3 id="四网口网卡"><a href="#四网口网卡" class="headerlink" title="四网口网卡"></a>四网口网卡</h3><p>为了折腾一下网卡直通、端口汇聚、overlay 网络卸载等特性，后面还要添加一块 <a href="https://www.intel.cn/content/www/cn/zh/products/docs/network-io/ethernet/10-25-40-gigabit-adapters/ethernet-i350-server-adapter-brief.html" target="_blank" rel="noopener">intel I350 T4 V2</a> ，闲鱼上的价格也不是很贵。</p><p><img src="img/20200822195450798.png" alt="image-20200822195450798"></p><h3 id="阵列卡"><a href="#阵列卡" class="headerlink" title="阵列卡"></a>阵列卡</h3><p>由于主板的 SATA 接口最大只支持到 2TB ，为了扩展一下存储，只能额外添加一块阵列卡了，由于主板的 PCIe 有限，而且这么大点的机箱最多也就能塞下 1 块 3.5 寸硬盘和 3 块 2.5 寸硬盘，所以找一块入门级的阵列卡就够了，最终花了 50 块钱捡了一块 <a href="https://lenovopress.com/tips0831-serveraid-h1110" target="_blank" rel="noopener">ServeRAID H1110 SAS/SATA Controller</a> 阵列卡，看来一下手册里的参数，大概也能暂时满足我的需求。</p><blockquote><ul><li>Four internal 6 Gbps SAS/SATA ports</li><li>One x4 mini-SAS internal connector (SFF-8087)</li><li>6 Gbps throughput per port</li><li>Based on LSI SAS2004 6 Gbps RAID on Chip (ROC) controller</li><li>x4 PCI Express 2.0 host interface</li><li>Supports RAID 0, 1, 1E, and 10</li><li>Connects to up to four SAS or SATA drives</li><li>SAS and SATA drives are supported, but the mixing of SAS and SATA in the same integrated volume is not supported</li><li>Supports simple-swap SATA and hot-swap SAS and SATA drives</li><li>Supports up to two integrated volumes</li><li>Supports up to two global hot-spare drives</li><li>Supports drive sizes greater than 2 TB for RAID 0, 1E, and 10 (not RAID 1)</li><li>Fixed stripe size of 64 KB</li><li>Compliant with Disk Data Format (DDF)</li><li>S.M.A.R.T. support</li></ul></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>懒得写了</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;捡垃圾&quot;&gt;&lt;a href=&quot;#捡垃圾&quot;
        
      
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.k8s.li/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="捡垃圾" scheme="https://blog.k8s.li/tags/%E6%8D%A1%E5%9E%83%E5%9C%BE/"/>
    
      <category term="NAS" scheme="https://blog.k8s.li/tags/NAS/"/>
    
  </entry>
  
  <entry>
    <title>docker registry GC 原理分析</title>
    <link href="https://blog.k8s.li/registry-gc.html"/>
    <id>https://blog.k8s.li/registry-gc.html</id>
    <published>2020-07-10T16:00:00.000Z</published>
    <updated>2021-02-24T13:40:34.691Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>好久没更新博客了，在家摸鱼赶紧来水一篇😂</p></blockquote><h2 id="registry-GC-原理🤔"><a href="#registry-GC-原理🤔" class="headerlink" title="registry GC 原理🤔"></a>registry GC 原理🤔</h2><p>在咱上个月写的<a href="https://blog.k8s.li/Exploring-container-image.html">《深入浅出容器镜像的一生》</a>中简单提到了容器镜像的一些知识，也简单介绍了镜像在 registry 中存储的目录结构。今天还是从文件系统层面分析一下 registry GC 的原理，比从源码来分析更直观一些。</p><h3 id="部署-registry-容器"><a href="#部署-registry-容器" class="headerlink" title="部署 registry 容器"></a>部署 registry 容器</h3><p>首先我们需要在本地部署一个 registry 容器，同时为了操作的方便还需要使用到 skopeo 这个工具来替代 docker 命令行客户端进行 copy 镜像和 delete 镜像。关于 skopeo 这个工具的安装和使用可以参考咱之前写过的<a href="https://blog.k8s.li/skopeo.html">《镜像搬运工 skopeo 》</a>。</p><h4 id="自签-SSL-证书"><a href="#自签-SSL-证书" class="headerlink" title="自签 SSL 证书"></a>自签 SSL 证书</h4><p>这一步为了方便在使用 skopeo 的时候不用加一堆额外的参数😂</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">set -e</span><br><span class="line">set -o nounset</span><br><span class="line">cat &gt;ca.conf &lt;&lt;EOF</span><br><span class="line">[ req ]</span><br><span class="line">default_bits  = 2048</span><br><span class="line">distinguished_name = req_distinguished_name</span><br><span class="line">prompt   = no</span><br><span class="line">encrypt_key  = no</span><br><span class="line">x509_extensions  = v3_ca</span><br><span class="line">[ req_distinguished_name ]</span><br><span class="line">CN         = localhost</span><br><span class="line">[ CA_default ]</span><br><span class="line">copy_extensions = copy</span><br><span class="line">[ alternate_names ]</span><br><span class="line">DNS.2=localhost</span><br><span class="line">[ v3_ca ]</span><br><span class="line">subjectAltName=@alternate_names</span><br><span class="line">subjectKeyIdentifier=hash</span><br><span class="line">authorityKeyIdentifier=keyid:always,issuer:always</span><br><span class="line">basicConstraints = critical,CA:true</span><br><span class="line">keyUsage=keyCertSign,cRLSign,digitalSignature,keyEncipherment,nonRepudiation</span><br><span class="line">EOF</span><br><span class="line">mkdir -p certs</span><br><span class="line">openssl req -days 365 -x509 -config ca.conf \</span><br><span class="line">    -new -keyout certs/domain.key -out certs/domain.crt</span><br></pre></td></tr></table></figure><ul><li>信任证书，根据不同的发行版选择相应的路径和命令行即可。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CentOS</span></span><br><span class="line">update-ca-trust force-enable</span><br><span class="line">cp certs/domain.crt /etc/pki/ca-trust/source/anchors/localhost.crt</span><br><span class="line">update-ca-trust</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line">cp certs/domain.crt /usr/local/share/ca-certificates/localhost.crt</span><br><span class="line"><span class="meta">$</span><span class="bash"> update-ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Debian</span></span><br><span class="line">cp certs/domain.crt /usr/share/ca-certificates/localhost.crt</span><br><span class="line">echo localhost.crt &gt;&gt; /etc/ca-certificates.conf</span><br><span class="line">update-ca-certificates</span><br></pre></td></tr></table></figure><h4 id="创建密码-auth-认证-auth-htpasswd-文件"><a href="#创建密码-auth-认证-auth-htpasswd-文件" class="headerlink" title="创建密码 auth 认证  auth.htpasswd 文件"></a>创建密码 auth 认证  auth.htpasswd 文件</h4><p>由于 PUSH 镜像和 DELETE 镜像是通过 HTTP 请求 registry 的 API 完成的，每个请求都需要一个 token 才能完成操作，这个 token 需要使用这个 AUTH 文件来进行鉴权，使用 <code>htpasswd</code> 来生成一个明文的用户/密码即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htpasswd -cB -b auth.htpasswd root 123456</span><br></pre></td></tr></table></figure><h4 id="启动-registry-容器，docker-run-走起！"><a href="#启动-registry-容器，docker-run-走起！" class="headerlink" title="启动 registry 容器，docker run 走起！"></a>启动 registry 容器，docker run 走起！</h4><ul><li><code>-v /var/lib/registry:/var/lib/registry</code> ，将本地的存储目录挂载到容器内的 registry 存储目录下。</li><li><code>-v pwd/certs:/certs</code>，将生成的 SSL 证书挂载到容器内。</li><li><code>-e REGISTRY_STORAGE_DELETE_ENABLED=true</code>，添加该参数才能进行 DELETE 镜像操作，不然的话会提示 <a href="https://github.com/docker/distribution/issues/1573" target="_blank" rel="noopener">Error in deleting repository in a private registry V2 #1573</a> 这种错误（＞﹏＜）。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:443:5000 --name registry \</span><br><span class="line">    -v /var/lib/registry:/var/lib/registry \</span><br><span class="line">    -v `pwd`/certs:/certs \</span><br><span class="line">    -v $(pwd)/auth.htpasswd:/etc/docker/registry/auth.htpasswd \</span><br><span class="line">    -e REGISTRY_AUTH="&#123;htpasswd: &#123;realm: localhost, path: /etc/docker/registry/auth.htpasswd&#125;&#125;" \</span><br><span class="line">    -e REGISTRY_HTTP_ADDR=0.0.0.0:5000 \</span><br><span class="line">    -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \</span><br><span class="line">    -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \</span><br><span class="line">    -e REGISTRY_STORAGE_DELETE_ENABLED=true \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure><h4 id="docker-login"><a href="#docker-login" class="headerlink" title="docker login"></a>docker login</h4><p>这一步是为了在 <code>~/.docker/.config.json</code> ，中添加上 auth 认证，后面使用 skopeo 的时候会用到。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 ~/registry</span><br><span class="line">╰─# docker login localhost -u root -p 123456</span><br><span class="line">]WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line">╭─root@sg-02 ~/registry</span><br><span class="line">╰─# cat ~/.docker/config.json</span><br><span class="line">&#123;</span><br><span class="line">        "auths": &#123;</span><br><span class="line">                "https://registry.k8s.li/v2": &#123;</span><br><span class="line">                        "auth": "VlJFpmQE43Sw=="</span><br><span class="line">                &#125;,</span><br><span class="line">                "localhost": &#123;</span><br><span class="line">                        "auth": "cm9vdDoxMjM0NTY="</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        "HttpHeaders": &#123;</span><br><span class="line">                "User-Agent": "Docker-Client/19.03.5 (linux)"</span><br><span class="line">        &#125;,</span><br><span class="line">        "experimental": "enabled"</span><br><span class="line">&#125;#</span><br></pre></td></tr></table></figure><h3 id="COPY-镜像到-registry"><a href="#COPY-镜像到-registry" class="headerlink" title="COPY 镜像到 registry"></a>COPY 镜像到 registry</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 ~/registry</span><br><span class="line">╰─# skopeo copy docker://alpine:3.10 docker://localhost/library/alpine:3.10</span><br><span class="line">Getting image source signatures</span><br><span class="line">Copying blob 21c83c524219 done</span><br><span class="line">Copying config be4e4bea2c done</span><br><span class="line">Writing manifest to image destination</span><br><span class="line">Storing signatures</span><br></pre></td></tr></table></figure><h3 id="registry-存储目录长什么样🤔"><a href="#registry-存储目录长什么样🤔" class="headerlink" title="registry 存储目录长什么样🤔"></a>registry 存储目录长什么样🤔</h3><p><img src="img/registry-storage.jpeg" alt="img"></p><p>registry 容器内的<code>/var/lib/registry/docker/registry/v2</code> 存储目录，结合上面这张图，通过 tree 目录我们可以清晰地看到：registry 存储目录下只有两种文件名的文件，一个是 <code>data</code> 文件，一个是 <code>link</code> 文件。其中 link 文件是普通的文本文件，存放在 <code>repositories</code> 目录下，其内容是指向 data 文件的 sha256 digest 值。link 文件是不是有点像 C 语言中的指针😂（大雾。</p><p>data 文件存放在 <code>blobs</code> 目录下文件又分为了三种文件，一个是镜像每一层的 <code>layer</code> 文件和镜像的 <code>config</code> 文件，以及镜像的 <code>manifest</code> 文件。</p><p>在 <code>repositories</code> 目录下每个镜像的 <code>_layers/sha256</code> 目录下的文件夹名是镜像的 layer 和 config 文件的 digest ，该目录下的 link 文件就是指向对应 blobs 目录下的 data 文件。当我们 pull 一个镜像的 layer 时，是通过 link 文件找到 layer 在 registry 中实际的存储位置的。</p><p>在 <code>_manifests</code> 文件夹下的 tags 和 revisions 目录下的 link 文件则指向该镜像的 manifest 文件，保存在所有历史镜像 tag 的 manifest 文件 的 link。当删除一个镜像时，只会删除该镜像最新的 tag 的 link 文件。</p><p>tags 目录下的文件夹名例如 3.10 ，就是该镜像的 tag ，在它的子目录下的 current/link 文件则记录了当前 tag 指向的 manifest 文件的位置。比如我们的 alpine:latest 镜像，每次 push 新的 latest 镜像时，current/link 都会更新成指向最新镜像的 manifest 文件。</p><p>我们后面观察一下当删除一个镜像时，这些文件是怎么变化的，就可以得知通过 registry API 进行 DELETE 操作可以转换成文件系统层面上对 link 文件的删除操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 ~/registry</span><br><span class="line">╰─# cd /var/lib/registry/docker/registry/v2</span><br><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2</span><br><span class="line">╰─# tree</span><br><span class="line">.</span><br><span class="line">├── blobs</span><br><span class="line">│   └── sha256</span><br><span class="line">│       ├── 21</span><br><span class="line">│       │   └── 21c83c5242199776c232920ddb58cfa2a46b17e42ed831ca9001c8dbc532d22d</span><br><span class="line">│       │       └── data</span><br><span class="line">│       ├── a1</span><br><span class="line">│       │   └── a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590</span><br><span class="line">│       │       └── data</span><br><span class="line">│       └── be</span><br><span class="line">│           └── be4e4bea2c2e15b403bb321562e78ea84b501fb41497472e91ecb41504e8a27c</span><br><span class="line">│               └── data</span><br><span class="line">└── repositories</span><br><span class="line">    └── library</span><br><span class="line">        └── alpine</span><br><span class="line">            ├── _layers</span><br><span class="line">            │   └── sha256</span><br><span class="line">            │       ├── 21c83c5242199776c232920ddb58cfa2a46b17e42ed831ca9001c8dbc532d22d</span><br><span class="line">            │       │   └── link</span><br><span class="line">            │       └── be4e4bea2c2e15b403bb321562e78ea84b501fb41497472e91ecb41504e8a27c</span><br><span class="line">            │           └── link</span><br><span class="line">            ├── _manifests</span><br><span class="line">            │   ├── revisions</span><br><span class="line">            │   │   └── sha256</span><br><span class="line">            │   │       └── a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590</span><br><span class="line">            │   │           └── link</span><br><span class="line">            │   └── tags</span><br><span class="line">            │       └── 3.10</span><br><span class="line">            │           ├── current</span><br><span class="line">            │           │   └── link</span><br><span class="line">            │           └── index</span><br><span class="line">            │               └── sha256</span><br><span class="line">            │                   └── a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590</span><br><span class="line">            │                       └── link</span><br><span class="line">            └── _uploads</span><br><span class="line"></span><br><span class="line">26 directories, 8 files</span><br></pre></td></tr></table></figure><ul><li><code>blobs</code> 存储目录，存放了镜像的三个必须文件，<code>layer</code>，<code>manifest</code>，<code>config</code>。通过文件大小我们可以大致地推算出最大的 2.7M 是镜像的 layer 。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2</span><br><span class="line">╰─# find . -name "data" -exec ls -sh &#123;&#125; \;</span><br><span class="line">2.7M ./blobs/sha256/21/21c83c5242199776c232920ddb58cfa2a46b17e42ed831ca9001c8dbc532d22d/data</span><br><span class="line">4.0K ./blobs/sha256/a1/a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590/data</span><br><span class="line">4.0K ./blobs/sha256/be/be4e4bea2c2e15b403bb321562e78ea84b501fb41497472e91ecb41504e8a27c/data</span><br></pre></td></tr></table></figure><ul><li><code>image layer</code> 文件，是 gzip 格式的 tar 包，是镜像层真实内容的 <code>tar.gzip</code> 格式存储形式。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./blobs/sha256/21/21c83c5242199776c232920ddb58cfa2a46b17e42ed831ca9001c8dbc532d22d/data: gzip compressed data</span><br></pre></td></tr></table></figure><ul><li><code>image manifest</code> 文件，json 文件格式的，存放该镜像 <code>layer</code> 和  <code>image config</code> 文件的索引。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2</span><br><span class="line">╰─# cat ./blobs/sha256/a1/a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590/data</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"schemaVersion"</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.distribution.manifest.v2+json"</span>,</span><br><span class="line">   <span class="attr">"config"</span>: &#123;</span><br><span class="line">      <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.container.image.v1+json"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">1509</span>,</span><br><span class="line">      <span class="attr">"digest"</span>: <span class="string">"sha256:be4e4bea2c2e15b403bb321562e78ea84b501fb41497472e91ecb41504e8a27c"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"layers"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.image.rootfs.diff.tar.gzip"</span>,</span><br><span class="line">         <span class="attr">"size"</span>: <span class="number">2795580</span>,</span><br><span class="line">         <span class="attr">"digest"</span>: <span class="string">"sha256:21c83c5242199776c232920ddb58cfa2a46b17e42ed831ca9001c8dbc532d22d"</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;#</span><br></pre></td></tr></table></figure><ul><li><code>image config</code> 文件，json 格式的。是构建时生成的，根据 <code>Dockerfile</code> 和宿主机的一些信息，以及一些构建过程中的容器可以生成 digest 唯一的 <code>image config</code> 文件。仔细看这个 image config 文件是不是有点疑惑，无论是 manifest 还是 config 文件里面的内容压根就没有镜像的名称和 tag 。其实，镜像就好比一个文件，文件的内容和文件名毫无关系。在 registry 中，是通过路径名的方式来对一个镜像进行命名的。当我们往 registry 中 PUSH 一个镜像时，以<code>localhost/library/alpine:3.10</code>为例，<code>localhost</code>，就是该 registry 的域名或者 URL ，<code>library</code>就是 project ，<code>alpine:3.10</code>就是镜像名和镜像的 tag。registry 会根据 <code>localhost/library/alpine:3.10</code> 在<code>repositories</code> 目录下依次创建相应的目录。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2</span><br><span class="line">╰─# cat ./blobs/sha256/be/be4e4bea2c2e15b403bb321562e78ea84b501fb41497472e91ecb41504e8a27c/data | jq "."</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"architecture"</span>: <span class="string">"amd64"</span>,</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">    <span class="attr">"Hostname"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"Domainname"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"User"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"AttachStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"AttachStdout"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"AttachStderr"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"Tty"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"OpenStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"StdinOnce"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"Env"</span>: [</span><br><span class="line">      <span class="string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"Cmd"</span>: [</span><br><span class="line">      <span class="string">"/bin/sh"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"ArgsEscaped"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"Image"</span>: <span class="string">"sha256:d928e20e1fbe5142bb5cdf594862271673133c5354950d6a8f74afed24df4c23"</span>,</span><br><span class="line">    <span class="attr">"Volumes"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"WorkingDir"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"Entrypoint"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"OnBuild"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"Labels"</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"container"</span>: <span class="string">"37e3972c75360676982c8f6591b66a9097719e5ad4cecd5fa63ad4f06472825f"</span>,</span><br><span class="line">  <span class="attr">"container_config"</span>: &#123;</span><br><span class="line">    <span class="attr">"Hostname"</span>: <span class="string">"37e3972c7536"</span>,</span><br><span class="line">    <span class="attr">"Domainname"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"User"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"AttachStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"AttachStdout"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"AttachStderr"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"Tty"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"OpenStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"StdinOnce"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"Env"</span>: [</span><br><span class="line">      <span class="string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"Cmd"</span>: [</span><br><span class="line">      <span class="string">"/bin/sh"</span>,</span><br><span class="line">      <span class="string">"-c"</span>,</span><br><span class="line">      <span class="string">"#(nop) "</span>,</span><br><span class="line">      <span class="string">"CMD [\"/bin/sh\"]"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"ArgsEscaped"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"Image"</span>: <span class="string">"sha256:d928e20e1fbe5142bb5cdf594862271673133c5354950d6a8f74afed24df4c23"</span>,</span><br><span class="line">    <span class="attr">"Volumes"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"WorkingDir"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"Entrypoint"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"OnBuild"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"Labels"</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"created"</span>: <span class="string">"2020-04-24T01:05:21.571691552Z"</span>,</span><br><span class="line">  <span class="attr">"docker_version"</span>: <span class="string">"18.09.7"</span>,</span><br><span class="line">  <span class="attr">"history"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"created"</span>: <span class="string">"2020-04-24T01:05:21.178437685Z"</span>,</span><br><span class="line">      <span class="attr">"created_by"</span>: <span class="string">"/bin/sh -c #(nop) ADD file:66a440394c2442570f1f060e25c86613cb2d88a8af0c71c5a4154b3570e9a805 in / "</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"created"</span>: <span class="string">"2020-04-24T01:05:21.571691552Z"</span>,</span><br><span class="line">      <span class="attr">"created_by"</span>: <span class="string">"/bin/sh -c #(nop)  CMD [\"/bin/sh\"]"</span>,</span><br><span class="line">      <span class="attr">"empty_layer"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"os"</span>: <span class="string">"linux"</span>,</span><br><span class="line">  <span class="attr">"rootfs"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"layers"</span>,</span><br><span class="line">    <span class="attr">"diff_ids"</span>: [</span><br><span class="line">      <span class="string">"sha256:1b3ee35aacca9866b01dd96e870136266bde18006ac2f0d6eb706c798d1fa3c3"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们再往 registry 中 COPY 一个镜像，方便后面的分析过程。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skopeo copy docker://debian:buster-slim docker://localhost/library/debian:buster-slim</span><br></pre></td></tr></table></figure><ul><li>这是 registry 中就只有 <code>alpine:3.10</code> 和 <code>debian:buster-slim</code>这两个基础镜像，此时的 registry 存储目录的结构如下：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2</span><br><span class="line">╰─# tree</span><br><span class="line">.</span><br><span class="line">├── blobs</span><br><span class="line">│   └── sha256</span><br><span class="line">│       ├── 21</span><br><span class="line">│       │   └── 21c83c5242199776c232920ddb58cfa2a46b17e42ed831ca9001c8dbc532d22d</span><br><span class="line">│       │       └── data</span><br><span class="line">│       ├── 43</span><br><span class="line">│       │   └── 43e3995ee54ac008271bfcf2d8ac7278c33f4c5e83d2f02bfcddd350034e3357</span><br><span class="line">│       │       └── data</span><br><span class="line">│       ├── 7c</span><br><span class="line">│       │   └── 7c459309b9a5ec1683ef3b137f39ce5888f5ad0384e488ad73c94e0243bc77d4</span><br><span class="line">│       │       └── data</span><br><span class="line">│       ├── 85</span><br><span class="line">│       │   └── 8559a31e96f442f2c7b6da49d6c84705f98a39d8be10b3f5f14821d0ee8417df</span><br><span class="line">│       │       └── data</span><br><span class="line">│       ├── a1</span><br><span class="line">│       │   └── a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590</span><br><span class="line">│       │       └── data</span><br><span class="line">│       └── be</span><br><span class="line">│           └── be4e4bea2c2e15b403bb321562e78ea84b501fb41497472e91ecb41504e8a27c</span><br><span class="line">│               └── data</span><br><span class="line">└── repositories</span><br><span class="line">    └── library</span><br><span class="line">        ├── alpine</span><br><span class="line">        │   ├── _layers</span><br><span class="line">        │   │   └── sha256</span><br><span class="line">        │   │       ├── 21c83c5242199776c232920ddb58cfa2a46b17e42ed831ca9001c8dbc532d22d</span><br><span class="line">        │   │       │   └── link</span><br><span class="line">        │   │       └── be4e4bea2c2e15b403bb321562e78ea84b501fb41497472e91ecb41504e8a27c</span><br><span class="line">        │   │           └── link</span><br><span class="line">        │   ├── _manifests</span><br><span class="line">        │   │   ├── revisions</span><br><span class="line">        │   │   │   └── sha256</span><br><span class="line">        │   │   │       └── a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590</span><br><span class="line">        │   │   │           └── link</span><br><span class="line">        │   │   └── tags</span><br><span class="line">        │   │       └── 3.10</span><br><span class="line">        │   │           ├── current</span><br><span class="line">        │   │           │   └── link</span><br><span class="line">        │   │           └── index</span><br><span class="line">        │   │               └── sha256</span><br><span class="line">        │   │                   └── a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590</span><br><span class="line">        │   │                       └── link</span><br><span class="line">        │   └── _uploads</span><br><span class="line">        └── debian</span><br><span class="line">            ├── _layers</span><br><span class="line">            │   └── sha256</span><br><span class="line">            │       ├── 43e3995ee54ac008271bfcf2d8ac7278c33f4c5e83d2f02bfcddd350034e3357</span><br><span class="line">            │       │   └── link</span><br><span class="line">            │       └── 8559a31e96f442f2c7b6da49d6c84705f98a39d8be10b3f5f14821d0ee8417df</span><br><span class="line">            │           └── link</span><br><span class="line">            ├── _manifests</span><br><span class="line">            │   ├── revisions</span><br><span class="line">            │   │   └── sha256</span><br><span class="line">            │   │       └── 7c459309b9a5ec1683ef3b137f39ce5888f5ad0384e488ad73c94e0243bc77d4</span><br><span class="line">            │   │           └── link</span><br><span class="line">            │   └── tags</span><br><span class="line">            │       └── buster-slim</span><br><span class="line">            │           ├── current</span><br><span class="line">            │           │   └── link</span><br><span class="line">            │           └── index</span><br><span class="line">            │               └── sha256</span><br><span class="line">            │                   └── 7c459309b9a5ec1683ef3b137f39ce5888f5ad0384e488ad73c94e0243bc77d4</span><br><span class="line">            │                       └── link</span><br><span class="line">            └── _uploads</span><br><span class="line"></span><br><span class="line">48 directories, 16 files</span><br></pre></td></tr></table></figure><h3 id="DELETE-镜像"><a href="#DELETE-镜像" class="headerlink" title="DELETE 镜像"></a>DELETE 镜像</h3><ul><li>通过 <code>skopeo delete</code> 删除镜像，注意，通过 registry 的 API 删除镜像每次只能删除一个 tag 的镜像。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2</span><br><span class="line">╰─# skopeo delete docker://localhost/library/alpine:3.10 --debug</span><br><span class="line">DEBU[0000] Returning credentials from /run/containers/0/auth.json</span><br><span class="line">DEBU[0000] Using registries.d directory /etc/containers/registries.d for sigstore configuration</span><br><span class="line">DEBU[0000]  No signature storage configuration found for localhost/library/alpine:3.10</span><br><span class="line">DEBU[0000] Looking for TLS certificates and private keys in /etc/docker/certs.d/localhost</span><br><span class="line">DEBU[0000] Loading registries configuration "/etc/containers/registries.conf"</span><br><span class="line">DEBU[0000] GET https://localhost/v2/</span><br><span class="line">DEBU[0000] Ping https://localhost/v2/ status 401</span><br><span class="line">DEBU[0000] GET https://localhost/v2/library/alpine/manifests/3.10</span><br><span class="line">DEBU[0000] DELETE https://localhost/v2/library/alpine/manifests/sha256:a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590</span><br></pre></td></tr></table></figure><ul><li>再看一下删除后的 registry 存储目录下的 alpine 目录里都少了哪些东东？</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2</span><br><span class="line">╰─# tree</span><br><span class="line">.</span><br><span class="line">├── blobs</span><br><span class="line">│   └── sha256</span><br><span class="line">│       ├── 21</span><br><span class="line">│       │   └── 21c83c5242199776c232920ddb58cfa2a46b17e42ed831ca9001c8dbc532d22d</span><br><span class="line">│       │       └── data</span><br><span class="line">│       ├── 43</span><br><span class="line">│       │   └── 43e3995ee54ac008271bfcf2d8ac7278c33f4c5e83d2f02bfcddd350034e3357</span><br><span class="line">│       │       └── data</span><br><span class="line">│       ├── 7c</span><br><span class="line">│       │   └── 7c459309b9a5ec1683ef3b137f39ce5888f5ad0384e488ad73c94e0243bc77d4</span><br><span class="line">│       │       └── data</span><br><span class="line">│       ├── 85</span><br><span class="line">│       │   └── 8559a31e96f442f2c7b6da49d6c84705f98a39d8be10b3f5f14821d0ee8417df</span><br><span class="line">│       │       └── data</span><br><span class="line">│       ├── a1</span><br><span class="line">│       │   └── a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590</span><br><span class="line">│       │       └── data</span><br><span class="line">│       └── be</span><br><span class="line">│           └── be4e4bea2c2e15b403bb321562e78ea84b501fb41497472e91ecb41504e8a27c</span><br><span class="line">│               └── data</span><br><span class="line">└── repositories</span><br><span class="line">    └── library</span><br><span class="line">        ├── alpine</span><br><span class="line">        │   ├── _layers</span><br><span class="line">        │   │   └── sha256</span><br><span class="line">        │   │       ├── 21c83c5242199776c232920ddb58cfa2a46b17e42ed831ca9001c8dbc532d22d</span><br><span class="line">        │   │       │   └── link</span><br><span class="line">        │   │       └── be4e4bea2c2e15b403bb321562e78ea84b501fb41497472e91ecb41504e8a27c</span><br><span class="line">        │   │           └── link</span><br><span class="line">        │   ├── _manifests</span><br><span class="line">        │   │   ├── revisions</span><br><span class="line">        │   │   │   └── sha256</span><br><span class="line">        │   │   │       └── a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590</span><br><span class="line">        │   │   └── tags</span><br><span class="line">        │   └── _uploads</span><br></pre></td></tr></table></figure><p>我们可以看到，通过 skopeo delete 一个镜像的时候，只对 <code>_manifests</code> 下的 link 文件进行了操作，删除的都是对该 tag 镜像 manifest 文件夹下的 link 文件，实际上 manifest 文件并没有从 blobs 目录下删除，只是删除了该镜像的 manifest 文件的引用。删除一个镜像后，tags 目录下的 tag 名目录就被删除了，_manifests/revisions 目录下的 link 文件也被删除了。实际上两者删除的是同一个内容，即对该镜像 manifest 文件的 link 文件。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBU[0000] DELETE https://localhost/v2/library/alpine/manifests/sha256:a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590</span><br></pre></td></tr></table></figure><p>从上面文件的变化可以得出，通过 registry API 来 DELETE 一个镜像实质上是删除 repositories 元数据文件夹下的 tag 名文件夹和该 tag 的 revisions 下的 link 文件。</p><h2 id="registry-GC-原理"><a href="#registry-GC-原理" class="headerlink" title="registry GC 原理"></a>registry GC 原理</h2><p>上面巴拉巴拉扯了一通也许你现在一头雾水，这和今天的主题 registry GC 原理毛关系？😂，其实想要从文件系统层面来理解 registry GC ，上面的知识是必备的（<em>^____^</em>）。</p><h3 id="GC-是弄啥咧？🤔"><a href="#GC-是弄啥咧？🤔" class="headerlink" title="GC 是弄啥咧？🤔"></a>GC 是弄啥咧？🤔</h3><p>GC 嘛，就是垃圾回收的意思，从 docker 官方文档 <a href="https://docs.docker.com/registry/garbage-collection/" target="_blank" rel="noopener">Garbage collection</a> 偷来的 example 😂来解释一下吧。</p><ul><li>假如镜像 A 和镜像 B ，他俩分别引用了layer a，b和 a，c。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A -----&gt; a &lt;----- B</span><br><span class="line">    \--&gt; b     |</span><br><span class="line">         c &lt;--&#x2F;</span><br></pre></td></tr></table></figure><ul><li>通过 registry API 删除镜像 B 之后，layer c 并没有删掉，只是删掉了对它的引用，所以 c 是多余的。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A -----&gt; a     B</span><br><span class="line">    \--&gt; b</span><br><span class="line">         c</span><br></pre></td></tr></table></figure><ul><li>GC 之后，layer c 就被删掉了，现在就没有无用的 layer 了。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A -----&gt; a</span><br><span class="line">    \--&gt; b</span><br></pre></td></tr></table></figure><h3 id="GC-的过程"><a href="#GC-的过程" class="headerlink" title="GC 的过程"></a>GC 的过程</h3><p>翻一下 registry  GC 的源码 <a href="https://github.com/docker/distribution/blob/master/registry/storage/garbagecollect.go" target="_blank" rel="noopener">garbagecollect.go</a>，可以看到 GC 的主要分两个阶段，marking 和 sweep。</p><h4 id="marking"><a href="#marking" class="headerlink" title="marking"></a>marking</h4><p>marking 阶段是扫描所有的 manifest 文件，根据上文我们提到的 link 文件，通过扫描所有镜像 tags 目录下的 link 文件就可以得到这些镜像的 manifest，在 manifest 中保存在该镜像所有的 layer 和 config 文件的 digest 值，把这些值标记为<strong>不能清除</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mark</span></span><br><span class="line">markSet := <span class="built_in">make</span>(<span class="keyword">map</span>[digest.Digest]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">manifestArr := <span class="built_in">make</span>([]ManifestDel, <span class="number">0</span>)</span><br><span class="line">err := repositoryEnumerator.Enumerate(ctx, <span class="function"><span class="keyword">func</span><span class="params">(repoName <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">emit(repoName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">named, err := reference.WithName(repoName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to parse repo name %s: %v"</span>, repoName, err)</span><br><span class="line">&#125;</span><br><span class="line">repository, err := registry.Repository(ctx, named)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to construct repository: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">manifestService, err := repository.Manifests(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to construct manifest service: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">manifestEnumerator, ok := manifestService.(distribution.ManifestEnumerator)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"unable to convert ManifestService into ManifestEnumerator"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一阶段用 shell 脚本来实现的话大致可以这样来搞，使用 shell 去遍历这些 manifest ，然后再 grep 出所有的 sha256 值就能得到这个镜像所有的 blobs 目录下的 data 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -x</span><br><span class="line">v2=$&#123;v2:="/var/lib/registry/docker/registry/v2"&#125;</span><br><span class="line">cd $&#123;v2&#125;</span><br><span class="line">all_blobs=/tmp/all_blobs.list</span><br><span class="line">echo "" &gt; $&#123;all_blobs&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> marking all the blob by all images manifest</span></span><br><span class="line">for tag in $(find repositories -name "link" | grep current)</span><br><span class="line">do</span><br><span class="line">    link=$(cat $&#123;tag&#125; | cut -c8-71)</span><br><span class="line">    mfs=blobs/sha256/$&#123;link:0:2&#125;/$&#123;link&#125;/data</span><br><span class="line">    echo $&#123;link&#125; &gt;&gt; $&#123;all_blobs&#125;</span><br><span class="line">    grep sha256 $&#123;mfs&#125; |cut -d "\"" -f4 | cut -c8-71 &gt;&gt; $&#123;all_blobs&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="sweep"><a href="#sweep" class="headerlink" title="sweep"></a>sweep</h4><p>第二阶段就是删除操作啦，marking 完之后，没有标记 blob（ layer 和 config 文件）就会被清除掉。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sweep</span></span><br><span class="line">vacuum := NewVacuum(ctx, storageDriver)</span><br><span class="line"><span class="keyword">if</span> !opts.DryRun &#123;</span><br><span class="line"><span class="keyword">for</span> _, obj := <span class="keyword">range</span> manifestArr &#123;</span><br><span class="line">err = vacuum.RemoveManifest(obj.Name, obj.Digest, obj.Tags)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to delete manifest %s: %v"</span>, obj.Digest, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">blobService := registry.Blobs()</span><br><span class="line">deleteSet := <span class="built_in">make</span>(<span class="keyword">map</span>[digest.Digest]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">err = blobService.Enumerate(ctx, <span class="function"><span class="keyword">func</span><span class="params">(dgst digest.Digest)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// check if digest is in markSet. If not, delete it!</span></span><br><span class="line"><span class="keyword">if</span> _, ok := markSet[dgst]; !ok &#123;</span><br><span class="line">deleteSet[dgst] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="img/registry-gc.png" alt=""></p><h3 id="GC-都干了啥？"><a href="#GC-都干了啥？" class="headerlink" title="GC 都干了啥？"></a>GC 都干了啥？</h3><p>接下来我们就进行实际的 GC 操作，进入到 registry 容器中，使用 registry garbage-collect 这个子命令进行操作。</p><h4 id="marking-1"><a href="#marking-1" class="headerlink" title="marking"></a>marking</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-<span class="number">02</span> /<span class="keyword">var</span>/lib/registry/docker/registry/v2</span><br><span class="line">╰─# docker exec -it registry sh</span><br><span class="line">/ # registry garbage-collect -m --delete-untagged=true /etc/docker/registry/<span class="keyword">config</span><span class="variable">.yml</span></span><br><span class="line"><span class="keyword">library</span>/alpine</span><br><span class="line"><span class="keyword">library</span>/debian</span><br><span class="line"><span class="keyword">library</span>/debian: marking manifest sha256:<span class="number">7</span>c459309b9a5ec1683ef3b137f39ce5888f5ad0384e488ad73c94e0243bc77d4</span><br><span class="line"><span class="keyword">library</span>/debian: marking blob sha256:<span class="number">43</span>e3995ee54ac008271bfcf2d8ac7278c33f4c5e83d2f02bfcddd350034e3357</span><br><span class="line"><span class="keyword">library</span>/debian: marking blob sha256:<span class="number">8559</span>a31e96f442f2c7b6da49d6c84705f98a39d8be10b3f5f14821d0ee8417df</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> blobs marked, <span class="number">3</span> blobs <span class="keyword">and</span> <span class="number">0</span> manifests eligible <span class="keyword">for</span> deletion</span><br></pre></td></tr></table></figure><h4 id="sweep-1"><a href="#sweep-1" class="headerlink" title="sweep"></a>sweep</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">blob eligible for deletion: sha256:a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590</span><br><span class="line">INFO[0000] Deleting blob: &#x2F;docker&#x2F;registry&#x2F;v2&#x2F;blobs&#x2F;sha256&#x2F;a1&#x2F;a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590  go.version&#x3D;go1.11.2 instance.id&#x3D;3ad15352-7cb7-46ca-a5ae-e5e16c6485a5 service&#x3D;registry</span><br><span class="line">blob eligible for deletion: sha256:be4e4bea2c2e15b403bb321562e78ea84b501fb41497472e91ecb41504e8a27c</span><br><span class="line">INFO[0000] Deleting blob: &#x2F;docker&#x2F;registry&#x2F;v2&#x2F;blobs&#x2F;sha256&#x2F;be&#x2F;be4e4bea2c2e15b403bb321562e78ea84b501fb41497472e91ecb41504e8a27c  go.version&#x3D;go1.11.2 instance.id&#x3D;3ad15352-7cb7-46ca-a5ae-e5e16c6485a5 service&#x3D;registry</span><br><span class="line">blob eligible for deletion: sha256:21c83c5242199776c232920ddb58cfa2a46b17e42ed831ca9001c8dbc532d22d</span><br><span class="line">INFO[0000] Deleting blob: &#x2F;docker&#x2F;registry&#x2F;v2&#x2F;blobs&#x2F;sha256&#x2F;21&#x2F;21c83c5242199776c232920ddb58cfa2a46b17e42ed831ca9001c8dbc532d22d  go.version&#x3D;go1.11.2 instance.id&#x3D;3ad15352-7cb7-46ca-a5ae-e5e16c6485a5 service&#x3D;registry</span><br></pre></td></tr></table></figure><h4 id="GC-之后的-registry-存储目录长什么样？"><a href="#GC-之后的-registry-存储目录长什么样？" class="headerlink" title="GC 之后的 registry 存储目录长什么样？"></a>GC 之后的 registry 存储目录长什么样？</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2</span><br><span class="line">╰─# tree                                                                                     </span><br><span class="line">.</span><br><span class="line">├── blobs</span><br><span class="line">│   └── sha256</span><br><span class="line">│       ├── 21</span><br><span class="line">│       ├── 43</span><br><span class="line">│       │   └── 43e3995ee54ac008271bfcf2d8ac7278c33f4c5e83d2f02bfcddd350034e3357</span><br><span class="line">│       │       └── data</span><br><span class="line">│       ├── 7c</span><br><span class="line">│       │   └── 7c459309b9a5ec1683ef3b137f39ce5888f5ad0384e488ad73c94e0243bc77d4</span><br><span class="line">│       │       └── data</span><br><span class="line">│       ├── 85</span><br><span class="line">│       │   └── 8559a31e96f442f2c7b6da49d6c84705f98a39d8be10b3f5f14821d0ee8417df</span><br><span class="line">│       │       └── data</span><br><span class="line">│       ├── a1</span><br><span class="line">│       └── be</span><br><span class="line">└── repositories</span><br><span class="line">    └── library</span><br><span class="line">        ├── alpine</span><br><span class="line">        │   ├── _layers</span><br><span class="line">        │   │   └── sha256</span><br><span class="line">        │   │       ├── 21c83c5242199776c232920ddb58cfa2a46b17e42ed831ca9001c8dbc532d22d</span><br><span class="line">        │   │       │   └── link</span><br><span class="line">        │   │       └── be4e4bea2c2e15b403bb321562e78ea84b501fb41497472e91ecb41504e8a27c</span><br><span class="line">        │   │           └── link</span><br><span class="line">        │   ├── _manifests</span><br><span class="line">        │   │   ├── revisions</span><br><span class="line">        │   │   │   └── sha256</span><br><span class="line">        │   │   │       └── a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590</span><br><span class="line">        │   │   └── tags</span><br><span class="line">        │   └── _uploads</span><br><span class="line">        └── debian</span><br><span class="line">            ├── _layers</span><br><span class="line">            │   └── sha256</span><br><span class="line">            │       ├── 43e3995ee54ac008271bfcf2d8ac7278c33f4c5e83d2f02bfcddd350034e3357</span><br><span class="line">            │       │   └── link</span><br><span class="line">            │       └── 8559a31e96f442f2c7b6da49d6c84705f98a39d8be10b3f5f14821d0ee8417df</span><br><span class="line">            │           └── link</span><br><span class="line">            ├── _manifests</span><br><span class="line">            │   ├── revisions</span><br><span class="line">            │   │   └── sha256</span><br><span class="line">            │   │       └── 7c459309b9a5ec1683ef3b137f39ce5888f5ad0384e488ad73c94e0243bc77d4</span><br><span class="line">            │   │           └── link</span><br><span class="line">            │   └── tags</span><br><span class="line">            │       └── buster-slim</span><br><span class="line">            │           ├── current</span><br><span class="line">            │           │   └── link</span><br><span class="line">            │           └── index</span><br><span class="line">            │               └── sha256</span><br><span class="line">            │                   └── 7c459309b9a5ec1683ef3b137f39ce5888f5ad0384e488ad73c94e0243bc77d4</span><br><span class="line">            │                       └── link</span><br><span class="line">            └── _uploads</span><br><span class="line"></span><br><span class="line">40 directories, 10 files</span><br></pre></td></tr></table></figure><p>根据 GC 后的 registry 存储目录我们可以看到，原本 blobs 目录下有 6 个 data 文件，现在已经变成了 3 个，alpine:3.10 这个镜像相关的 layer、config、manifest 这三个文件都已经被 GC 掉了。但是在 repositories 目录下，该镜像的 _layers 下的 link 文件依旧存在🤔。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结以上，用下面这三张图片就能直观地理解这些过程啦。</p><h4 id="delete-镜像之前的-registry-存储目录结构"><a href="#delete-镜像之前的-registry-存储目录结构" class="headerlink" title="delete 镜像之前的 registry 存储目录结构"></a>delete 镜像之前的 registry 存储目录结构</h4><p><img src="img/registry-gc-1.jpeg" alt="REGISTRY"></p><h4 id="delete-镜像之后的-registry-存储目录结构"><a href="#delete-镜像之后的-registry-存储目录结构" class="headerlink" title="delete 镜像之后的 registry 存储目录结构"></a>delete 镜像之后的 registry 存储目录结构</h4><p><img src="img/registry-gc-2.jpeg" alt=""></p><h4 id="GC-之后的-registry-存储目录结构"><a href="#GC-之后的-registry-存储目录结构" class="headerlink" title="GC 之后的 registry 存储目录结构"></a>GC 之后的 registry 存储目录结构</h4><p><img src="img/registry-gc-3.jpeg" alt=""></p><h3 id="shell-大法好！"><a href="#shell-大法好！" class="headerlink" title="shell 大法好！"></a>shell 大法好！</h3><p>根据上面的 GC 原理和过程，实际上我们可以使用不到 25 行的 shell 脚本来实现一个粗暴的  GC 😂</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -x</span><br><span class="line">v2=$1</span><br><span class="line">v2=$&#123;v2:="/var/lib/registry/docker/registry/v2"&#125;</span><br><span class="line">cd $&#123;v2&#125;</span><br><span class="line">all_blobs=/tmp/all_blobs.list</span><br><span class="line">: &gt; $&#123;all_blobs&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> marking all the blob by all images manifest</span></span><br><span class="line">for tag in $(find repositories -name "link" | grep current)</span><br><span class="line">do</span><br><span class="line">    link=$(cat $&#123;tag&#125; | cut -c8-71)</span><br><span class="line">    mfs=blobs/sha256/$&#123;link:0:2&#125;/$&#123;link&#125;/data</span><br><span class="line">    echo $&#123;link&#125; &gt;&gt; $&#123;all_blobs&#125;</span><br><span class="line">    grep sha256 $&#123;mfs&#125; |cut -d "\"" -f4 | cut -c8-71 &gt;&gt; $&#123;all_blobs&#125;</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> delete blob <span class="keyword">if</span> the blob doesn<span class="string">'t exist in all_blobs.list</span></span></span><br><span class="line">for blob in $(find blobs -name "data" | cut -d "/" -f4)</span><br><span class="line">do</span><br><span class="line">    grep $&#123;blob&#125; $&#123;all_blobs&#125;</span><br><span class="line">    if [[ $? != 0 ]]; then</span><br><span class="line">    rm -rf blobs/sha256/$&#123;blob:0:2&#125;/$&#123;blob&#125;</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ol><li><p>遍历所有镜像的 tag 下最新的 link 文件指向的 manifest</p></li><li><p>根据 manifest 文件 grep 出 sha256 值的 image config 和 layer 文件，保存到 <code>all_blobs.list</code> 文件中。</p></li><li><p>使用 <code>find</code> 和 <code>for</code> 循环遍历所有 blobs 下的的 data 文件，判断它是否在 <code>all_blobs.list</code> 中，不再的话直接 <code>rm -rf</code> 干掉它！</p></li><li><p>最后重启一下 registry 容器。</p></li></ol><p>就是这么简单粗暴！哈哈，<code>rm -rf</code> 用起来真爽（手动滑稽 。如果还想把这个脚本再优化一下的话，可以将 所有的 blob 的 sha256 值截取前 12 位保存在一个变量中。通过 <code>=~</code> 来判断包含关系来替代 grep。</p><h2 id="踩坑！"><a href="#踩坑！" class="headerlink" title="踩坑！"></a>踩坑！</h2><h3 id="The-operation-is-unsupported-405-Method-Not-Allowed"><a href="#The-operation-is-unsupported-405-Method-Not-Allowed" class="headerlink" title="The operation is unsupported.(405 Method Not Allowed)"></a>The operation is unsupported.(405 Method Not Allowed)</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 ~/registry</span><br><span class="line">╰─# skopeo delete docker://localhost/library/alpine:3.10 --debug</span><br><span class="line">DEBU[0000] Returning credentials from /run/containers/0/auth.json</span><br><span class="line">DEBU[0000] Using registries.d directory /etc/containers/registries.d for sigstore configuration</span><br><span class="line">DEBU[0000]  No signature storage configuration found for localhost/library/alpine:3.10</span><br><span class="line">DEBU[0000] Looking for TLS certificates and private keys in /etc/docker/certs.d/localhost</span><br><span class="line">DEBU[0000] Loading registries configuration "/etc/containers/registries.conf"</span><br><span class="line">DEBU[0000] GET https://localhost/v2/</span><br><span class="line">DEBU[0000] Ping https://localhost/v2/ status 401</span><br><span class="line">DEBU[0000] GET https://localhost/v2/library/alpine/manifests/3.10</span><br><span class="line">DEBU[0000] DELETE https://localhost/v2/library/alpine/manifests/sha256:a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590</span><br><span class="line">FATA[0000] Failed to delete /v2/library/alpine/manifests/sha256:a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590: &#123;"errors":[&#123;"code":"UNSUPPORTED","message":"The operation is unsupported."&#125;]&#125;</span><br><span class="line"> (405 Method Not Allowed)</span><br></pre></td></tr></table></figure><p>在 registry 容器启动的时候添加变量开启 <code>REGISTRY_STORAGE_DELETE_ENABLED=true</code> 即可，或者修改容器内的配置文件 <code>/etc/docker/registry/config.yml</code>，在 <code>storage:</code> 下添加上 下面的参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">delete:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="GC-不彻底，残留-link-文件"><a href="#GC-不彻底，残留-link-文件" class="headerlink" title="GC 不彻底，残留 link 文件"></a>GC 不彻底，残留 link 文件</h3><p>从上面我们可以得知，registry 无论是删除一个镜像还是进行 GC 操作，都不会删除 repositories 目录下的 <code>_layers/sha256/digest/link</code> 文件，在进行 GC 之后，一些镜像 layer 和 config 文件已经在 blobs 存储目录下删除了，但指向它的 layers/link 文件依旧保存在 repositories 目录下🙄。GitHub 上有个 PR <a href="https://github.com/docker/distribution/issues/2288" target="_blank" rel="noopener">Remove the layer’s link by garbage-collect #2288</a> 就是专门来清理这些无用的 layer link 文件的，最早的一个是三年前的，但是还没有合并😂。</p><p>留着已经被 GC 掉 blob 的 layer link 也没啥用，使用下面这个脚本就能删掉无用的 layer link 文件。根据 layer link 的值去 blobs 目录下看看该文件是否存在，不存在的话就 rm -rf 掉，存在的话就留着。这样就能清理干净啦😁。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">cd /var/lib/registry/docker/registry/v2</span><br><span class="line">for link in $(find repositories -name "link" | grep -E "_layers")</span><br><span class="line">do</span><br><span class="line">    link_sha256=$(echo $&#123;link&#125; | awk -F "/" '&#123;print $6&#125;')</span><br><span class="line">    link_short=$(echo $&#123;link&#125; | awk -F "/" '&#123;print $6&#125;' | cut -c1-2)</span><br><span class="line">    data_file=blobs/sha256/$&#123;link_short&#125;/$&#123;link_sha256&#125;</span><br><span class="line">    dir_link=$(echo $&#123;link&#125; | sed s'/link//g')</span><br><span class="line">    if [[ ! -d "$&#123;data_file&#125;" ]]; then</span><br><span class="line">    rm -rf $&#123;dir_link&#125;</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="GC-后要重启！"><a href="#GC-后要重启！" class="headerlink" title="GC 后要重启！"></a>GC 后要重启！</h3><p>GC 之后一定要重启，因为 registry 容器缓存了镜像 layer 的信息，当删除掉一个镜像 A ，后边 GC 掉该镜像的 layer 之后，如果不重启 registry 容器，当重新 PUSH 镜像 A 的时候就会提示镜像 layer 已经存在，不会重新上传 layer ，但实际上已经被 GC 掉了，最终会导致镜像 A 不完整，无法 pull 到该镜像。</p><h3 id="GC-不是事务性操作"><a href="#GC-不是事务性操作" class="headerlink" title="GC 不是事务性操作"></a>GC 不是事务性操作</h3><p>GC 的时候最好暂停 PUSH 镜像，以免把正在上传的镜像 layer 给 GC 掉。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;好久没更新博客了，在家摸鱼赶紧来
        
      
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.k8s.li/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="https://blog.k8s.li/tags/docker/"/>
    
      <category term="registry" scheme="https://blog.k8s.li/tags/registry/"/>
    
      <category term="镜像" scheme="https://blog.k8s.li/tags/%E9%95%9C%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>2020 阅读记录（二）</title>
    <link href="https://blog.k8s.li/Q2-reading.html"/>
    <id>https://blog.k8s.li/Q2-reading.html</id>
    <published>2020-06-19T16:00:00.000Z</published>
    <updated>2020-06-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  見證了這段歷史也越來越能體會感觸到：當今世界，專制的權力還在奴役人的自由；極權的統治還在控制人的思想；習慣性的不思考和無判斷將人傾向愚昧和自我欺騙，於是我們共同造就了這台極權專制的機器，我們服從這老大哥的思想，一切都要政治正確。</p></blockquote><p>悄无声息地渡过了 2020 年的一半，和上一篇读书记录<a href="https://blog.k8s.li/spring-reading-note.html">《春季读书笔记》</a>一样，这篇也是个人回顾一下最近三个月的读书记录，在此做个总结，以此来督促自己每天都要坚持阅读，坚持记录下去。</p><h3 id="在读"><a href="#在读" class="headerlink" title="在读"></a>在读</h3><ul><li>布拉格精神</li><li>大话存储</li><li>生命通史</li><li>徐贲文集</li><li>通往尊严的公共生活</li></ul><h3 id="2020-读完"><a href="#2020-读完" class="headerlink" title="2020 读完"></a>2020 读完</h3><p>回顾这大半年来一共完整读完了 48 本书😂</p><table><thead><tr><th align="center">书名</th><th align="center">作者</th><th align="center">时间</th><th align="center">阅读时长</th></tr></thead><tbody><tr><td align="center">论人类不平等的起源和基础</td><td align="center">[法]让-雅克·卢梭</td><td align="center">01-01</td><td align="center">5h</td></tr><tr><td align="center">社会主义：经济学与社会学的分析</td><td align="center">[奥] 路德维希·冯·米瑟斯</td><td align="center">01-01</td><td align="center">10h</td></tr><tr><td align="center">心理测量者</td><td align="center">[日]深真见</td><td align="center">01-03</td><td align="center">6h</td></tr><tr><td align="center">论革命</td><td align="center">[德] 汉娜·阿伦特</td><td align="center">01-05</td><td align="center">12h</td></tr><tr><td align="center">新常识：一党专政的性质和后果</td><td align="center">张雪忠</td><td align="center">01-15</td><td align="center">4h</td></tr><tr><td align="center">论科学与艺术</td><td align="center">[法]让-雅克·卢梭</td><td align="center">01-21</td><td align="center">2h</td></tr><tr><td align="center">地球脉动：前所未见的自然之美</td><td align="center">[英]阿拉斯泰尔·福瑟吉尔</td><td align="center">01-22</td><td align="center">2h</td></tr><tr><td align="center">社会契约论 (译林人文精选)</td><td align="center">[法]让-雅克·卢梭</td><td align="center">01-23</td><td align="center">4h</td></tr><tr><td align="center">中国国家治理的制度逻辑：一个组织学研究</td><td align="center">周雪光</td><td align="center">01-28</td><td align="center">8h</td></tr><tr><td align="center">病毒星球</td><td align="center">[美]卡尔·齐默</td><td align="center">01-28</td><td align="center">4h</td></tr><tr><td align="center">病毒来袭</td><td align="center">[美]内森•沃尔夫</td><td align="center">01-29</td><td align="center">2h</td></tr><tr><td align="center">血疫：埃博拉的故事</td><td align="center">理查德·普雷斯顿</td><td align="center">02-01</td><td align="center">8h</td></tr><tr><td align="center">远古的葱茏：古植物王国</td><td align="center">周志炎</td><td align="center">02-05</td><td align="center">4h</td></tr><tr><td align="center">古生物学简明教程</td><td align="center">朱才伐</td><td align="center">02-06</td><td align="center">3h</td></tr><tr><td align="center">上帝造人有多难：生命的密钥</td><td align="center">朱钦士</td><td align="center">02-07</td><td align="center">6h</td></tr><tr><td align="center">朱钦士的个人博客</td><td align="center">朱钦士</td><td align="center">02-08</td><td align="center">8h</td></tr><tr><td align="center">远古的辉煌：生物大幅射</td><td align="center">戎嘉余</td><td align="center">02-13</td><td align="center">6h</td></tr><tr><td align="center">牛津通识读本：地球</td><td align="center">[英]马丁·雷德芬</td><td align="center">02-13</td><td align="center">6h</td></tr><tr><td align="center">生命活动的摇篮：细胞</td><td align="center">王耀发</td><td align="center">02-16</td><td align="center">4h</td></tr><tr><td align="center">地球脉动2：奇迹世界</td><td align="center">胡·科里</td><td align="center">02-24</td><td align="center">3h</td></tr><tr><td align="center">一想到还有95<em>%的</em>问题留给人类，我就放心了</td><td align="center">豪尔赫•陈</td><td align="center">03-07</td><td align="center">4h</td></tr><tr><td align="center">历史的终结及最后之人</td><td align="center">[美]弗朗西斯·福山</td><td align="center">03-03</td><td align="center">10h</td></tr><tr><td align="center">我無罪：劉曉波傳</td><td align="center">余杰</td><td align="center">03-13</td><td align="center">8h</td></tr><tr><td align="center">神奇的生物化学</td><td align="center">神奇的生物化学</td><td align="center">03-23</td><td align="center">4h</td></tr><tr><td align="center">费马最终定理</td><td align="center">[日]日冲樱皮</td><td align="center">03-26</td><td align="center">3h</td></tr><tr><td align="center">被讨厌的勇气</td><td align="center">[日]岸見一郎</td><td align="center">03-28</td><td align="center">4h</td></tr><tr><td align="center">鸟瞰古文明</td><td align="center">[法] 让-克劳德·戈尔万</td><td align="center">04-03</td><td align="center">8h</td></tr><tr><td align="center">编码：隐匿在计算机软硬件背后的语言</td><td align="center">[美]查尔斯•佩措尔德</td><td align="center">04-10</td><td align="center">8h</td></tr><tr><td align="center">自由宪章</td><td align="center">[奥]弗里德里希·哈耶克</td><td align="center">04-01</td><td align="center">16h</td></tr><tr><td align="center">我们最幸福：北韩人民的真实生活</td><td align="center">[美]芭芭拉·德米克</td><td align="center">04-23</td><td align="center">6h</td></tr><tr><td align="center">哈维尔文集</td><td align="center">[捷克]哈维尔</td><td align="center">04-24</td><td align="center">8h</td></tr><tr><td align="center">布达佩斯往事：冷战时期一个东欧家庭的秘密档案</td><td align="center">[美] 卡蒂·马顿</td><td align="center">04-26</td><td align="center">6h</td></tr><tr><td align="center">致命的自负：社会主义的谬误</td><td align="center">[奥]弗里德里希·哈耶克</td><td align="center">05-01</td><td align="center">10h</td></tr><tr><td align="center">地球的演变故事</td><td align="center">姚建明</td><td align="center">05-02</td><td align="center">4h</td></tr><tr><td align="center">图解科技译丛：漫画元素118</td><td align="center">[日]斋腾胜裕</td><td align="center">05-02</td><td align="center">2h</td></tr><tr><td align="center">颓废与沉默：透视犬儒文化</td><td align="center">徐贲</td><td align="center">05-02</td><td align="center">4h</td></tr><tr><td align="center">统治与教育：从国民到公民</td><td align="center">徐贲</td><td align="center">05-03</td><td align="center">8h</td></tr><tr><td align="center">三角距离无限为零1-4</td><td align="center">[日]岬鹭宫</td><td align="center">05-05</td><td align="center">10h</td></tr><tr><td align="center">被禁锢的头脑</td><td align="center">[立]切斯瓦夫·米沃什</td><td align="center">05-05</td><td align="center">6h</td></tr><tr><td align="center">人以什么理由来记忆</td><td align="center">徐贲</td><td align="center">05-02</td><td align="center">10h</td></tr><tr><td align="center">宇宙从一粒尘埃开始：9堂极简宇宙课</td><td align="center">[英]布莱恩•考克斯</td><td align="center">05-25</td><td align="center">5h</td></tr><tr><td align="center">通往尊严的公共生活</td><td align="center">徐贲</td><td align="center">05-25</td><td align="center">10h</td></tr><tr><td align="center">宇宙从起源到未来</td><td align="center">[[美]约翰·布罗克曼</td><td align="center">06-18</td><td align="center">5h</td></tr><tr><td align="center">kubernetes 网络权威指南</td><td align="center">杜军</td><td align="center">06-20</td><td align="center">6h</td></tr><tr><td align="center">Linux开源网络全栈详解：从DPDK到OpenFlow</td><td align="center">英特尔亚太研发有限公司</td><td align="center">06-20</td><td align="center">3h</td></tr><tr><td align="center">大话处理器</td><td align="center">万木杨</td><td align="center">06-21</td><td align="center">1h</td></tr><tr><td align="center">三角的距离无限为零5</td><td align="center">[日]岬鹭宫</td><td align="center">06-24</td><td align="center">2.5h</td></tr></tbody></table><h2 id="4-月"><a href="#4-月" class="headerlink" title="4 月"></a>4 月</h2><h3 id="自由宪章"><a href="#自由宪章" class="headerlink" title="自由宪章"></a>自由宪章</h3><p>《自由宪章》是这大半年来最难啃的书，哈耶克的书对于木子这种菜鸡来说读起来就是头大啊😂，和我在一月份读的《自由与繁荣的国度》味道一样。</p><h4 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h4><p><strong>弗里德里希·哈耶克</strong>（Friedrich A·Hayek）是奥地利经济学家和政治哲学家。身为1974年的诺贝尔经济学奖的获得者之一，他主张以市场为基础的自由资本主义和有限的政府。此外，他还于1991年获得了总统自由勋章。</p><p>在这本书中，单单法治概念的含义，哈耶克本人就罗列引用了 30 多本著作！可见当时哈耶克本人的学术水平相当高滴！</p><blockquote><ul><li>《法律与秩序》</li><li>《教会、国家与研究》</li><li>《新利维坦》</li><li>《美国的行政司法及法律的最高地位》</li><li>《宪政政治与民主》</li><li>《政治与行政》</li><li>《现代共同体的基础》</li><li>《对良好社会原则探索》</li><li>《宪政与变动中的世界》</li><li>《民主国家与集权国家》</li><li>《行政与法治》</li><li>《现代政治诸要素》</li><li>《法治：保守的伦敦律师公会与工会协会进行的研究》</li><li>《法律：有关民主之中的权威的理论的论文》</li><li>《个人主义与法律》</li><li>《宪法学》</li><li>《宪法之保卫者》</li><li>《法治国家，还是独裁？》</li><li>《政治学》《法治国家有效性的界限》</li><li>《法治国家还是威权国家？》</li><li>《自由主义作为一种意识形态的没落》</li><li>《波恩基本法中的社会法治国家概念》</li><li>《作为刑法最新发展的中心概念的法治国家》</li><li>《法、国家、经济》</li><li>《从法律国家到法官国家》</li><li>《瑞士联邦国家法》</li><li>《德国行政法的体制》</li><li>《瑞士联邦法院的宪法管辖权》</li><li>《法制国家民主制》</li><li>《美国与瑞士宪法管辖权的政治意识形态上与法律意识形态上的根据》</li><li>《作为国家根本法律秩序的宪法》</li><li>《瑞士法律中的公民自由》</li><li>《法治国家的秩序》</li><li>《1955年雅典国际法学家大会报告》</li></ul></blockquote><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>虽然这本书早在1960年就已出版，但其深刻的见解时至今日仍然盛行。他所倡导的经济和个人自由理论适用于很多当今的热议话题，从物价上涨到累进税制。在书中，作者对比了建立有限政府的益处和实施中央计划经济的弊端。限制政府权力将会有利于提升个体能动性和创造力，进而推动人类知识和文明的进步。哈耶克论证了法律法规、合法程序和宪法政府对自由的积极作用，并指出个人自由所面临的严峻的潜在威胁。以下是本书的几个要点：</p><ul><li>有限的政府通过激发人的个体主动性来推动社会的进步。</li><li>财产权利和个人自由这一宽泛的政治概念有着密切的联系。</li><li>只有那些与约定俗成的道德观念相符的法律才能经得住时间的考验。</li><li>多数裁定原则自然很有必要，但仅仅依靠它还不足以建立一个自由社会。</li><li>宪政是美国追求自由事业最有力的武器。</li><li>社会主义是一种失败的政府形式，但它至今依然影响着公共政策的制定。</li><li>通过收入再分配来缓解贫困会带来意想不到的负面效应，比如“福利国家”的出现。</li><li>基于市场状况的奖励制度比基于个人优点的奖励制度更加有效。</li><li>比起通货紧缩，政府更倾向于通货膨胀。但过度的膨胀会威胁到自由。</li><li>限制政府对教育的干涉有利于社会保持思想活力。</li></ul><h3 id="我们最幸福：北朝鲜人民的真实生活"><a href="#我们最幸福：北朝鲜人民的真实生活" class="headerlink" title="我们最幸福：北朝鲜人民的真实生活"></a>我们最幸福：北朝鲜人民的真实生活</h3><p>读完这本书就感觉到当今的朝鲜就如上世纪的中国<strong>十年文革基础上再加上三年大饥荒</strong>一样悲惨，这种纪实类的写作和《切尔诺贝利的悲鸣》以及《十个人的一百年》一样，沉重的历史感。我们都是被共产主义的极权专制独裁暴政统治蹂躏过的民族，感同身受的历史记忆，彷佛就在映射着当下一样，让人有种身在历史中感受它的存在一样。看看下面这几段摘抄，和文革时期的我们以及当下的我们又是何其的相似：</p><blockquote><p>  由于北韩太贫困，电力供应不足以维持电子监控，所以国家安全必须仰赖人力情报——告密。报纸偶尔会出现文情并茂的报导，描述勇敢的孩子纠举父母的违法行为。由此看来，因发表对当局不满的言论而被邻居告发也就不觉得奇怪了。</p></blockquote><blockquote><p>  北韩人学会吞下自己的自尊与捏住自己的鼻子。他们从农村动物的排泄物中挑出来未被消化的玉米粒。船厂工人发展处一种技术，原本储存粮食的货仓底部残留着腐臭黏腻的东西，他们将这些东西刮起了，放在地面晾干，从中可以拾取一点未烹煮过的稻米与其他可食用的谷物。</p></blockquote><blockquote><p>  孩子睡觉时要提防其他帮派偷走他们的少许余粮。此外也流传着许多诡异的故事，提到成年人把孩子当成猎物。不只用来发泄性欲，也当成食物。金赫听说有人对孩子下毒，杀死孩子，大卸八块吃下肚。在火车站后面，靠近铁道边，有些小贩在小火炉上煮汤煮面，据说浮在上面的灰色肉块就是人肉。</p></blockquote><blockquote><p>  各级督导例行性地捏造农业生产与工业产出的统计数据，因为他们不敢告诉长官实情。为了圆谎，只好说更多的谎，从基层传达到高层的讯息没有一件是真的，所以可以想见金日成本人恐怕完全不知道经济的状况有多糟。</p></blockquote><h4 id="作者-1"><a href="#作者-1" class="headerlink" title="作者"></a>作者</h4><p><strong>芭芭拉·德米克</strong></p><h4 id="别笑，我们也很幸福"><a href="#别笑，我们也很幸福" class="headerlink" title="别笑，我们也很幸福"></a>别笑，我们也很幸福</h4><p><img src="img/2020-06-27_17-12-28.jpg" alt="img"></p><p>看完这本书也可以去看另外一本书《黄长烨回忆录》</p><blockquote><p>  我在一个充满了虚伪和欺骗的社会生活了很久，一开始我以为虚伪和欺骗是为了解放勤劳的人民大众，即为了取得与剥削阶级斗争的胜利而必须采用的手段。 但是，后来我意识到，虚伪与欺骗已经与独裁者的利己主义结合起来。独裁者的利己主义集中体现为个人崇拜思想，北朝鲜是全世界个人崇拜和阶级主义最严重的国家。 我身处北朝鲜统治体制的中枢，是整个虚伪宣传的动员和组织者（作者是北朝鲜马克思主义和意识形态领域的权威，译者注）。虚伪曾经一度取代真理占据一个学者的良心，与学者的灵魂对立。 我（在书中）不会因为讨厌我和让我讨厌的人而夸大、丑化事实，也不会因为爱我和让我爱的人而毫无原则的美化现实。 历史就摆在那里，对历史来说，歪曲是最大的犯罪。我不认为我说的就是绝对（正确），我反倒更希望读者带着批判的态度来阅读本书。 对于与大众利益毫无关系的个人生活，或者有干涉它国内政之嫌的言论，我会尽量避免。来到韩国之后，我在努力学习新事物，开始新的体验。 但是，我已经老了，学到的新知识和新经验对我思考方法的影响有限。在本书中，我还是想将在北朝鲜经历过的、体验过的写出来。</p></blockquote><h3 id="哈维尔文集"><a href="#哈维尔文集" class="headerlink" title="哈维尔文集"></a>哈维尔文集</h3><p>三月份在读《我无罪：刘晓波传》的时候意外收获到的这本书，刘晓波和哈维尔至于捷克</p><p>另外推荐阅读李慎之先生为这本书题的序的<a href="http://www.aisixiang.com/data/1724.html" target="_blank" rel="noopener">《无权者的权力和反政治的政治：后极权主义时代的人生哲学》</a></p><h3 id="布达佩斯往事：冷战时期一个东欧家庭的秘密档案"><a href="#布达佩斯往事：冷战时期一个东欧家庭的秘密档案" class="headerlink" title="布达佩斯往事：冷战时期一个东欧家庭的秘密档案"></a>布达佩斯往事：冷战时期一个东欧家庭的秘密档案</h3><p>在二月份的时候剩余价值里的一期节目中提到过《布达佩斯往事：冷战时期一个东欧家庭的秘密档案》这本书，而这本书的序言正是徐贲老师写的，后来陆续又读了五六本徐贲老师的书。</p><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><blockquote><p>  本书通过冷战时期匈牙利秘密警察长达20年的档案，所揭开的是一部隐藏了几十年的家庭历史和时代侧记。</p><p>  冷战时期，苏联集团中的匈牙利，秘密警察通过庞大的告密网，试图全面渗透控制匈牙利的政治生活。作者的父母原是匈牙利著名记者，他们的报道是西方了解匈牙利的重要信息来源。因此他们被视为“人民的敌人”，长期受秘密警察的监控，终因叛国和间谍罪而先后入狱。一家移居美国后，匈牙利政府却又异想天开地试图招募他们当间谍，而美国也对他们进行了几年的监控。书中不只还原了马顿夫妇被告密者包围的经历和遭遇，他们的抗争、坚守、脆弱和勇气，也展现了他们情感和内心的矛盾——夫妻之间相互的感情背叛与灾难中的支撑，父母子女之间的爱与亲情，人性的坚强与软弱，从而使得这本书更为丰富、复杂，具有血肉。</p></blockquote><h2 id="5-月"><a href="#5-月" class="headerlink" title="5 月"></a>5 月</h2><h3 id="致命的自负：社会主义的谬误"><a href="#致命的自负：社会主义的谬误" class="headerlink" title="致命的自负：社会主义的谬误"></a>致命的自负：社会主义的谬误</h3><p>地球的演变故事</p><h3 id="图解科技译丛：漫画元素118"><a href="#图解科技译丛：漫画元素118" class="headerlink" title="图解科技译丛：漫画元素118"></a>图解科技译丛：漫画元素118</h3><h3 id="人以什么理由来记忆"><a href="#人以什么理由来记忆" class="headerlink" title="人以什么理由来记忆"></a>人以什么理由来记忆</h3><h4 id="作者-2"><a href="#作者-2" class="headerlink" title="作者"></a>作者</h4><p><strong>徐贲</strong></p><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>之前我也读过他的论文 <a href="https://matters.news/@philosophia1979/徐贲-中国的-新极权主义-及其末世景象-野兽荐读-bafyreiegbg5tti3ljc7newaah5wp36ncf7fvb2oaovd6p7elc4xqfhbcd4" target="_blank" rel="noopener">《中国的“新极权主义”及其末世景象》</a>) ，所以对他关注的内容也有所了解。总感觉这本书更像是阿伦特、加缪、萨特、哈维尔等人对于极权主义著作及思想的解析。就像在剩余价值里提到的，我们读这些历史的时候，而当下就仿佛置身于历史之中一样。书中记录苏联和纳粹德国极权统治改造人性的言论审查、秘密警察、集中营、无言论自由和新闻自由、党媒愚民洗脑等，这些描述极权统治的历史，再看一看当下，我们不正置身于其中吗？</p><ul><li><strong>比瘟疫更可怕的是謊言，比災難更可怕的是遺忘</strong></li></ul><p><img src="img/20200618225156768.png" alt="image-20200618225156768"></p><p><img src="img/2020-06-09_15-46-37.jpg" alt=""></p><p><img src="img/2020-06-09_15-46-372.jpg" alt=""></p><p><img src="img/2020-06-09_15-46-373.jpg" alt=""></p><p>诺贝尔和平奖得主 <a href="https://www.rfa.org/mandarin/pinglun/liuxiaobopinglunzhuanji/64-06022008113911.html" target="_blank" rel="noopener">刘晓波曾经说过，</a>“遗忘罪恶历史的民族，决不会有真正的未来。”</p><blockquote><p>  “对于一个民族来说，记忆对遗忘的抗拒，首先是知识精英的良知对强权的抗拒。否则的话，我们非但无法把六四大屠杀的真相、进而把独裁制度的罪恶变成民众的历史常识，也无法防止类似大悲剧的重演。难道中国历史在专制下恶性循环的时间还不够长吗？”</p></blockquote><p>最终，因为遗忘罪恶历史而受害的，只会是中国人自己。</p><p>就像刘晓波所说的那样：</p><p><strong>“用民间记忆抗拒官方的强制遗忘，就是为我们这个历尽苦难的民族保存记忆和良知。”</strong></p><blockquote><p>  人民“获得”的“国家历史”是那些记录下来，或者说被权力允许记录下来的“事件”，而那些没有被记录或不被允许记录下来的事件，就此被武断地从国家历史中剔除，也从族群记忆中排斥出去了。因此，对历史真实保持沉默，虽然是从改写历史开始，但最终却表现为族群的集体忘却。每个沉默的个人，每个在族群中按权力意志来记忆或忘却的人，都参与在以沉默代替真实，以沉默维持谎言的共谋之中。</p></blockquote><h3 id="颓废与沉默：透视犬儒文化"><a href="#颓废与沉默：透视犬儒文化" class="headerlink" title="颓废与沉默：透视犬儒文化"></a>颓废与沉默：透视犬儒文化</h3><p>恰好读完这本书之后不久 B 站就上映了后浪洗脑宣传片，不料微博评论区也是翻车现场🤣</p><p><img src="img/2020-05-04_17-31-222.jpg" alt=""></p><p><img src="img/2020-05-04_17-31-223.jpg" alt=""></p><p>第一次听说到后浪的时候我就觉着，这类身居高位的犬儒知识份子，如胡锡进、胡鞍钢、金灿荣、张维为这类，为当权者歌功赞德、拍马溜须、谄媚献媚、阿谀奉承，这类人应该比任何人都清楚在这太平盛世的背后，抓捕了多少维权律师、迫害了多少异议人士、关押了多少公民记者、处分了多少直言教师。然这些知识分子、教授、专家在说假话，用所谓的”学术”来取悦和投靠权力和当权者,谋取私利，以貌似高深、渊博、精致的理论包装普通人用常识就能看穿的慌言，有的甚至还相当”富有创意”，善于”理论更新”,或有”理论建树”。</p><p>在政治意识形态主导一切,权力可以操控一切的社会里,不存在所谓的”独立学术”,尤其不存在独立的人文学术。一些知识分子因为不得已而做”纯学问”,是一种憋屈的学术”自宫”。权力的咸胁与利诱造就体制性的”学术义儒”,它往往是一种在清醒状态下的装傻——一面自嘲,一面配合体制,积极自我审査；一面咒骂,一面迎合体制的无理要求；一面鄙视不懂学术的顶头上司,一面顺从他们的领导权威；一面嘲笑,一面参与为官员授予各种真的假学位和假头衔。</p><blockquote><p>  阿伦特在1963年7月24日给友人卡斯贝尔（Gerhard Casper）的信里写道:”人们经常发现,洗脑欺骗最肯定的长期后果就是造成犬儒主义——绝对不相信任何事情可能是真的,哪怕是确有实据的真实,也照样不相信。换言之,完全用谎言来代替事实真相的结果不是人们会把谎言当作真实,或者真实会被当作为谎言,而是我们赖以在真实世界里存在的知觉会被完全摧毁。人类为了生存,必须具备基本知觉,其中就有对真和假的识别。”</p></blockquote><blockquote><p>  阿伦特认为,社会中的多数人集体投向犬儒主义,是因为政治权力长期用谎言来代替真实,大规模地对群众进行洗脑并欺骗他们。这是20世纪才有的统治方式,最典型的例子就是斯大林统治时期否认托洛茨基曾对俄罗斯革命有过任何贡献。阿伦特称此为”极权谎言”,它要编造的是一种完全虚假的,因此彻底颠覆真伪区别的”真实”。</p></blockquote><h4 id="犬儒主义"><a href="#犬儒主义" class="headerlink" title="犬儒主义"></a>犬儒主义</h4><ul><li>（1）娱乐至死（没有目标或信仰,得过且过）；</li><li>（2）看客心态（看穿、冷漠、围观,管了也没用,不如不管）；</li><li>（3）习惯性怀疑（上至政府,下至朋友,对谁都不信任,都不相信）；</li><li>（4）审丑心理（在一个是非不分的环境里,美丑、善恶、真假也无法辨别,何必要坚持真、善、美）；</li><li>（8）”鸵鸟心态”（多一事不如少一事,被宣传的现实反正是假的,不如”躲进小楼成一统”）;</li><li>（9）思考恐惧症（多思多惹事,有的是前车之鉴,你要我怎么说,我就怎么说,这才是安身保命之道）；</li><li>（11）炫富心态（看穿一些道德、理想、未来展望的虚妄,只有钱才是实在的,才是世人认可的唯一价值）；</li><li>（12）初老症（没有前途、没有未来、没有追求,过一天算一天,坐吃等死）；</li><li>（13）自虐心态（这个说法并不确实,因为一般人既非共产党又非体制,不是”自虐”,这种顾左右而言他的说法,明白人说糊涂话,既不诚实,也不真实,它本身就是犬儒主义的）。</li></ul><blockquote><p>  对犬儒的现代定义是有代表性的:一、挑刺、嘲笑、讽刺；二、不相信或装着不相信普通人接受的道德价值观和人类行为真诚的善良动机,把自私自利认作唯一可能的动机；轻蔑、鄙视、嘲讽的怀疑和不相信。</p></blockquote><p>刘晓波曾在 <a href="http://www.liu-xiaobo.org/blog/archives/12412" target="_blank" rel="noopener">刘晓波：在刀锋上行走——狱中读《布拉格精神》</a> 写过：</p><blockquote><p>  据克里玛的介绍，在前苏东极权下的捷克知识分子群体中，不仅出现了哈维尔这样的道义示范，而且有95％以上的人为了自由和良知而进行着各种形式的拒绝，只有不到5%的人甘愿堕落为卖身投靠者。这当然是让中国知识分子自觉羞愧的表现。我们没有捷克人那种清醒和坚韧，仅仅十年的时间，六四的伤口便被遗忘，这不光是因为官方的强制，也是民族灵魂的冷漠。知识分子群体不能以言行来洗刷耻辱，既源于外在的政治恐怖，更源于他们生命中洗刷耻辱的冲动已经死亡。</p></blockquote><h3 id="统治与教育：从国民到公民"><a href="#统治与教育：从国民到公民" class="headerlink" title="统治与教育：从国民到公民"></a>统治与教育：从国民到公民</h3><blockquote><p>  极权政体彻底控制与思想、言论、新闻有关的要害领域，教育是被管制得最严厉的领域之一，和宣传一样，被严格控制。这样的教育虽然与民主国家的教育一样被称为“教育”，但实际上已经成为政治权力控制国民思想和培养子民的工具。这与民主国家中学校教育作为公民社会文化机制的一部分，起到培养民主公民的作用，是完全不同的。</p></blockquote><blockquote><p>  纳粹统治德国，依靠的不仅是完全由纳粹控制和操纵的国家机器，政府、各级纳粹党组织、党卫军、冲锋队、警察等，而且更是无处不在的纳粹意识形态，它渗透到德国社会、文化、教育和家庭生活的每一个角落，确保纳粹政党成为德国主权的内核。正是由于纳粹政党实际上已经成为德国主权的内核，德国的国家主义才会按照纳粹的意志转变为符合纳粹党利益，并为它的利益服务的党国主义。</p></blockquote><blockquote><p>  在纳粹的极权统治制度中，学校进行的是一种由统治政党意识形态指挥的党化教育。这种党化教育渗透到教育的每一个环节之中，而在每一个环节中使这种党化意识形态顺利发生作用的正是无数直接从事教学工作的教师。党化教育迫使人们不断进行思想的相互纯洁和自我纯洁，它在课堂里发生之前，早就先已经在许多教师的头脑中发生了，并成为他们的思维和行为习惯。没有这样的教师，党化教育是不可能在学校里有效贯彻的。</p></blockquote><blockquote><p>  在极权国家里，国民必须有相同的正确表现，教师在学校里的行为被完全模式化了。教师们都忠于党，按党的要求去做，他们在学校的行为并不仅仅是“好教师”行为，同时也是“好国民”行为。当一个“好国民”，就是像所有其他国民一样对领袖、党和党国表现绝对的忠诚。“</p></blockquote><blockquote><p>  纳粹德国实行的是一种彻底的以国家主义为旗号的党化教育，这种教育从儿童开始，在课程、教学、教材、师生关系的每一个环节上都贯彻纳粹的极权统治原则。</p></blockquote><blockquote><p>  在《极权主义的起源》一书中，汉娜·阿伦特从极权主义原型的特点中概括出它成功统治的三大要素，它们分别是暴力和恐惧的统治，迫使人民成为相互隔绝的、无助无援的散沙个体，以及充分运用“组织”和“宣传”的力量。阿伦特亲身经历过她所思考的极权主义中最为成功的一种，那就是德国纳粹的极权。她对极权主义三要素的总结便是从她的直接经验中观察得出的。</p></blockquote><blockquote><p>  党的宣传要求新闻从“正面报道”，所以总是尽量不让坏消息曝光。它认为，坏消息不利于稳定人心，也可能被别人利用，所以，坏消息也成为一种不能泄露的“国家机密”。</p></blockquote><h3 id="三角的距离无限为零1-4"><a href="#三角的距离无限为零1-4" class="headerlink" title="三角的距离无限为零1-4"></a>三角的距离无限为零1-4</h3><h3 id="七堂极简物理课"><a href="#七堂极简物理课" class="headerlink" title="七堂极简物理课"></a>七堂极简物理课</h3><p>虽然被捧得很好，但觉着没啥好看的……🙄</p><h2 id="6-月"><a href="#6-月" class="headerlink" title="6 月"></a>6 月</h2><h3 id="被禁锢的头脑"><a href="#被禁锢的头脑" class="headerlink" title="被禁锢的头脑"></a>被禁锢的头脑</h3><h3 id="宇宙从一粒尘埃开始：9堂极简宇宙课"><a href="#宇宙从一粒尘埃开始：9堂极简宇宙课" class="headerlink" title="宇宙从一粒尘埃开始：9堂极简宇宙课"></a>宇宙从一粒尘埃开始：9堂极简宇宙课</h3><p>不错的天体物理学科普，简单讲了下大爆炸、暴涨、量子力学等知识，以及如何给地球称重量、如何测量天体之间的距离等。</p><h3 id="宇宙从起源到未来"><a href="#宇宙从起源到未来" class="headerlink" title="宇宙从起源到未来"></a>宇宙从起源到未来</h3><p>作者阵容很强</p><h3 id="kubernetes-网络权威指南"><a href="#kubernetes-网络权威指南" class="headerlink" title="kubernetes 网络权威指南"></a>kubernetes 网络权威指南</h3><p>这是一本技术干货，写作风格和博客极为相似，主要是讲了些 kubernetes 及其容器网路的底层原理，是容器网络里难得的中文资料，值得推荐。</p><h3 id="大话处理器"><a href="#大话处理器" class="headerlink" title="大话处理器"></a>大话处理器</h3><h3 id="Linux-开源网络全栈详解：从-DPDK-到-OpenFlow"><a href="#Linux-开源网络全栈详解：从-DPDK-到-OpenFlow" class="headerlink" title="Linux 开源网络全栈详解：从 DPDK 到 OpenFlow"></a>Linux 开源网络全栈详解：从 DPDK 到 OpenFlow</h3><h3 id="三角的距离无限为零5"><a href="#三角的距离无限为零5" class="headerlink" title="三角的距离无限为零5"></a>三角的距离无限为零5</h3>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt; 
        
      
    
    </summary>
    
    
    
      <category term="life" scheme="https://blog.k8s.li/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出容器镜像的一生🤔</title>
    <link href="https://blog.k8s.li/Exploring-container-image.html"/>
    <id>https://blog.k8s.li/Exploring-container-image.html</id>
    <published>2020-06-13T16:00:00.000Z</published>
    <updated>2020-06-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>上周在写<a href="https://blog.k8s.li/skopeo.html">《镜像搬运工 skopeo 》</a> 的时候看了很多关于容器镜像相关的博客，从大佬们那里偷偷学了不少知识，对容器镜像有了一点点深入的了解。这周末一个人闲着宅在家里没事就把最近所学的知识整理一下分享出来，供大家一起来食用。内容比较多，耐心看完的话，还是能收获一些<del>没用的</del>知识滴😂。</p><h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><ul><li>2020-06-13：还有一些没有写完，后续补充</li><li>2020-06-06： 初稿</li><li>2020-09-02：补充</li></ul><h2 id="镜像是怎样炼成的🤔"><a href="#镜像是怎样炼成的🤔" class="headerlink" title="镜像是怎样炼成的🤔"></a>镜像是怎样炼成的🤔</h2><p>所谓炼成像就是构建镜像啦，下面用到的<strong>搓</strong>和<strong>炼制</strong>都是指的构建镜像啦，只是个人习惯用语而已😂。</p><p>提到容器镜像就不得不提一下 OCI ，即 Open Container Initiative 旨在围绕容器格式和运行时制定一个开放的工业化标准。目前 OCI 主要有三个规范：运行时规范 <a href="https://github.com/opencontainers/runtime-spec" target="_blank" rel="noopener">runtime-spec</a> ，镜像规范 <a href="http://www.github.com/opencontainers/image-spec" target="_blank" rel="noopener">image-spec</a> 以及不常见的镜像仓库规范 <a href="https://github.com/opencontainers/distribution-spec" target="_blank" rel="noopener">distribution-spec</a> 。关于 OCI 这些规范的作用的作用，就引用一下 <a href="https://wilhelmguo.cn/blog/post/william/%E5%AE%B9%E5%99%A8%E5%BC%80%E6%94%BE%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83%EF%BC%88CRI-OCI%EF%BC%89-2" target="_blank" rel="noopener">容器开放接口规范（CRI OCI）</a> 中的内容，我也就懒得自己组织语言灌水了😂（凑字数</p><blockquote><p>制定容器格式标准的宗旨概括来说就是不受上层结构的绑定，如特定的客户端、编排栈等，同时也不受特定的供应商或项目的绑定，即不限于某种特定操作系统、硬件、CPU架构、公有云等。</p><p>这两个协议通过 OCI runtime filesytem bundle 的标准格式连接在一起，OCI 镜像可以通过工具转换成 bundle，然后 OCI 容器引擎能够识别这个 bundle 来运行容器</p><ul><li>操作标准化：容器的标准化操作包括使用标准容器创建、启动、停止容器，使用标准文件系统工具复制和创建容器快照，使用标准化网络工具进行下载和上传。</li><li>内容无关：内容无关指不管针对的具体容器内容是什么，容器标准操作执行后都能产生同样的效果。如容器可以用同样的方式上传、启动，不管是PHP应用还是MySQL数据库服务。</li><li>基础设施无关：无论是个人的笔记本电脑还是AWS S3，亦或是OpenStack，或者其它基础设施，都应该对支持容器的各项操作。</li><li>为自动化量身定制：制定容器统一标准，是的操作内容无关化、平台无关化的根本目的之一，就是为了可以使容器操作全平台自动化。</li><li>工业级交付：制定容器标准一大目标，就是使软件分发可以达到工业级交付成为现实</li></ul></blockquote><p>其实 OCI 规范就是一堆 markdown 文件啦，内容也很容易理解，不像 RFC 和 ISO 那么高深莫测，所以汝想对容器镜像有个深入的了解还是推荐大家去读一下这些 markdown 文件😂。OCI 规范是免费的哦，不像大多数 ISO 规范还要交钱才能看（︶^︶）哼。</p><h3 id="OCI-image-spec"><a href="#OCI-image-spec" class="headerlink" title="OCI image-spec"></a>OCI image-spec</h3><p>OCI 规范中的镜像规范 <a href="http://www.github.com/opencontainers/image-spec" target="_blank" rel="noopener">image-spec</a> 决定了我们的镜像按照什么标准来构建，以及构建完镜像之后如何存放，接着下文提到的 Dockerfile 则决定了镜像的 layer 内容以及镜像的一些元数据信息。一个镜像规范 image-spec 和一个 Dockerfile 就指导着我们构建一个镜像，那么接下来我们就简单了解一下这个镜像规范，看看镜像是长什么样子的，对镜像有个大体的主观认识。</p><p>根据官方文档的描述，OCI 镜像规范的主要由以下几个 markdown 文件组成：</p><blockquote><ul><li><a href="https://github.com/opencontainers/image-spec/blob/master/manifest.md" target="_blank" rel="noopener">Image Manifest</a> - a document describing the components that make up a container image</li><li><a href="https://github.com/opencontainers/image-spec/blob/master/image-index.md" target="_blank" rel="noopener">Image Index</a> - an annotated index of image manifests</li><li><a href="https://github.com/opencontainers/image-spec/blob/master/image-layout.md" target="_blank" rel="noopener">Image Layout</a> - a filesystem layout representing the contents of an image</li><li><a href="https://github.com/opencontainers/image-spec/blob/master/layer.md" target="_blank" rel="noopener">Filesystem Layer</a> - a changeset that describes a container’s filesystem</li><li><a href="https://github.com/opencontainers/image-spec/blob/master/config.md" target="_blank" rel="noopener">Image Configuration</a> - a document determining layer ordering and configuration of the image suitable for translation into a <a href="https://github.com/opencontainers/runtime-spec" target="_blank" rel="noopener">runtime bundle</a></li><li><a href="https://github.com/opencontainers/image-spec/blob/master/conversion.md" target="_blank" rel="noopener">Conversion</a> - a document describing how this translation should occur</li><li><a href="https://github.com/opencontainers/image-spec/blob/master/descriptor.md" target="_blank" rel="noopener">Descriptor</a> - a reference that describes the type, metadata and content address of referenced content</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├── annotations.md         # 注解规范</span><br><span class="line">├── config.md              # image config 文件规范</span><br><span class="line">├── considerations.md      # 注意事项</span><br><span class="line">├── conversion.md          # 转换为 OCI 运行时</span><br><span class="line">├── descriptor.md          # OCI Content Descriptors 内容描述</span><br><span class="line">├── image-index.md         # manifest list 文件</span><br><span class="line">├── image-layout.md        # 镜像的布局</span><br><span class="line">├── implementations.md     # 使用 OCI 规范的项目</span><br><span class="line">├── layer.md               # 镜像层 layer 规范</span><br><span class="line">├── manifest.md            # manifest 规范</span><br><span class="line">├── media-types.md         # 文件类型</span><br><span class="line">├── README.md              # README 文档</span><br><span class="line">├── spec.md                # OCI 镜像规范的概览</span><br></pre></td></tr></table></figure><p>总结以上几个 markdown 文件， OCI 容器镜像规范主要包括以下几块内容：</p><h4 id="layer"><a href="#layer" class="headerlink" title="layer"></a>layer</h4><p><a href="https://github.com/opencontainers/image-spec/blob/master/layer.md" target="_blank" rel="noopener">文件系统</a>：以 layer （镜像层）保存的文件系统，每个 layer 保存了和上层之间变化的部分，layer 应该保存哪些文件，怎么表示增加、修改和删除的文件等。</p><h4 id="image-config"><a href="#image-config" class="headerlink" title="image config"></a>image config</h4><p><a href="https://github.com/opencontainers/image-spec/blob/master/config.md" target="_blank" rel="noopener">image config 文件</a>：保存了文件系统的层级信息（每个层级的 hash 值，以及历史信息），以及容器运行时需要的一些信息（比如环境变量、工作目录、命令参数、mount 列表），指定了镜像在某个特定平台和系统的配置，比较接近我们使用 <code>docker inspect &lt;image_id&gt;</code> 看到的内容。</p><ul><li>example</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"architecture"</span>: <span class="string">"amd64"</span>,</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">    <span class="attr">"Hostname"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"Domainname"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"User"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"AttachStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"AttachStdout"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"AttachStderr"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"Tty"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"OpenStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"StdinOnce"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"Env"</span>: [</span><br><span class="line">      <span class="string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"Cmd"</span>: [</span><br><span class="line">      <span class="string">"bash"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"Image"</span>: <span class="string">"sha256:ba8f577813c7bdf6b737f638dffbc688aa1df2ff28a826a6c46bae722977b549"</span>,</span><br><span class="line">    <span class="attr">"Volumes"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"WorkingDir"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"Entrypoint"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"OnBuild"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"Labels"</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"container"</span>: <span class="string">"38501d5aa48c080884f4dc6fd4b1b6590ff1607d9e7a12e1cef1d86a3fdc32df"</span>,</span><br><span class="line">  <span class="attr">"container_config"</span>: &#123;</span><br><span class="line">    <span class="attr">"Hostname"</span>: <span class="string">"38501d5aa48c"</span>,</span><br><span class="line">    <span class="attr">"Domainname"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"User"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"AttachStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"AttachStdout"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"AttachStderr"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"Tty"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"OpenStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"StdinOnce"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"Env"</span>: [</span><br><span class="line">      <span class="string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"Cmd"</span>: [</span><br><span class="line">      <span class="string">"/bin/sh"</span>,</span><br><span class="line">      <span class="string">"-c"</span>,</span><br><span class="line">      <span class="string">"#(nop) "</span>,</span><br><span class="line">      <span class="string">"CMD [\"bash\"]"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"Image"</span>: <span class="string">"sha256:ba8f577813c7bdf6b737f638dffbc688aa1df2ff28a826a6c46bae722977b549"</span>,</span><br><span class="line">    <span class="attr">"Volumes"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"WorkingDir"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"Entrypoint"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"OnBuild"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"Labels"</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"created"</span>: <span class="string">"2020-06-07T01:59:47.348924716Z"</span>,</span><br><span class="line">  <span class="attr">"docker_version"</span>: <span class="string">"19.03.5"</span>,</span><br><span class="line">  <span class="attr">"history"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"created"</span>: <span class="string">"2020-06-07T01:59:46.877600299Z"</span>,</span><br><span class="line">      <span class="attr">"created_by"</span>: <span class="string">"/bin/sh -c #(nop) ADD file:a82014afc29e7b364ac95223b22ebafad46cc9318951a85027a49f9ce1a99461 in / "</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"created"</span>: <span class="string">"2020-06-07T01:59:47.348924716Z"</span>,</span><br><span class="line">      <span class="attr">"created_by"</span>: <span class="string">"/bin/sh -c #(nop)  CMD [\"bash\"]"</span>,</span><br><span class="line">      <span class="attr">"empty_layer"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"os"</span>: <span class="string">"linux"</span>,</span><br><span class="line">  <span class="attr">"rootfs"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"layers"</span>,</span><br><span class="line">    <span class="attr">"diff_ids"</span>: [</span><br><span class="line">      <span class="string">"sha256:d1b85e6186f67d9925c622a7a6e66faa447e767f90f65ae47cdc817c629fa956"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h4><p><a href="https://github.com/opencontainers/image-spec/blob/master/manifest.md" target="_blank" rel="noopener">manifest 文件</a> ：镜像的 config 文件索引，有哪些 layer，额外的 annotation 信息，manifest 文件中保存了很多和当前平台有关的信息。另外 manifest 中的 layer 和 config 中的 layer 表达的虽然都是镜像的 layer ，但二者代表的意义不太一样，稍后会讲到。manifest 文件是存放在 registry 中，当我们拉取镜像的时候，会根据该文件拉取相应的 layer 。根据 OCI image-spec 规范中 <a href="https://github.com/opencontainers/image-spec/blob/master/manifest.md" target="_blank" rel="noopener">OCI Image Manifest Specification</a> 的定义可以得知，镜像的 manifest 文件主要有以下三个目标：（英语不好就不翻译了😥</p><blockquote><p>There are three main goals of the Image Manifest Specification.</p><ul><li>The first goal is content-addressable images, by supporting an image model where the image’s configuration can be hashed to generate a unique ID for the image and its components.</li><li>The second goal is to allow multi-architecture images, through a “fat manifest” which references image manifests for platform-specific versions of an image. In OCI, this is codified in an <a href="https://github.com/opencontainers/image-spec/blob/master/image-index.md" target="_blank" rel="noopener">image index</a>.</li><li>The third goal is to be <a href="https://github.com/opencontainers/image-spec/blob/master/conversion.md" target="_blank" rel="noopener">translatable</a> to the <a href="https://github.com/opencontainers/runtime-spec" target="_blank" rel="noopener">OCI Runtime Specification</a>.</li></ul></blockquote><p>另外 manifest 也分好几个版本，目前主流的版本是  <code>Manifest Version 2, Schema 2</code> ，可以参考 docker 的官方文档 <a href="https://github.com/docker/distribution/blob/master/docs/spec/manifest-v2-2.md" target="_blank" rel="noopener">Image Manifest Version 2, Schema 2</a> 。registry 中会有个 <code>Manifest List</code> 文件，该文件是为不同处理器体系架构而设计的，通过该文件指向与该处理器体系架构相对应的 Image Manifest ，这一点不要搞混。</p><ul><li>Example Manifest List</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"schemaVersion"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.distribution.manifest.list.v2+json"</span>,</span><br><span class="line">  <span class="attr">"manifests"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.distribution.manifest.v2+json"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">7143</span>,</span><br><span class="line">      <span class="attr">"digest"</span>: <span class="string">"sha256:e692418e4cbaf90ca69d05a66403747baa33ee08806650b51fab815ad7fc331f"</span>,</span><br><span class="line">      <span class="attr">"platform"</span>: &#123;</span><br><span class="line">        <span class="attr">"architecture"</span>: <span class="string">"ppc64le"</span>,</span><br><span class="line">        <span class="attr">"os"</span>: <span class="string">"linux"</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.distribution.manifest.v2+json"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">7682</span>,</span><br><span class="line">      <span class="attr">"digest"</span>: <span class="string">"sha256:5b0bcabd1ed22e9fb1310cf6c2dec7cdef19f0ad69efa1f392e94a4333501270"</span>,</span><br><span class="line">      <span class="attr">"platform"</span>: &#123;</span><br><span class="line">        <span class="attr">"architecture"</span>: <span class="string">"amd64"</span>,</span><br><span class="line">        <span class="attr">"os"</span>: <span class="string">"linux"</span>,</span><br><span class="line">        <span class="attr">"features"</span>: [</span><br><span class="line">          <span class="string">"sse4"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Image Manifest</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "schemaVersion": 2,</span><br><span class="line">  "mediaType": "application/vnd.docker.distribution.manifest.v2+json",</span><br><span class="line">  "config": &#123;</span><br><span class="line">    "mediaType": "application/vnd.docker.container.image.v1+json",</span><br><span class="line">    "size": 1509,</span><br><span class="line">    "digest": "sha256:a24bb4013296f61e89ba57005a7b3e52274d8edd3ae2077d04395f806b63d83e"</span><br><span class="line">  &#125;,</span><br><span class="line">  "layers": [</span><br><span class="line">    &#123;</span><br><span class="line">      "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",</span><br><span class="line">      "size": 5844992,</span><br><span class="line">      "digest": "sha256:50644c29ef5a27c9a40c393a73ece2479de78325cae7d762ef3cdc19bf42dd0a"</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再补充一段高策大佬的 <a href="http://gaocegege.com/Blog/ormb" target="_blank" rel="noopener">解释</a> ：</p><blockquote><p>Manifest 是一个 JSON 文件，其定义包括两个部分，分别是 <a href="https://github.com/opencontainers/image-spec/blob/master/config.md" target="_blank" rel="noopener">Config</a> 和 <a href="https://github.com/opencontainers/image-spec/blob/master/layer.md" target="_blank" rel="noopener">Layers</a>。Config 是一个 JSON 对象，Layers 是一个由 JSON 对象组成的数组。可以看到，Config 与 Layers 中的每一个对象的结构相同，都包括三个字段，分别是 digest、mediaType 和 size。其中 digest 可以理解为是这一对象的 ID。mediaType 表明了这一内容的类型。size 是这一内容的大小。</p><p>容器镜像的 Config 有着固定的 mediaType <code>application/vnd.oci.image.config.v1+json</code>。一个 Config 的示例配置如下，它记录了关于容器镜像的配置，可以理解为是镜像的元数据。通常它会被镜像仓库用来在 UI 中展示信息，以及区分不同操作系统的构建等。</p><p>而容器镜像的 Layers 是由多层 mediaType 为 <code>application/vnd.oci.image.layer.v1.*</code>（其中最常见的是 <code>application/vnd.oci.image.layer.v1.tar+gzip</code>) 的内容组成的。众所周知，容器镜像是分层构建的，每一层就对应着 Layers 中的一个对象。</p><p>容器镜像的 Config，和 Layers 中的每一层，都是以 Blob 的方式存储在镜像仓库中的，它们的 digest 作为 Key 存在。因此，在请求到镜像的 Manifest 后，Docker 会利用 digest 并行下载所有的 Blobs，其中就包括 Config 和所有的 Layers。</p></blockquote><h4 id="image-manifest-index"><a href="#image-manifest-index" class="headerlink" title="image manifest index"></a>image manifest index</h4><p><a href="https://github.com/opencontainers/image-spec/blob/master/image-index.md" target="_blank" rel="noopener">index 文件</a> ：其实就是我们上面提到的 Manifest List 啦。在 docker 的 <a href="https://github.com/docker/distribution" target="_blank" rel="noopener">distribution</a> 中称之为 <code>Manifest List</code> 在 OCI 中就叫 <a href="https://github.com/opencontainers/image-spec/blob/master/image-index.md" target="_blank" rel="noopener">OCI Image Index Specification</a> 。其实两者是指的同一个文件，甚至两者 GitHub 上文档给的 example 都一一模样🤣，应该是 OCI 复制粘贴 Docker 的文档😂。index 文件是个可选的文件，包含着一个列表为同一个镜像不同的处理器 arch 指向不同平台的 manifest 文件，这个文件能保证一个镜像可以跨平台使用，每个处理器 arch 平台拥有不同的 manifest 文件，使用 index 作为索引。当我们使用 arm 架构的处理器时要额外注意，在拉取镜像的时候要拉取 arm 架构的镜像，一般处理器的架构都接在镜像的 tag 后面，默认 latest tag 的镜像是 x86 的，在 arm 处理器的机器这些镜像上是跑不起来的。</p><h3 id="各种-id-分不清？"><a href="#各种-id-分不清？" class="headerlink" title="各种 id 分不清？"></a>各种 id 分不清？</h3><p>看完  <a href="http://www.github.com/opencontainers/image-spec" target="_blank" rel="noopener">image-spec</a> 里面提到的各种 id 相信你又很多疑惑，在此总结一下这些 id 的作用：</p><table><thead><tr><th align="center">image-id</th><th>image config 的 sha256 哈希值，在本地镜像存储中由它唯一标识一个镜像</th></tr></thead><tbody><tr><td align="center">image digest</td><td>在 registry 中的 image manifest 的 sha256 哈希值，在 registry 中由它唯一标识一个镜像</td></tr><tr><td align="center">diff_ids</td><td>镜像每一层的 id ，是对 layer 的未压缩的 tar 包的 sha256 哈希值</td></tr><tr><td align="center">layer digest</td><td>镜像在 registry 存储中的 id ，是对 layer压缩后的 tar 包的 sha256 哈希值</td></tr></tbody></table><p>镜像的 image config 中的 <code>rootfs</code> 字段记录了每一层 layer 的 id，而镜像的 layer id 则是 layer tar 包的 sha256 值，如果镜像的 layer 改变，则这个 layer id 会改变，而记录它的 image config 内容也会改变，image config 内容变了，image config 文件的 sha256 值也就会改变，这样就可以由 image id 和 image digest 唯一标识一个镜像，达到防治篡改的安全目的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"rootfs": &#123;</span><br><span class="line">    "type": "layers",</span><br><span class="line">    "diff_ids": [</span><br><span class="line">      <span class="string">"sha256:d1b85e6186f67d9925c622a7a6e66faa447e767f90f65ae47cdc817c629fa956"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>众所周知 docker 镜像需要一个 Dockerfile 来构建而成，当我们对 OCI 镜像规范有了个大致的了解之后，我们接下来就拿着 Dockerfile 这个 ”图纸“ 去一步步构建镜像。本文不再细讲 Dockerfile 的详细书写和技巧，网上也有很多众所周知的关于写好 Dockerfile 的技巧，比如我之前水过的一篇 <a href="https://blog.k8s.li/dockerfile-tips.html">Dockerfile 搓镜像的小技巧</a> 。</p><p>下面就是 <a href="https://webp.sh" target="_blank" rel="noopener">webp server go</a> Dockerfile 的例子：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:alpine as builder</span><br><span class="line"><span class="keyword">ARG</span> IMG_PATH=/opt/pics</span><br><span class="line"><span class="keyword">ARG</span> EXHAUST_PATH=/opt/exhaust</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk update ;\</span></span><br><span class="line"><span class="bash">    apk add alpine-sdk ;\</span></span><br><span class="line"><span class="bash">    git <span class="built_in">clone</span> https://github.com/webp-sh/webp_server_go /build ;\</span></span><br><span class="line"><span class="bash">    <span class="built_in">cd</span> /build ;\</span></span><br><span class="line"><span class="bash">    sed -i <span class="string">"s|.\/pics|<span class="variable">$&#123;IMG_PATH&#125;</span>|g"</span> config.json ;\</span></span><br><span class="line"><span class="bash">    sed -i <span class="string">"s|\"\"|\"<span class="variable">$&#123;EXHAUST_PATH&#125;</span>\"|g"</span> config.json ;\</span></span><br><span class="line"><span class="bash">    sed -i <span class="string">'s/127.0.0.1/0.0.0.0/g'</span> config.json</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /build</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go build -o webp-server .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /build/webp-server  /usr/bin/webp-server</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /build/config.json /etc/config.json</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /opt</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /opt/exhaust</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/usr/bin/webp-server"</span>, <span class="string">"--config"</span>, <span class="string">"/etc/config.json"</span>]</span></span><br></pre></td></tr></table></figure><p>需要注意的是，在 RUN 指令的每行结尾我使用的是 <code>;\</code> 来接下一行 shell ，另一种写法是 <code>&amp;&amp;</code> 。二者有本质的区别，比如 COMMAND 1;COMMAND 2 ，当 COMMAND 1 运行失败时会继续运行 COMMAND2 ，并不会退出。而 COMMAND 1&amp;&amp; COMMAND 2，时 COMMAND 1 运行成功时才接着运行 COMMAND 2 ，COMMAND 1 运行失败会退出。如果没有十足的把握保证每一行 shell 都能每次运行成功建议用 <code>&amp;&amp;</code> ，这样失败了就退出构建镜像，不然构建出来的镜像会有问题。如果是老司机🚗 的话建议用 <code>;</code> ，逛了一圈 docker hub 官方镜像中用 <code>;</code> 较多一些，因为 <code>;</code> 比 <code>&amp;&amp;</code> 要美观一些（大雾😂。</p><ul><li>风格一：比如 <a href="https://github.com/nginxinc/docker-nginx/blob/master/stable/buster/Dockerfile" target="_blank" rel="noopener">nginx</a> 官方镜像是用的 <code>&amp;&amp;</code>，貌似也混入了 <code>;</code>🤣</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RUN set -x \</span><br><span class="line"><span class="meta">#</span><span class="bash"> create nginx user/group first, to be consistent throughout docker variants</span></span><br><span class="line">    &amp;&amp; addgroup --system --gid 101 nginx \</span><br><span class="line">    &amp;&amp; adduser --system --disabled-login --ingroup nginx --no-create-home --home /nonexistent --gecos "nginx user" --shell /bin/false --uid 101 nginx \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install --no-install-recommends --no-install-suggests -y gnupg1 ca-certificates \</span><br><span class="line">    &amp;&amp; \</span><br><span class="line">    NGINX_GPGKEY=573BFD6B3D8FBC641079A6ABABF5BD827BD9BF62; \</span><br><span class="line">    found=''; \</span><br><span class="line">    for server in \</span><br><span class="line">        ha.pool.sks-keyservers.net \</span><br><span class="line">        hkp://keyserver.ubuntu.com:80 \</span><br><span class="line">        hkp://p80.pool.sks-keyservers.net:80 \</span><br><span class="line">        pgp.mit.edu \</span><br><span class="line">    ; do \</span><br></pre></td></tr></table></figure><ul><li>风格二：比如 <a href="https://github.com/docker-library/redis/blob/23af5b6adb271bcebbcebc93308884438512a4af/6.0/Dockerfile" target="_blank" rel="noopener">redis</a> 官方镜像就清一色使用的 <code>;</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RUN set -eux; \</span><br><span class="line">savedAptMark="$(apt-mark showmanual)"; \</span><br><span class="line">apt-get update; \</span><br><span class="line">apt-get install -y --no-install-recommends ca-certificates dirmngr gnupg wget; \</span><br><span class="line">rm -rf /var/lib/apt/lists/*; \</span><br><span class="line">dpkgArch="$(dpkg --print-architecture | awk -F- '&#123; print $NF &#125;')"; \</span><br><span class="line">wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$dpkgArch"; \</span><br><span class="line">wget -O /usr/local/bin/gosu.asc "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$dpkgArch.asc"; \</span><br><span class="line">export GNUPGHOME="$(mktemp -d)"; \</span><br><span class="line">gpg --batch --keyserver hkps://keys.openpgp.org --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4; \</span><br><span class="line">gpg --batch --verify /usr/local/bin/gosu.asc /usr/local/bin/gosu; \</span><br><span class="line">gpgconf --kill all; \</span><br><span class="line">rm -rf "$GNUPGHOME" /usr/local/bin/gosu.asc; \</span><br><span class="line">apt-mark auto '.*' &gt; /dev/null; \</span><br><span class="line">[ -z "$savedAptMark" ] || apt-mark manual $savedAptMark &gt; /dev/null; \</span><br><span class="line">apt-get purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant=false; \</span><br><span class="line">chmod +x /usr/local/bin/gosu; \</span><br><span class="line">gosu --version; \</span><br><span class="line">gosu nobody true</span><br></pre></td></tr></table></figure><p>汝喜欢哪种风格呢？快在评论区留言吧😋</p><h4 id="镜像工厂🛠"><a href="#镜像工厂🛠" class="headerlink" title="镜像工厂🛠"></a>镜像工厂🛠</h4><blockquote><p>Docker 是一个典型的 C/S 架构的应用，分为 Docker 客户端（即平时敲的 docker 命令） Docker 服务端（dockerd 守护进程）。</p><p>Docker 客户端通过 REST API 和服务端进行交互，docker 客户端每发送一条指令，底层都会转化成 REST API 调用的形式发送给服务端，服务端处理客户端发送的请求并给出响应。</p><p>Docker 镜像的构建、容器创建、容器运行等工作都是 Docker 服务端来完成的，Docker 客户端只是承担发送指令的角色。</p><p>Docker 客户端和服务端可以在同一个宿主机，也可以在不同的宿主机，如果在同一个宿主机的话，Docker 客户端默认通过 UNIX 套接字(<code>/var/run/docker.sock</code>)和服务端通信。</p></blockquote><p>类比于钢铁是怎样炼成的，如果说炼制镜像也需要个工厂的话，那么我们的 dockerd 这个守护进程就是个生产镜像的工厂。能生产镜像的不止 docker 一家，红帽子家的 <a href="https://buildah.io/" target="_blank" rel="noopener">buildah</a> 也能生产镜像，不过用的人并不多。二者的最大区别在于 buildah 可以不用 root 权限来构建镜像，而使用 docker 构建镜像时需要用到 root 权限，没有 root 权限的用户构建镜像会当场翻车。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock:</span><br></pre></td></tr></table></figure><p>不过 buildah 构建出来的镜像有一堆堆的兼容性问题，所以我们还是使用 docker 来构建镜像吧。当我们使用 docker build 命令构建一个镜像的时候第一行日志就是 <code>Sending build context to Docker daemon xx MB</code>。这一步是 docker cli 这个命令行客户端将我们当前目录（即构建上下文） <code>build context</code> 打包发送 <code>Docker daemon</code> 守护进程 （即 dockerd）的过程。</p><p><img src="img/docker-architecture.png" alt="img"></p><p>docker build 构建镜像的流程大概就是：</p><ul><li>执行 <code>docker build -t &lt;imageName:Tag&gt; .</code>，可以使用 <code>-f</code>参数来指定 Dockerfile 文件；</li><li>docker 客户端会将构建命令后面指定的路径(<code>.</code>)下的所有文件打包成一个 tar 包，发送给 Docker 服务端;</li><li>docker 服务端收到客户端发送的 tar 包，然后解压，接下来根据 Dockerfile 里面的指令进行镜像的分层构建；</li><li>docker 下载 FROM 语句中指定的基础镜像，然后将基础镜像的 layer 联合挂载为一层，并在上面创建一个空目录；</li><li>接着启动一个临时的容器并在 chroot 中启动一个 bash，运行 <code>RUN</code> 语句中的命令：<code>RUN: chroot . /bin/bash -c &quot;apt get update……&quot;</code>；</li><li>一条 <code>RUN</code> 命令结束后，会把上层目录压缩，形成新镜像中的新的一层；</li><li>如果 Dockerfile 中包含其它命令，就以之前构建的层次为基础，从第二步开始重复创建新层，直到完成所有语句后退出；</li><li>构建完成之后为该镜像打上 tag；</li></ul><p>以上就是构建镜像的大致流程，我们也可以通过 <code>docker history &lt;imageName:Tag&gt;</code> 命令来逆向推算出 docker build 的过程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 ~/buster/slim</span><br><span class="line">╰─# docker history webpsh/webps</span><br><span class="line">IMAGE               CREATED             CREATED BY          SIZE                COMMENT</span><br><span class="line">30d9679b0b1c        2 weeks ago         /bin/sh -c #(nop)  CMD ["/usr/bin/webp-serve…   0B</span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop)  VOLUME [/opt/exhaust]        0B</span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop) WORKDIR /opt                  0B</span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop) COPY file:1497d882aeef5f77…   168B</span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop) COPY file:327020918e4dc998…   14.9MB</span><br><span class="line">&lt;missing&gt;           6 weeks ago         /bin/sh -c #(nop)  CMD ["/bin/sh"]              0B</span><br><span class="line">&lt;missing&gt;           6 weeks ago         /bin/sh -c #(nop) ADD file:b91adb67b670d3a6f…   5.61MB</span><br><span class="line"></span><br><span class="line">╭─root@sg-02 ~/buster/slim</span><br><span class="line">╰─# docker history debian:v2</span><br><span class="line">IMAGE               CREATED             CREATED BY           SIZE                COMMENT</span><br><span class="line">e6e782a57a51        38 hours ago        /bin/sh -c #(nop)  CMD ["bash"]                 0B</span><br><span class="line">ba8f577813c7        38 hours ago        /bin/sh -c #(nop) ADD file:a82014afc29e7b364…   69.2MB</span><br></pre></td></tr></table></figure><h4 id="base-image"><a href="#base-image" class="headerlink" title="base image"></a>base image</h4><p>当我们在写 Dockerfile 的时候都需要用 <code>FROM</code> 语句来指定一个基础镜像，这些基础镜像并不是无中生有，也需要一个 Dockerfile 来构建成镜像。下面我们拿来 <a href="https://hub.docker.com/_/debian" target="_blank" rel="noopener">debian:buster</a> 这个基础镜像的 <a href="https://github.com/debuerreotype/docker-debian-artifacts/blob/18cb4d0418be1c80fb19141b69ac2e0600b2d601/buster/Dockerfile" target="_blank" rel="noopener">Dockerfile</a> 来看一下基础镜像是如何炼成的。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> rootfs.tar.xz /</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"bash"</span>]</span></span><br></pre></td></tr></table></figure><p>一个基础镜像的 Dockerfile 一般仅有三行。第一行 <code>FROM scratch</code> 中的<code>scratch</code> 这个镜像并不真实的存在。当你使用 <code>docker pull scratch</code> 命令来拉取这个镜像的时候会翻车哦，提示 <code>Error response from daemon: &#39;scratch&#39; is a reserved name</code>。这是因为自从 docker 1.5 版本开始，在 Dockerfile 中 <code>FROM scratch</code> 指令并不进行任何操作，也就是不会创建一个镜像层；接着第二行的 <code>ADD rootfs.tar.xz /</code> 会自动把 <code>rootfs.tar.xz</code>  解压到 <code>/</code> 目录下，由此产生的一层镜像就是最终构建的镜像真实的 layer 内容；第三行 <code>CMD [&quot;bash&quot;]</code> 指定这镜像在启动容器的时候执行的应用程序，一般基础镜像的 CMD 默认为 bash 或者 sh 。</p><blockquote><p>As of Docker 1.5.0 (specifically, <a href="https://github.com/docker/docker/pull/8827" target="_blank" rel="noopener"><code>docker/docker#8827</code></a>), <code>FROM scratch</code> is a no-op in the Dockerfile , and will not create an extra layer in your image (so a previously 2-layer image will be a 1-layer image instead).</p></blockquote><p><code>ADD rootfs.tar.xz /</code> 中，这个 <code>rootfs.tar.xz</code> 就是我们经过一系列骚操作（一般是发行版源码编译）搓出来的根文件系统，这个操作比较复杂，木子太菜了🥬就不在这里瞎掰掰了🙃，如果汝对源码构建 <code>rootfs.tar.xz</code> 这个过程感兴趣可以去看一下构建 debian 基础镜像的 Jenkins 流水线任务 <a href="https://doi-janky.infosiftr.net/job/tianon/job/debuerreotype/" target="_blank" rel="noopener">debuerreotype</a>，上面有构建这个 <code>rootfs.tar.xz</code> 完整过程，或者参考 Debian 官方的 <a href="https://github.com/debuerreotype/docker-debian-artifacts" target="_blank" rel="noopener">docker-debian-artifacts</a> 这个 repo 里的 shell 脚本。</p><p>需要额外注意一点，在这里往镜像里添加 <code>rootfs.tar.xz</code> 时使用的是 <code>ADD</code> 而不是 <code>COPY</code> ，因为在 Dockerfile 中的 ADD 指令 src 文件如果是个 tar 包，在构建的时候 docker 会帮我们把 tar 包解开到指定目录，使用 copy 指令则不会解开 tar 包。另外一点区别就是 ADD 指令是添加一个文件，这个文件可以是构建上下文环境中的文件，也可以是个 URL，而 COPY 则只能添加构建上下文中的文件，所谓的构建上下文就是我们构建镜像的时候最后一个参数啦。</p><blockquote><p>PS：面试的时候经常被问 ADD 与 COPY 的区别；CMD 与 ENTRYPOINT 的区别😂。</p></blockquote><p>搓这个 <code>rootfs.tar.xz</code> 不同的发行版方法可能不太一样，Debian 发行版的 <code>rootfs.tar.xz</code> 可以在 <a href="https://github.com/debuerreotype/docker-debian-artifacts" target="_blank" rel="noopener">docker-debian-artifacts</a> 这个 repo 上找到，根据不同处理器 arch 选择相应的 branch ，然后这个 branch 下的目录就对应着该发行版的不同的版本的代号。意外发现 Debian 官方是将所有 arch 和所有版本的 <code>rootfs.tar.xz</code> 都放在这个 repo 里的，以至于这个 repo 的大小接近 2.88 GiB 😨，当网盘来用的嘛🤣（：手动滑稽</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 ~</span><br><span class="line">╰─# git clone https://github.com/debuerreotype/docker-debian-artifacts</span><br><span class="line">Cloning into 'docker-debian-artifacts'...</span><br><span class="line">remote: Enumerating objects: 278, done.</span><br><span class="line">remote: Counting objects: 100% (278/278), done.</span><br><span class="line">Receiving objects:  67% (443/660), 1.60 GiB | 16.96 MiB/s</span><br><span class="line">remote: Total 660 (delta 130), reused 244 (delta 97), pack-reused 382</span><br><span class="line">Receiving objects: 100% (660/660), 2.88 GiB | 16.63 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (267/267), done.</span><br></pre></td></tr></table></figure><p>我们把这个 <code>rootfs.tar.xz</code> 解开就可以看到，这就是一个 Linux 的根文件系统，不同于我们使用 ISO 安装系统的那个根文件系统，这个根文件系统是经过一系列的裁剪，去掉了一些在容器运行中不必要的文件，使之更加轻量适用于容器运行的场景，整个根文件系统的大小为 125M，如果使用 slim 的<code>rootfs.tar.xz</code> 会更小一些，仅仅 76M。当然相比于仅仅几 M 的 <code>alpine</code> ，这算是够大的了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 ~/docker-debian-artifacts/buster ‹dist-amd64*›</span><br><span class="line">╰─# git checkout dist-amd64</span><br><span class="line">╭─root@sg-02 ~/docker-debian-artifacts/buster ‹dist-amd64*›</span><br><span class="line">╰─# cd buster</span><br><span class="line">╭─root@sg-02 ~/docker-debian-artifacts/buster ‹dist-amd64*›</span><br><span class="line">╰─# mkdir rootfs</span><br><span class="line">╭─root@sg-02 ~/docker-debian-artifacts/buster ‹dist-amd64*›</span><br><span class="line">╰─# tar -xvf rootfs.tar.xz -C !$</span><br><span class="line">╭─root@sg-02 ~/docker-debian-artifacts/buster ‹dist-amd64*›</span><br><span class="line">╰─# ls rootfs/</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">╭─root@sg-02 ~/docker-debian-artifacts/buster ‹dist-amd64*›</span><br><span class="line">╰─# du -sh rootfs</span><br><span class="line">125M    rootfs</span><br><span class="line">╭─root@sg-02 ~/docker-debian-artifacts/buster ‹dist-amd64*›</span><br><span class="line">╰─# du -sh slim/rootfs</span><br><span class="line">76M     slim/rootfs</span><br></pre></td></tr></table></figure><p>想要自己构建一个 <code>debian:buster</code> 基础镜像其实很简单，就像下面这样一把梭操作下来就行😂：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/debuerreotype/docker-debian-artifacts debian</span><br><span class="line">cd !$</span><br><span class="line">git checkout dist-amd64</span><br><span class="line">cd buster</span><br><span class="line">docker build -t debian:buster .</span><br></pre></td></tr></table></figure><p>下面就是构建 Debian 基础镜像的过程，正如 Dockerfile 中的那样，最终只产生了一层镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker build -t debian:buster .</span><br><span class="line">Sending build context to Docker daemon  30.12MB</span><br><span class="line">Step 1/3 : FROM scratch</span><br><span class="line"><span class="meta"> ---&gt;</span></span><br><span class="line">Step 2/3 : ADD rootfs.tar.xz /</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 1756d6a585ae</span></span><br><span class="line">Step 3/3 : CMD ["bash"]</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> c86a8b6deb3d</span></span><br><span class="line">Removing intermediate container c86a8b6deb3d</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 04948daa3c2e</span></span><br><span class="line">Successfully built 04948daa3c2e</span><br><span class="line">Successfully tagged debian:buster</span><br></pre></td></tr></table></figure><h2 id="镜像是怎样存放的-（一）本地存储-🙄"><a href="#镜像是怎样存放的-（一）本地存储-🙄" class="headerlink" title="镜像是怎样存放的 （一）本地存储 🙄"></a>镜像是怎样存放的 （一）本地存储 🙄</h2><p>当我们构建完一个镜像之后，镜像就存储在了我们 docker 本地存储目录，默认情况下为 <code>/var/lib/docker</code> ，下面就探寻一下镜像是以什么样的目录结构存放的。在开始 hack 之前我们先统一一下环境信息，我使用的机器是 Ubuntu 1804，<code>docker info</code> 信息如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">╭─root@sg-02</span> <span class="string">/var/lib/docker</span></span><br><span class="line"><span class="string">╰─#</span> <span class="string">docker</span> <span class="string">info</span></span><br><span class="line"><span class="attr">Client:</span></span><br><span class="line"> <span class="attr">Debug Mode:</span> <span class="literal">false</span></span><br><span class="line"> <span class="attr">Plugins:</span></span><br><span class="line">  <span class="attr">buildx:</span> <span class="string">Build</span> <span class="string">with</span> <span class="string">BuildKit</span> <span class="string">(Docker</span> <span class="string">Inc.,</span> <span class="string">v0.3.1-tp-docker)</span></span><br><span class="line">  <span class="attr">app:</span> <span class="string">Docker</span> <span class="string">Application</span> <span class="string">(Docker</span> <span class="string">Inc.,</span> <span class="string">v0.8.0)</span></span><br><span class="line"><span class="attr">Server:</span></span><br><span class="line"> <span class="attr">Containers:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">Running:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">Paused:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">Stopped:</span> <span class="number">0</span></span><br><span class="line"> <span class="attr">Images:</span> <span class="number">2</span></span><br><span class="line"> <span class="attr">Server Version:</span> <span class="number">19.03</span><span class="number">.5</span></span><br><span class="line"> <span class="attr">Storage Driver:</span> <span class="string">overlay2</span></span><br><span class="line">  <span class="attr">Backing Filesystem:</span> <span class="string">extfs</span></span><br><span class="line">  <span class="attr">Supports d_type:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">Native Overlay Diff:</span> <span class="literal">true</span></span><br><span class="line"> <span class="attr">Logging Driver:</span> <span class="string">json-file</span></span><br><span class="line"> <span class="attr">Cgroup Driver:</span> <span class="string">cgroupfs</span></span><br><span class="line"> <span class="attr">Plugins:</span></span><br><span class="line">  <span class="attr">Volume:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">Network:</span> <span class="string">bridge</span> <span class="string">host</span> <span class="string">ipvlan</span> <span class="string">macvlan</span> <span class="literal">null</span> <span class="string">overlay</span></span><br><span class="line">  <span class="attr">Log:</span> <span class="string">awslogs</span> <span class="string">fluentd</span> <span class="string">gcplogs</span> <span class="string">gelf</span> <span class="string">journald</span> <span class="string">json-file</span> <span class="string">local</span> <span class="string">logentries</span> <span class="string">splunk</span> <span class="string">syslog</span></span><br><span class="line"> <span class="attr">Swarm:</span> <span class="string">inactive</span></span><br><span class="line"> <span class="attr">Runtimes:</span> <span class="string">runc</span></span><br><span class="line"> <span class="attr">Default Runtime:</span> <span class="string">runc</span></span><br><span class="line"> <span class="attr">Init Binary:</span> <span class="string">docker-init</span></span><br><span class="line"> <span class="attr">containerd version:</span> <span class="string">b34a5c8af56e510852c35414db4c1f4fa6172339</span></span><br><span class="line"> <span class="attr">runc version:</span> <span class="string">3e425f80a8c931f88e6d94a8c831b9d5aa481657</span></span><br><span class="line"> <span class="attr">init version:</span> <span class="string">fec3683</span></span><br><span class="line"> <span class="attr">Security Options:</span></span><br><span class="line">  <span class="string">apparmor</span></span><br><span class="line">  <span class="string">seccomp</span></span><br><span class="line">   <span class="attr">Profile:</span> <span class="string">default</span></span><br><span class="line"> <span class="attr">Kernel Version:</span> <span class="number">4.15</span><span class="number">.0</span><span class="number">-1052</span><span class="string">-aws</span></span><br><span class="line"> <span class="attr">Operating System:</span> <span class="string">Ubuntu</span> <span class="number">18.04</span><span class="number">.1</span> <span class="string">LTS</span></span><br><span class="line"> <span class="attr">OSType:</span> <span class="string">linux</span></span><br><span class="line"> <span class="attr">Architecture:</span> <span class="string">x86_64</span></span><br><span class="line"> <span class="attr">CPUs:</span> <span class="number">1</span></span><br><span class="line"> <span class="attr">Total Memory:</span> <span class="number">983.</span><span class="string">9MiB</span></span><br><span class="line"> <span class="attr">Name:</span> <span class="string">sg-02</span></span><br><span class="line"> <span class="attr">ID:</span> <span class="string">B7J5:Y7ZM:Y477:7AS6:WMYI:6NLV:YOMA:W32Y:H4NZ:UQVD:XHDX:Y5EF</span></span><br><span class="line"> <span class="attr">Docker Root Dir:</span> <span class="string">/opt/docker</span></span><br><span class="line"> <span class="attr">Debug Mode:</span> <span class="literal">false</span></span><br><span class="line"> <span class="attr">Username:</span> <span class="string">webpsh</span></span><br><span class="line"> <span class="attr">Registry:</span> <span class="string">https://index.docker.io/v1/</span></span><br><span class="line"> <span class="attr">Labels:</span></span><br><span class="line"> <span class="attr">Experimental:</span> <span class="literal">false</span></span><br><span class="line"> <span class="attr">Insecure Registries:</span></span><br><span class="line">  <span class="number">127.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/8</span></span><br><span class="line"> <span class="attr">Registry Mirrors:</span></span><br><span class="line">  <span class="string">https://registry.k8s.li/</span></span><br><span class="line"> <span class="attr">Live Restore Enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>为了方便分析，我将其他的 docker image 全部清空掉，只保留 <code>debian:v1</code> 和 <code>debian:v2</code> 这两个镜像，这两个镜像足够帮助我们理解容器镜像是如何存放的，镜像多了多话分析下面存储目录的时候可能不太方便（＞﹏＜），这两个镜像是我们之前使用 Debian 的 <code>rootfs.tar.xz</code> 构建出来的基础镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/docker</span><br><span class="line">╰─# docker images</span><br><span class="line">REPOSITORY       TAG         IMAGE ID            CREATED             SIZE</span><br><span class="line">debian           v2          e6e782a57a51        22 hours ago        69.2MB</span><br><span class="line">debian           v1          cfba37fd24f8        22 hours ago        69.2MB</span><br></pre></td></tr></table></figure><h3 id="docker-var-lib-docker"><a href="#docker-var-lib-docker" class="headerlink" title="docker (/var/lib/docker)"></a>docker (/var/lib/docker)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/docker</span><br><span class="line">╰─# tree -d -L 1</span><br><span class="line">.</span><br><span class="line">├── builder</span><br><span class="line">├── buildkit</span><br><span class="line">├── containers</span><br><span class="line">├── image</span><br><span class="line">├── network</span><br><span class="line">├── overlay2</span><br><span class="line">├── plugins</span><br><span class="line">├── runtimes</span><br><span class="line">├── swarm</span><br><span class="line">├── tmp</span><br><span class="line">├── trust</span><br><span class="line">└── volumes</span><br><span class="line"></span><br><span class="line">12 directories</span><br></pre></td></tr></table></figure><p>根据目录的名字我们可以大致推断出关于容器镜像的存储，我们只关心 image 和 overlay2 这两个文件夹即可，容器的元数据存放在 image 目录下，容器的 layer 数据则存放在 overlay2 目录下。</p><h3 id="var-lib-docker-image"><a href="#var-lib-docker-image" class="headerlink" title="/var/lib/docker/image"></a>/var/lib/docker/image</h3><p>overlay2 代表着本地 docker 存储使用的是 overlay2 该存储驱动，目前最新版本的 docker 默认优先采用 <strong>overlay2</strong> 作为存储驱动，对于已支持该驱动的 Linux 发行版，不需要任何进行任何额外的配置，可使用 lsmod 命令查看当前系统内核是否支持 overlay2 。</p><p>另外值得一提的是<code>devicemapper</code> 存储驱动已经在 docker 18.09 版本中被废弃，docker 官方推荐使用 <code>overlay2</code> 替代<code>devicemapper</code>。（之前我老东家用的 docker 1.13 版本，<code>devicemapper</code>的存储驱动在生产环境翻过车😂。所以呢，都 2020 年了，当你使用 baidu 这种垃圾搜素引擎去搜索 “CentOS 安装 docker” 时它会给你一堆垃圾的教程，叫你去安装 <code>device-mapper-persistent-data lvm2</code>，对于这种抄来抄去的博客平台，离得越远越好。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">image</span><br><span class="line">└── overlay2</span><br><span class="line">    ├── distribution</span><br><span class="line">    │   ├── diffid-by-digest</span><br><span class="line">    │   │   └── sha256</span><br><span class="line">    │   │       ├── 039b991354af4dcbc534338f687e27643c717bb57e11b87c2e81d50bdd0b2376</span><br><span class="line">    │   │       ├── 09a4142c5c9dde2fbf35e7a6e6475eba75a8c28540c375c80be7eade4b7cb438</span><br><span class="line">    │   └── v2metadata-by-diffid</span><br><span class="line">    │       └── sha256</span><br><span class="line">    │           ├── 0683de2821778aa9546bf3d3e6944df779daba1582631b7ea3517bb36f9e4007</span><br><span class="line">    │           ├── 0f7493e3a35bab1679e587b41b353b041dca1e7043be230670969703f28a1d83</span><br><span class="line">    ├── imagedb</span><br><span class="line">    │   ├── content</span><br><span class="line">    │   │   └── sha256</span><br><span class="line">    │   │       ├── 708bc6af7e5e539bdb59707bbf1053cc2166622f5e1b17666f0ba5829ca6aaea</span><br><span class="line">    │   │       └── f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a</span><br><span class="line">    │   └── metadata</span><br><span class="line">    │       └── sha256</span><br><span class="line">    ├── layerdb</span><br><span class="line">    │   ├── mounts</span><br><span class="line">    │   ├── sha256</span><br><span class="line">    │   │   ├── b9835d6a62886d4e85b65abb120c0ea44ff1b3d116d7a707620785d4664d8c1a</span><br><span class="line">    │   │   │   ├── cache-id</span><br><span class="line">    │   │   │   ├── diff</span><br><span class="line">    │   │   │   ├── parent</span><br><span class="line">    │   │   │   ├── size</span><br><span class="line">    │   │   │   └── tar-split.json.gz</span><br><span class="line">    │   │   └── d9b567b77bcdb9d8944d3654ea9bb5f6f4f7c4d07a264b2e40b1bb09af171dd3</span><br><span class="line">    │   │       ├── cache-id</span><br><span class="line">    │   │       ├── diff</span><br><span class="line">    │   │       ├── parent</span><br><span class="line">    │   │       ├── size</span><br><span class="line">    │   │       └── tar-split.json.gz</span><br><span class="line">    │   └── tmp</span><br><span class="line">    └── repositories.json</span><br><span class="line">21 directories, 119 files</span><br></pre></td></tr></table></figure><ul><li><code>repositories.json</code></li></ul><p>repositories.json 就是存储镜像元数据信息，主要是 image name 和 image id 的对应，digest 和 image id 的对应。当 pull 完一个镜像的时候 docker 会更新这个文件。当我们 docker run 一个容器的时候也用到这个文件去索引本地是否存在该镜像，没有镜像的话就自动去 pull 这个镜像。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/docker/image/overlay2</span><br><span class="line">╰─# jq "." repositories.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Repositories"</span>: &#123;</span><br><span class="line">    <span class="attr">"debian"</span>: &#123;</span><br><span class="line">      <span class="attr">"debian:v1"</span>: <span class="string">"sha256:cfba37fd24f80f59e5d7c1f7735cae7a383e887d8cff7e2762fdd78c0d73568d"</span>,</span><br><span class="line">      <span class="attr">"debian:v2"</span>: <span class="string">"sha256:e6e782a57a51d01168907938beb5cd5af24fcb7ebed8f0b32c203137ace6d3df"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"localhost:5000/library/debian"</span>: &#123;</span><br><span class="line">      <span class="attr">"localhost:5000/library/debian:v1"</span>: <span class="string">"sha256:cfba37fd24f80f59e5d7c1f7735cae7a383e887d8cff7e2762fdd78c0d73568d"</span>,</span><br><span class="line">      <span class="attr">"localhost:5000/library/debian:v2"</span>: <span class="string">"sha256:e6e782a57a51d01168907938beb5cd5af24fcb7ebed8f0b32c203137ace6d3df"</span>,</span><br><span class="line">      <span class="attr">"localhost:5000/library/debian@sha256:b9caca385021f231e15aee34929eac332c49402372a79808d07ee66866792239"</span>: <span class="string">"sha256:cfba37fd24f80f59e5d7c1f7735cae7a383e887d8cff7e2762fdd78c0d73568d"</span>,</span><br><span class="line">      <span class="attr">"localhost:5000/library/debian@sha256:c805f078bb47c575e9602b09af7568eb27fd1c92073199acba68c187bc5bcf11"</span>: <span class="string">"sha256:e6e782a57a51d01168907938beb5cd5af24fcb7ebed8f0b32c203137ace6d3df"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"registry"</span>: &#123;</span><br><span class="line">      <span class="attr">"registry:latest"</span>: <span class="string">"sha256:708bc6af7e5e539bdb59707bbf1053cc2166622f5e1b17666f0ba5829ca6aaea"</span>,</span><br><span class="line">      <span class="attr">"registry@sha256:7d081088e4bfd632a88e3f3bcd9e007ef44a796fddfe3261407a3f9f04abe1e7"</span>: <span class="string">"sha256:708bc6af7e5e539bdb59707bbf1053cc2166622f5e1b17666f0ba5829ca6aaea"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>distribution 目录下</li></ul><p>存放着 layer 的 diff_id 和 digest 的对应关系</p><p>diffid-by-digest :存放 <code>digest</code> 到 <code>diffid</code> 的对应关系</p><p>v2metadata-by-diffid : 存放 <code>diffid</code> 到 <code>digest</code> 的对应关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── distribution</span><br><span class="line">│   ├── diffid-by-digest</span><br><span class="line">│   │   └── sha256</span><br><span class="line">│   │       ├── 039b991354af4dcbc534338f687e27643c717bb57e11b87c2e81d50bdd0b2376</span><br><span class="line">│   │       ├── 09a4142c5c9dde2fbf35e7a6e6475eba75a8c28540c375c80be7eade4b7cb438</span><br><span class="line">│   └── v2metadata-by-diffid</span><br><span class="line">│       └── sha256</span><br><span class="line">│           ├── 0683de2821778aa9546bf3d3e6944df779daba1582631b7ea3517bb36f9e4007</span><br><span class="line">│           ├── 0f7493e3a35bab1679e587b41b353b041dca1e7043be230670969703f28a1d83</span><br></pre></td></tr></table></figure><ul><li>imagedb</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── imagedb</span><br><span class="line">│   ├── content</span><br><span class="line">│   │   └── sha256</span><br><span class="line">│   │       ├── 708bc6af7e5e539bdb59707bbf1053cc2166622f5e1b17666f0ba5829ca6aaea</span><br><span class="line">│   │       └── f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a</span><br><span class="line">│   └── metadata</span><br><span class="line">│       └── sha256</span><br></pre></td></tr></table></figure><ul><li>layerdb</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── layerdb</span><br><span class="line">│   ├── mounts</span><br><span class="line">│   ├── sha256</span><br><span class="line">│   │   ├── b9835d6a62886d4e85b65abb120c0ea44ff1b3d116d7a707620785d4664d8c1a</span><br><span class="line">│   │   │   ├── cache-id  # docker 下载镜像时随机生成的 id</span><br><span class="line">│   │   │   ├── diff # 存放 layer 的 diffid</span><br><span class="line">│   │   │   ├── parent # 放当前 layer 的父 layer 的 diffid，最底层的 layer 没有这个文件</span><br><span class="line">│   │   │   ├── size # 该 layer 的大小</span><br><span class="line">│   │   │   └── tar-split.json.gz</span><br></pre></td></tr></table></figure><p>需要注意的是：tar-split.json.gz 文件是 layer tar 包的 split 文件，记录了 layer 解压后的文件在 tar 包中的位置（偏移量），通过这个文件可以还原 layer 的 tar 包，在 docker save 导出 image 的时候会用到，由根据它可以开倒车把解压的 layer 还原回 tar 包。详情可参考 <a href="https://github.com/vbatts/tar-split" target="_blank" rel="noopener">tar-split</a></p><h3 id="var-lib-docker-overlay2"><a href="#var-lib-docker-overlay2" class="headerlink" title="/var/lib/docker/overlay2"></a>/var/lib/docker/overlay2</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">overlay2</span><br><span class="line">├── 259cf6934509a674b1158f0a6c90c60c133fd11189f98945c7c3a524784509ff</span><br><span class="line">│   └── diff</span><br><span class="line">│       ├── bin</span><br><span class="line">│       ├── dev</span><br><span class="line">│       ├── etc</span><br><span class="line">│       ├── home</span><br><span class="line">│       ├── lib</span><br><span class="line">│       ├── media</span><br><span class="line">│       ├── mnt</span><br><span class="line">│       ├── opt</span><br><span class="line">│       ├── proc</span><br><span class="line">│       ├── root</span><br><span class="line">│       ├── run</span><br><span class="line">│       ├── sbin</span><br><span class="line">│       ├── srv</span><br><span class="line">│       ├── sys</span><br><span class="line">│       ├── tmp</span><br><span class="line">│       ├── usr</span><br><span class="line">│       └── var</span><br><span class="line">├── 27f9e9b74a88a269121b4e77330a665d6cca4719cb9a58bfc96a2b88a07af805</span><br><span class="line">│   ├── diff</span><br><span class="line">│   └── work</span><br><span class="line">├── a0df3cc902cfbdee180e8bfa399d946f9022529d12dba3bc0b13fb7534120015</span><br><span class="line">│   ├── diff</span><br><span class="line">│   │   └── bin</span><br><span class="line">│   └── work</span><br><span class="line">├── b2fbebb39522cb6f1f5ecbc22b7bec5e9bc6ecc25ac942d9e26f8f94a028baec</span><br><span class="line">│   ├── diff</span><br><span class="line">│   │   ├── etc</span><br><span class="line">│   │   ├── lib</span><br><span class="line">│   │   ├── usr</span><br><span class="line">│   │   └── var</span><br><span class="line">│   └── work</span><br><span class="line">├── be8c12f63bebacb3d7d78a09990dce2a5837d86643f674a8fd80e187d8877db9</span><br><span class="line">│   ├── diff</span><br><span class="line">│   │   └── etc</span><br><span class="line">│   └── work</span><br><span class="line">├── e8f6e78aa1afeb96039c56f652bb6cd4bbd3daad172324c2172bad9b6c0a968d</span><br><span class="line">│   └── diff</span><br><span class="line">│       ├── bin</span><br><span class="line">│       ├── dev</span><br><span class="line">│       ├── etc</span><br><span class="line">│       ├── home</span><br><span class="line">│       ├── lib</span><br><span class="line">│       ├── media</span><br><span class="line">│       ├── mnt</span><br><span class="line">│       ├── proc</span><br><span class="line">│       ├── root</span><br><span class="line">│       ├── run</span><br><span class="line">│       ├── sbin</span><br><span class="line">│       ├── srv</span><br><span class="line">│       ├── sys</span><br><span class="line">│       ├── tmp</span><br><span class="line">│       ├── usr</span><br><span class="line">│       └── var</span><br><span class="line">└── l</span><br><span class="line">    ├── 526XCHXRJMZXRIHN4YWJH2QLPY -&gt; ../b2fbebb39522cb6f1f5ecbc22b7bec5e9bc6ecc25ac942d9e26f8f94a028baec/diff</span><br><span class="line">    ├── 5RZOXYR35NSGAWTI36CVUIRW7U -&gt; ../be8c12f63bebacb3d7d78a09990dce2a5837d86643f674a8fd80e187d8877db9/diff</span><br><span class="line">    ├── LBWRL4ZXGBWOTN5JDCDZVNOY7H -&gt; ../a0df3cc902cfbdee180e8bfa399d946f9022529d12dba3bc0b13fb7534120015/diff</span><br><span class="line">    ├── MYRYBGZRI4I76MJWQHN7VLZXLW -&gt; ../27f9e9b74a88a269121b4e77330a665d6cca4719cb9a58bfc96a2b88a07af805/diff</span><br><span class="line">    ├── PCIS4FYUJP4X2D4RWB7ETFL6K2 -&gt; ../259cf6934509a674b1158f0a6c90c60c133fd11189f98945c7c3a524784509ff/diff</span><br><span class="line">    └── XK5IA4BWQ2CIS667J3SXPXGQK5 -&gt; ../e8f6e78aa1afeb96039c56f652bb6cd4bbd3daad172324c2172bad9b6c0a968d/diff</span><br></pre></td></tr></table></figure><p>在 <code>/var/lib/docker/overlay2</code> 目录下，我们可以看到，镜像 layer 的内容都存放在一个 <code>diff</code> 的文件夹下，diff 的上级目录就是以镜像 layer 的 digest 为名的目录。其中还有个 <code>l</code> 文件夹，下面有一坨坨的硬链接文件指向上级目录的 layer 目录。这个 l 其实就是 link 的缩写，l 下的文件都是一些比 digest 文件夹名短一些的，方面不至于 mount 的参数过长。</p><h2 id="镜像是怎么搬运的🤣"><a href="#镜像是怎么搬运的🤣" class="headerlink" title="镜像是怎么搬运的🤣"></a>镜像是怎么搬运的🤣</h2><p>当我们在本地构建完成一个镜像之后，如何传递给他人呢？这就涉及到镜像是怎么搬运的一些知识，搬运镜像就像我们在 GitHub 上搬运代码一样，docker 也有类似于 git clone 和 git push 的搬运方式。docker push 就和我们使用 git push 一样，将本地的镜像推送到一个称之为 registry 的镜像仓库，这个 registry 镜像仓库就像 GitHub 用来存放公共/私有的镜像，一个中心化的镜像仓库方便大家来进行交流和搬运镜像。docker pull 就像我们使用 git pull 一样，将远程的镜像拉拉取本地。</p><h3 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h3><p>理解 docker pull 一个镜像的流程最好的办法是查看 OCI registry 规范中的这段文档 <a href="https://github.com/opencontainers/distribution-spec/blob/master/spec.md#pulling-an-image" target="_blank" rel="noopener">pulling-an-image</a> ，在这里我结合大佬的博客简单梳理一下 pull 一个镜像的大致流程。下面这张图是从 <a href="https://github.com/helios741/myblog/blob/new/learn_go/src/2019/20191206_docker_disk_storage/README.md" target="_blank" rel="noopener">浅谈docker中镜像和容器在本地的存储)</a> 借来的😂</p><p><img src="https://user-images.githubusercontent.com/12036324/70367494-646d2380-18db-11ea-992a-d2bca4cbfeb0.png" alt="image"></p><p>docker pull 就和我们使用 git clone 一样效果，将远程的镜像仓库拉取到本地来给容器运行时使用，结合上图大致的流程如下：</p><ul><li>第一步应该是使用<code>~/.docker/config.json</code> 中的 auth 认证信息在 registry 那里进行鉴权授权，拿到一个 token，后面的所有的 HTTP 请求中都要包含着该 token 才能有权限进行操作。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /home/ubuntu</span><br><span class="line">╰─# cat ~/.docker/config.json</span><br><span class="line">&#123;</span><br><span class="line">        <span class="attr">"auths"</span>: &#123;</span><br><span class="line">                <span class="attr">"https://registry.k8s.li/v2/"</span>: &#123;</span><br><span class="line">                        <span class="attr">"auth"</span>: <span class="string">"d2VicH855828WM7bSVsslJFpmQE43Sw=="</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"HttpHeaders"</span>: &#123;</span><br><span class="line">                <span class="attr">"User-Agent"</span>: <span class="string">"Docker-Client/19.03.5 (linux)"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"experimental"</span>: <span class="string">"enabled"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>dockerd 守护进程解析 docker 客户端参数，由镜像名 + tag 向 registry 请求 Manifest 文件，HTTP 请求为<code>GET /v2/&lt;name&gt;/manifests/&lt;reference&gt;</code>。registry 中一个镜像有多个 tag 或者多个处理器体系架构的镜像，则根据这个 tag 来返回给客户端与之对应的  manifest 文件；</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET /v2/&lt;name&gt;/manifests/&lt;reference&gt;</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"annotations"</span>: &#123;</span><br><span class="line">      <span class="attr">"com.example.key1"</span>: <span class="string">"value1"</span>,</span><br><span class="line">      <span class="attr">"com.example.key2"</span>: <span class="string">"value2"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"config"</span>: &#123;</span><br><span class="line">      <span class="attr">"digest"</span>: <span class="string">"sha256:6f4e69a5ff18d92e7315e3ee31c62165ebf25bfa05cad05c0d09d8f412dae401"</span>,</span><br><span class="line">      <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.oci.image.config.v1+json"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">452</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"layers"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"digest"</span>: <span class="string">"sha256:6f4e69a5ff18d92e7315e3ee31c62165ebf25bfa05cad05c0d09d8f412dae401"</span>,</span><br><span class="line">         <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.oci.image.layer.v1.tar+gzip"</span>,</span><br><span class="line">         <span class="attr">"size"</span>: <span class="number">78343</span></span><br><span class="line">      &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"schemaVersion"</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>dockerd 得到 <code>manifest</code> 后，读取里面 image config 文件的 <code>digest</code>，这个 sha256 值就是 image 的 <code>ID</code></li><li>根据 <code>ID</code> 在本地的 <code>repositories.json</code>中查找找有没有存在同样 <code>ID</code> 的 image，有的话就不用下载了</li><li>如果没有，那么会给 registry 服务器发请求拿到  image config 文件</li><li>根据 image config 文件中的 <code>diff_ids</code>在本地找对应的 layer 是否存在</li><li>如果 layer 不存在，则根据 <code>manifest</code> 里面 layer 的 <code>sha256</code> 和 <code>media type</code> 去服务器拿相应的 layer（相当去拿压缩格式的包）</li><li>dockerd 守护进程并行下载各 layer ，HTTP 请求为<code>GET /v2/&lt;name&gt;/blobs/&lt;digest&gt;</code>。 </li><li>拿到后进行解压，并检查解压(gzip -d)后 tar 包的 sha256 是否和 image config 中的 <code>diff_id</code> 相同，不相同就翻车了</li><li>等所有的 layer 都下载完成后，整个 image 的 layer 就下载完成，接着开始进行解压(tar -xf) layer 的 tar 包。</li><li>dockerd 起一个单独的进程 <code>docker-untar</code> 来 gzip 解压缩已经下载完成的 layer 文件；对于有些比较大的镜像（比如几十 GB 的镜像），往往镜像的 layer 已经下载完成了，但还没有解压完😂。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-untar /var/lib/docker/overlay2/a076db6567c7306f3cdab6040cd7d083ef6a39d125171353eedbb8bde7f203b4/diff</span><br></pre></td></tr></table></figure><ul><li>验证 image config 中的 RootFS.DiffIDs 是否与下载（解压后）hash 相同；</li></ul><h3 id="docker-push"><a href="#docker-push" class="headerlink" title="docker push"></a>docker push</h3><p>push 推送一个镜像到远程的 registry 流程恰好和 pull 拉取镜像到本地的流程相反。我们 pull 一个镜像的时候往往需要先获取包含着镜像 layer 信息的 Manifest 文件，然后根据这个文件中的 layer 信息取 pull 相应的 layer。push 一个镜像，需要先将镜像的各个 layer 推送到 registry ，当所有的镜像 layer 上传完毕之后最后再 push Image Manifest 到 registry。大体的流程如下：</p><blockquote><p>  All layer uploads use two steps to manage the upload process. The first step starts the upload in the registry service, returning a url to carry out the second step. The second step uses the upload url to transfer the actual data. Uploads are started with a POST request which returns a url that can be used to push data and check upload status.</p></blockquote><ul><li><p>第一步和 pull 一个镜像一样也是进行鉴权授权，拿到一个 token；</p></li><li><p>向 registry 发送 <code>POST /v2/&lt;name&gt;/blobs/uploads/</code>请求，registry 返回一个上传镜像 layer 时要应到的 URL；</p></li><li><p>客户端通过 <code>HEAD /v2/&lt;name&gt;/blobs/&lt;digest&gt;</code> 请求检查 registry 中是否已经存在镜像的 layer。</p></li><li><p>客户端通过URL 使用 POST 方法来实时上传 layer 数据，上传镜像 layer 分为 <code>Monolithic Upload</code> （整体上传）和<code>Chunked Upload</code>（分块上传）两种方式。</p><ul><li>Monolithic Upload </li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /v2/&lt;name&gt;/blobs/uploads/&lt;session_id&gt;?digest=&lt;digest&gt;</span><br><span class="line"><span class="attribute">Content-Length</span>: &lt;size of layer&gt;</span><br><span class="line"><span class="attribute">Content-Type</span>: application/octet-stream</span><br><span class="line"></span><br><span class="line">&lt;Layer Binary Data&gt;</span><br></pre></td></tr></table></figure><ul><li>Chunked Upload</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PATCH /v2/&lt;name&gt;/blobs/uploads/&lt;session_id&gt;</span><br><span class="line"><span class="attribute">Content-Length</span>: &lt;size of chunk&gt;</span><br><span class="line"><span class="attribute">Content-Range</span>: &lt;start of range&gt;-&lt;end of range&gt;</span><br><span class="line"><span class="attribute">Content-Type</span>: application/octet-stream</span><br><span class="line"></span><br><span class="line">&lt;Layer Chunk Binary Data&gt;</span><br></pre></td></tr></table></figure></li><li><p>镜像的 layer 上传完成之后，客户端需要向 registry 发送一个 PUT HTTP 请求告知该 layer 已经上传完毕。</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /v2/&lt;name&gt;/blobs/uploads/&lt;session_id&gt;?digest=&lt;digest&gt;</span><br><span class="line"><span class="attribute">Content-Length</span>: &lt;size of chunk&gt;</span><br><span class="line"><span class="attribute">Content-Range</span>: &lt;start of range&gt;-&lt;end of range&gt;</span><br><span class="line"><span class="attribute">Content-Type</span>: application/octet-stream</span><br><span class="line"></span><br><span class="line">&lt;Last Layer Chunk Binary Data&gt;</span><br></pre></td></tr></table></figure><ul><li>最后当所有的 layer 上传完之后，客户端再将 manifest 推送上去就完事儿了。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUT /v2/&lt;name&gt;/manifests/&lt;reference&gt;</span><br><span class="line">Content-Type: &lt;manifest media type&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"annotations"</span>: &#123;</span><br><span class="line">      <span class="attr">"com.example.key1"</span>: <span class="string">"value1"</span>,</span><br><span class="line">      <span class="attr">"com.example.key2"</span>: <span class="string">"value2"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"config"</span>: &#123;</span><br><span class="line">      <span class="attr">"digest"</span>: <span class="string">"sha256:6f4e69a5ff18d92e7315e3ee31c62165ebf25bfa05cad05c0d09d8f412dae401"</span>,</span><br><span class="line">      <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.oci.image.config.v1+json"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">452</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"layers"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"digest"</span>: <span class="string">"sha256:6f4e69a5ff18d92e7315e3ee31c62165ebf25bfa05cad05c0d09d8f412dae401"</span>,</span><br><span class="line">         <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.oci.image.layer.v1.tar+gzip"</span>,</span><br><span class="line">         <span class="attr">"size"</span>: <span class="number">78343</span></span><br><span class="line">      &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"schemaVersion"</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-docker-drag"><a href="#Python-docker-drag" class="headerlink" title="Python docker-drag"></a>Python <a href="https://github.com/NotGlop/docker-drag" target="_blank" rel="noopener">docker-drag</a></h3><p>这是一个很简单粗暴的 Python 脚本，使用 request 库请求 registry API 来从镜像仓库中拉取镜像，并保存为一个 tar 包，拉完之后使用 docker load 加载一下就能食用啦。该 python 脚本简单到去掉空行和注释不到 200 行，如果把这个脚本源码读一遍的话就能大概知道 docker pull 和 skopeo copy 的一些原理，他们都是去调用 registry 的 API ，所以还是推荐去读一下这个它的源码。</p><p>食用起来也很简单直接 <code>python3 docker_pull.py [image name]</code>，貌似只能拉取 docker.io 上的镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /home/ubuntu</span><br><span class="line">╰─# wget https://raw.githubusercontent.com/NotGlop/docker-drag/master/docker_pull.py</span><br><span class="line">╭─root@sg-02 /home/ubuntu</span><br><span class="line">╰─# python3 docker_pull.py nginx</span><br><span class="line">Creating image structure in: tmp_nginx_latest</span><br><span class="line">afb6ec6fdc1c: Pull complete [27098756]</span><br><span class="line">dd3ac8106a0b: Pull complete [26210578]                                       ]</span><br><span class="line">8de28bdda69b: Pull complete [538]</span><br><span class="line">a2c431ac2669: Pull complete [900]</span><br><span class="line">e070d03fd1b5: Pull complete [669]</span><br><span class="line">Docker image pulled: library_nginx.tar</span><br><span class="line">╭─root@sg-02 /home/ubuntu</span><br><span class="line">╰─# docker load -i library_nginx.tar</span><br><span class="line">ffc9b21953f4: Loading layer [==================================================&gt;]  72.49MB/72.49MB</span><br><span class="line">d9c0b16c8d5b: Loading layer [==================================================&gt;]  63.81MB/63.81MB</span><br><span class="line">8c7fd6263c1f: Loading layer [==================================================&gt;]  3.072kB/3.072kB</span><br><span class="line">077ae58ac205: Loading layer [==================================================&gt;]  4.096kB/4.096kB</span><br><span class="line">787328500ad5: Loading layer [==================================================&gt;]  3.584kB/3.584kB</span><br><span class="line">Loaded image: nginx:latest</span><br></pre></td></tr></table></figure><h3 id="skopeo"><a href="#skopeo" class="headerlink" title="skopeo"></a>skopeo</h3><p>这个工具是红帽子家的，是 Podman、Skopeo 和 Buildah （简称 PSB ）下一代容器新架构中的一员，不过木子觉着 Podman 想要取代 docker 和 containerd 容器运行时还有很长的路要走，虽然它符合 OCI 规范，但对于企业来讲，替换的成本并不值得他们去换到 PSB 上去。</p><p>其中的 skopeo 这个镜像搬运工具简直是个神器，尤其是在 CI/CD 流水线中搬运两个镜像仓库里的镜像简直爽的不得了。我入职新公司后做的一个工作就是优化我们的 Jenkins 流水线中同步两个镜像仓库的过程，使用 了skopeo 替代 docker 来同步两个镜像仓库中的镜像，将原来需要 2h 小时缩短到了 25min 😀。</p><p>关于这个工具的详细使用推荐大家去读一下我之前写的一篇博客 <a href="https://blog.k8s.li/skopeo.html">镜像搬运工 skopeo 初体验</a> 。在这里只讲两个木子最常用的功能。</p><h4 id="skopeo-copy"><a href="#skopeo-copy" class="headerlink" title="skopeo copy"></a>skopeo copy</h4><p>使用 skopeo copy 两个 registry 中的镜像时，skopeo 请求两个 registry API 直接 copy <code>original blob</code> 到另一个 registry ，这样免去了像 docker pull –&gt; docker tag –&gt; docker push 那样 pull 镜像对镜像进行解压缩，push 镜像进行压缩。尤其是在搬运一些较大的镜像（几GB 或者几十 GB的镜像，比如 <code>nvidia/cuda</code> ），使用 skopeo copy 的加速效果十分明显。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DEBU[0000] Detected compression format gzip</span><br><span class="line">DEBU[0000] Using original blob without modification</span><br><span class="line"></span><br><span class="line">Getting image source signatures</span><br><span class="line">Copying blob 09a9f6a07669 done</span><br><span class="line">Copying blob f8cdeb3c6c18 done</span><br><span class="line">Copying blob 22c4d5853f25 done</span><br><span class="line">Copying blob 76abc3f50d9b done</span><br><span class="line">Copying blob 3386b7c9ccd4 done</span><br><span class="line">Copying blob b9207193f1af [==============================&gt;-------] 224.2MiB / 271.2MiB</span><br><span class="line">Copying blob 2f32d819e6ce done</span><br><span class="line">Copying blob 5dbc3047e646 done</span><br><span class="line">Copying blob f8dfcc3265c3 [==================&gt;-------------------] 437.1MiB / 864.3MiB</span><br><span class="line">Copying blob 13d3556105d1 done</span><br><span class="line">Copying blob f9b7fa6a027e [=========================&gt;------------] 84.0MiB / 124.3MiB</span><br><span class="line">Copying blob a1a0f6abe73b [====================&gt;-----------------] 417.9MiB / 749.1MiB</span><br><span class="line">Copying blob bcc9947fc8a4 done</span><br><span class="line">Copying blob 9563b2824fef done</span><br><span class="line">Copying blob a1b8faa0044b [===&gt;----------------------------------] 88.0MiB / 830.1MiB</span><br><span class="line">Copying blob 9917e218edfd [===============&gt;----------------------] 348.6MiB / 803.6MiB</span><br><span class="line">Copying blob 776b9ff2f788 done</span><br><span class="line">Copying config d0c3cfd730 done</span><br><span class="line">Writing manifest to image destination</span><br><span class="line">Storing signatures</span><br></pre></td></tr></table></figure><h4 id="skopeo-inspect"><a href="#skopeo-inspect" class="headerlink" title="skopeo inspect"></a>skopeo inspect</h4><p>用 skopeo inspect 命令可以很方方便地通过 registry 的 API 来查看镜像的 manifest 文件，以前我都是用 curl 命令的，要 token 还要加一堆参数，所以比较麻烦，所以后来就用上了  skopeo inspect😀。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">root@deploy:/root # skopeo inspect docker://index.docker.io/webpsh/webps:latest --raw</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"schemaVersion"</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.distribution.manifest.v2+json"</span>,</span><br><span class="line">   <span class="attr">"config"</span>: &#123;</span><br><span class="line">      <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.container.image.v1+json"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">2534</span>,</span><br><span class="line">      <span class="attr">"digest"</span>: <span class="string">"sha256:30d9679b0b1ca7e56096eca0cdb7a6eedc29b63968f25156ef60dec27bc7d206"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"layers"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.image.rootfs.diff.tar.gzip"</span>,</span><br><span class="line">         <span class="attr">"size"</span>: <span class="number">2813316</span>,</span><br><span class="line">         <span class="attr">"digest"</span>: <span class="string">"sha256:cbdbe7a5bc2a134ca8ec91be58565ec07d037386d1f1d8385412d224deafca08"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.image.rootfs.diff.tar.gzip"</span>,</span><br><span class="line">         <span class="attr">"size"</span>: <span class="number">8088920</span>,</span><br><span class="line">         <span class="attr">"digest"</span>: <span class="string">"sha256:54335262c2ed2d4155e62b45b187a1394fbb6f39e0a4a171ab8ce0c93789e6b0"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.image.rootfs.diff.tar.gzip"</span>,</span><br><span class="line">         <span class="attr">"size"</span>: <span class="number">262</span>,</span><br><span class="line">         <span class="attr">"digest"</span>: <span class="string">"sha256:31555b34852eddc7c01f26fa9c0e5e577e36b4e7ccf1b10bec977eb4593a376b"</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="镜像是怎么存放的-二-registry-存储🙄"><a href="#镜像是怎么存放的-二-registry-存储🙄" class="headerlink" title="镜像是怎么存放的 (二) registry 存储🙄"></a>镜像是怎么存放的 (二) registry 存储🙄</h2><p>文章的开头我们提到过 OCI 规范中的镜像仓库规范 <a href="https://github.com/opencontainers/distribution-spec" target="_blank" rel="noopener">distribution-spec</a>，该规范就定义着容器镜像如何存储在远端（即 registry）上。我们可以把 registry 看作镜像的仓库，使用该规范可以帮助我们把这些镜像按照约定俗成的格式来存放，目前实现该规范的 registry 就 docker 家的 registry 使用的多一些。其他的 registry 比如 harbor ，quay.io 使用的也比较多。</p><h3 id="registry-registry-docker-v2"><a href="#registry-registry-docker-v2" class="headerlink" title="registry (/registry/docker/v2)"></a>registry (/registry/docker/v2)</h3><p>想要分析一下镜像是如何存放在 registry 上的，我们在本地使用 docker run 来起 registry 的容器即可，我们仅仅是来分析 registry 中镜像时如何存储的，这种场景下不太适合用 harbor 这种重量级的 registry 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /home/ubuntu</span><br><span class="line">╰─# docker run -d --name registry -p 5000:5000 -v /var/lib/registry:/var/lib/registry registry</span><br><span class="line">335ea763a2fa4508ebf3ec6f8b11f3b620a11bdcaa0ab43176b781427e0beee6</span><br></pre></td></tr></table></figure><p>启动完 registry 容器之后我们给之前已经构建好的镜像重新打上改 registry 的 tag 方便后续 push 到 registry 上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 ~/buster/slim</span><br><span class="line">╰─# docker tag debian:v1  localhost:5000/library/debian:v1</span><br><span class="line">╭─root@sg-02 ~/buster/slim</span><br><span class="line">╰─# ^v1^v2</span><br><span class="line">╭─root@sg-02 ~/buster/slim</span><br><span class="line">╰─# docker tag debian:v2  localhost:5000/library/debian:v2</span><br><span class="line">╭─root@sg-02 ~/buster/slim</span><br><span class="line">╰─# docker images</span><br><span class="line">REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">debian                          v2                  e6e782a57a51        5 minutes ago       69.2MB</span><br><span class="line">localhost:5000/library/debian   v2                  e6e782a57a51        5 minutes ago       69.2MB</span><br><span class="line">debian                          v1                  cfba37fd24f8        9 minutes ago       69.2MB</span><br><span class="line">localhost:5000/library/debian   v1                  cfba37fd24f8        9 minutes ago       69.2MB</span><br><span class="line">╭─root@sg-02 ~/buster/slim</span><br><span class="line">╰─# docker push localhost:5000/library/debian:v1</span><br><span class="line">The push refers to repository [localhost:5000/library/debian]</span><br><span class="line">d1b85e6186f6: Pushed</span><br><span class="line">v1: digest: sha256:b9caca385021f231e15aee34929eac332c49402372a79808d07ee66866792239 size: 529</span><br><span class="line">╭─root@sg-02 ~/buster/slim</span><br><span class="line">╰─# docker push localhost:5000/library/debian:v2</span><br><span class="line">The push refers to repository [localhost:5000/library/debian]</span><br><span class="line">d1b85e6186f6: Layer already exists</span><br><span class="line">v2: digest: sha256:c805f078bb47c575e9602b09af7568eb27fd1c92073199acba68c187bc5bcf11 size: 529</span><br></pre></td></tr></table></figure><p>当我们在本地启动一个 registry 容器之后，容器内默认的存储位置为 <code>/var/lib/registry</code> ，所以我们在启动的时候加了参数 <code>-v /var/lib/registry:/var/lib/registry</code> 将本机的路径挂载到容器内。进入这里路径我们使用 tree 命令查看一下这个目录的存储结构。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2</span><br><span class="line">╰─# tree -h</span><br><span class="line">.</span><br><span class="line">├── [4.0K]  blobs</span><br><span class="line">│   └── [4.0K]  sha256</span><br><span class="line">│       ├── [4.0K]  aa</span><br><span class="line">│       │   └── [4.0K]  aaae33815489895f602207ac5a583422b8a8755b3f67fc6286ca9484ba685bdb</span><br><span class="line">│       │       └── [ 26M]  data</span><br><span class="line">│       ├── [4.0K]  b9</span><br><span class="line">│       │   └── [4.0K]  b9caca385021f231e15aee34929eac332c49402372a79808d07ee66866792239</span><br><span class="line">│       │       └── [ 529]  data</span><br><span class="line">│       ├── [4.0K]  c8</span><br><span class="line">│       │   └── [4.0K]  c805f078bb47c575e9602b09af7568eb27fd1c92073199acba68c187bc5bcf11</span><br><span class="line">│       │       └── [ 529]  data</span><br><span class="line">│       ├── [4.0K]  cf</span><br><span class="line">│       │   └── [4.0K]  cfba37fd24f80f59e5d7c1f7735cae7a383e887d8cff7e2762fdd78c0d73568d</span><br><span class="line">│       │       └── [1.4K]  data</span><br><span class="line">│       └── [4.0K]  e6</span><br><span class="line">│           └── [4.0K]  e6e782a57a51d01168907938beb5cd5af24fcb7ebed8f0b32c203137ace6d3df</span><br><span class="line">│               └── [1.4K]  data</span><br><span class="line">└── [4.0K]  repositories</span><br><span class="line">    └── [4.0K]  library</span><br><span class="line">        └── [4.0K]  debian</span><br><span class="line">            ├── [4.0K]  _layers</span><br><span class="line">            │   └── [4.0K]  sha256</span><br><span class="line">            │       ├── [4.0K]  aaae33815489895f602207ac5a583422b8a8755b3f67fc6286ca9484ba685bdb</span><br><span class="line">            │       │   └── [  71]  link</span><br><span class="line">            │       ├── [4.0K]  cfba37fd24f80f59e5d7c1f7735cae7a383e887d8cff7e2762fdd78c0d73568d</span><br><span class="line">            │       │   └── [  71]  link</span><br><span class="line">            │       └── [4.0K]  e6e782a57a51d01168907938beb5cd5af24fcb7ebed8f0b32c203137ace6d3df</span><br><span class="line">            │           └── [  71]  link</span><br><span class="line">            ├── [4.0K]  _manifests</span><br><span class="line">            │   ├── [4.0K]  revisions</span><br><span class="line">            │   │   └── [4.0K]  sha256</span><br><span class="line">            │   │       ├── [4.0K]  b9caca385021f231e15aee34929eac332c49402372a79808d07ee66866792239</span><br><span class="line">            │   │       │   └── [  71]  link</span><br><span class="line">            │   │       └── [4.0K]  c805f078bb47c575e9602b09af7568eb27fd1c92073199acba68c187bc5bcf11</span><br><span class="line">            │   │           └── [  71]  link</span><br><span class="line">            │   └── [4.0K]  tags</span><br><span class="line">            │       ├── [4.0K]  v1</span><br><span class="line">            │       │   ├── [4.0K]  current</span><br><span class="line">            │       │   │   └── [  71]  link</span><br><span class="line">            │       │   └── [4.0K]  index</span><br><span class="line">            │       │       └── [4.0K]  sha256</span><br><span class="line">            │       │           └── [4.0K]  b9caca385021f231e15aee34929eac332c49402372a79808d07ee66866792239</span><br><span class="line">            │       │               └── [  71]  link</span><br><span class="line">            │       └── [4.0K]  v2</span><br><span class="line">            │           ├── [4.0K]  current</span><br><span class="line">            │           │   └── [  71]  link</span><br><span class="line">            │           └── [4.0K]  index</span><br><span class="line">            │               └── [4.0K]  sha256</span><br><span class="line">            │                   └── [4.0K]  c805f078bb47c575e9602b09af7568eb27fd1c92073199acba68c187bc5bcf11</span><br><span class="line">            │                       └── [  71]  link</span><br><span class="line">            └── [4.0K]  _uploads</span><br><span class="line"></span><br><span class="line">37 directories, 14 files</span><br></pre></td></tr></table></figure><p>树形的结构看着不太直观，木子就画了一张层级结构的图：</p><p><img src="img/registry-storage.jpeg" alt="img"></p><h3 id="blobs-目录"><a href="#blobs-目录" class="headerlink" title="blobs 目录"></a>blobs 目录</h3><p>之前我们向 registry 种推送了两个镜像，这两个镜像的 layer 相同但不是用一个镜像，在我们之前 push image 的时候也看到了 <code>d1b85e6186f6: Layer already exists</code>。也就可以证明了，虽然两个镜像不同，但它们的 layer 在 registry 中存储的时候可能是相同的。</p><p>在 <code>blobs/sha256</code> 目录下一共有 5 个名为 data 的文件，我们可以推测一下最大的那个 <code>[ 26M]</code> 应该是镜像的 layer ，最小的 <code>[ 529]</code> 那个应该是 manifest，剩下的那个 <code>[1.4K]</code> 应该就是 image config 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2/blobs/sha256</span><br><span class="line">╰─# tree -h</span><br><span class="line">.</span><br><span class="line">├── [4.0K]  aa</span><br><span class="line">│   └── [4.0K]  aaae33815489895f602207ac5a583422b8a8755b3f67fc6286ca9484ba685bdb</span><br><span class="line">│       └── [ 26M]  data</span><br><span class="line">├── [4.0K]  b9</span><br><span class="line">│   └── [4.0K]  b9caca385021f231e15aee34929eac332c49402372a79808d07ee66866792239</span><br><span class="line">│       └── [ 529]  data</span><br><span class="line">├── [4.0K]  c8</span><br><span class="line">│   └── [4.0K]  c805f078bb47c575e9602b09af7568eb27fd1c92073199acba68c187bc5bcf11</span><br><span class="line">│       └── [ 529]  data</span><br><span class="line">├── [4.0K]  cf</span><br><span class="line">│   └── [4.0K]  cfba37fd24f80f59e5d7c1f7735cae7a383e887d8cff7e2762fdd78c0d73568d</span><br><span class="line">│       └── [1.4K]  data</span><br><span class="line">└── [4.0K]  e6</span><br><span class="line">    └── [4.0K]  e6e782a57a51d01168907938beb5cd5af24fcb7ebed8f0b32c203137ace6d3df</span><br><span class="line">        └── [1.4K]  data</span><br></pre></td></tr></table></figure><p>在 <code>registry</code> 的存储目录下，<code>blobs</code> 目录用来存放镜像的三种文件： layer 的真实数据，镜像的 manifest 文件，镜像的 image config 文件。这些文件都是以 <code>data</code> 为名的文件存放在于该文件 <code>sha256</code> 相对应的目录下。 使用以内容寻址的 <code>sha256</code> 散列存储方便索引文件，在 <code>blob digest</code> 目录下有一个名为 <code>data</code>的文件，对于 layer 来讲，这是个 <code>data</code> 文件的格式是 <code>vnd.docker.image.rootfs.diff.tar.gzip</code> ，我们可以使用 <code>tar -xvf</code> 命令将这个 layer 解开。当我们使用 docker pull 命令拉取镜像的时候，也是去下载这个 <code>data</code>文件，下载完成之后会有一个 <code>docker-untar</code>的进程将这个 <code>data</code>文件解开存放在<code>/var/lib/docker/overlay2/${digest}/diff</code> 目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── [4.0K]  blobs</span><br><span class="line">│   └── [4.0K]  sha256</span><br><span class="line">│       ├── [4.0K]  aa</span><br><span class="line">│       │   └── [4.0K]  aaae33815489895f602207ac5a583422b8a8755b3f67fc6286ca9484ba685bdb</span><br><span class="line">│       │       └── [ 26M]  data</span><br></pre></td></tr></table></figure><h4 id="manifest-文件"><a href="#manifest-文件" class="headerlink" title="manifest 文件"></a>manifest 文件</h4><p>就是一个普通的 json 文件啦，记录了一个镜像所包含的 layer 信息，当我们 pull 镜像的时候会使用到这个文件。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2/blobs/sha256/b9/b9caca385021f231e15aee34929eac332c49402372a79808d07ee66866792239</span><br><span class="line">╰─# cat data</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"schemaVersion"</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.distribution.manifest.v2+json"</span>,</span><br><span class="line">   <span class="attr">"config"</span>: &#123;</span><br><span class="line">      <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.container.image.v1+json"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">1462</span>,</span><br><span class="line">      <span class="attr">"digest"</span>: <span class="string">"sha256:cfba37fd24f80f59e5d7c1f7735cae7a383e887d8cff7e2762fdd78c0d73568d"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"layers"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.image.rootfs.diff.tar.gzip"</span>,</span><br><span class="line">         <span class="attr">"size"</span>: <span class="number">27097859</span>,</span><br><span class="line">         <span class="attr">"digest"</span>: <span class="string">"sha256:aaae33815489895f602207ac5a583422b8a8755b3f67fc6286ca9484ba685bdb"</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;#</span><br></pre></td></tr></table></figure><h4 id="image-config-文件"><a href="#image-config-文件" class="headerlink" title="image config 文件"></a>image config 文件</h4><p>image config 文件里并没有包含镜像的 tag 信息。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2/blobs/sha256/e6/e6e782a57a51d01168907938beb5cd5af24fcb7ebed8f0b32c203137ace6d3df</span><br><span class="line">╰─# cat data | jq "."</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"architecture"</span>: <span class="string">"amd64"</span>,</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">    <span class="attr">"Hostname"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"Domainname"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"User"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"AttachStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"AttachStdout"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"AttachStderr"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"Tty"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"OpenStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"StdinOnce"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"Env"</span>: [</span><br><span class="line">      <span class="string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"Cmd"</span>: [</span><br><span class="line">      <span class="string">"bash"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"Image"</span>: <span class="string">"sha256:ba8f577813c7bdf6b737f638dffbc688aa1df2ff28a826a6c46bae722977b549"</span>,</span><br><span class="line">    <span class="attr">"Volumes"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"WorkingDir"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"Entrypoint"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"OnBuild"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"Labels"</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"container"</span>: <span class="string">"38501d5aa48c080884f4dc6fd4b1b6590ff1607d9e7a12e1cef1d86a3fdc32df"</span>,</span><br><span class="line">  <span class="attr">"container_config"</span>: &#123;</span><br><span class="line">    <span class="attr">"Hostname"</span>: <span class="string">"38501d5aa48c"</span>,</span><br><span class="line">    <span class="attr">"Domainname"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"User"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"AttachStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"AttachStdout"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"AttachStderr"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"Tty"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"OpenStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"StdinOnce"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"Env"</span>: [</span><br><span class="line">      <span class="string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"Cmd"</span>: [</span><br><span class="line">      <span class="string">"/bin/sh"</span>,</span><br><span class="line">      <span class="string">"-c"</span>,</span><br><span class="line">      <span class="string">"#(nop) "</span>,</span><br><span class="line">      <span class="string">"CMD [\"bash\"]"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"Image"</span>: <span class="string">"sha256:ba8f577813c7bdf6b737f638dffbc688aa1df2ff28a826a6c46bae722977b549"</span>,</span><br><span class="line">    <span class="attr">"Volumes"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"WorkingDir"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"Entrypoint"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"OnBuild"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"Labels"</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"created"</span>: <span class="string">"2020-06-07T01:59:47.348924716Z"</span>,</span><br><span class="line">  <span class="attr">"docker_version"</span>: <span class="string">"19.03.5"</span>,</span><br><span class="line">  <span class="attr">"history"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"created"</span>: <span class="string">"2020-06-07T01:59:46.877600299Z"</span>,</span><br><span class="line">      <span class="attr">"created_by"</span>: <span class="string">"/bin/sh -c #(nop) ADD file:a82014afc29e7b364ac95223b22ebafad46cc9318951a85027a49f9ce1a99461 in / "</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"created"</span>: <span class="string">"2020-06-07T01:59:47.348924716Z"</span>,</span><br><span class="line">      <span class="attr">"created_by"</span>: <span class="string">"/bin/sh -c #(nop)  CMD [\"bash\"]"</span>,</span><br><span class="line">      <span class="attr">"empty_layer"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"os"</span>: <span class="string">"linux"</span>,</span><br><span class="line">  <span class="attr">"rootfs"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"layers"</span>,</span><br><span class="line">    <span class="attr">"diff_ids"</span>: [</span><br><span class="line">      <span class="string">"sha256:d1b85e6186f67d9925c622a7a6e66faa447e767f90f65ae47cdc817c629fa956"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="uploads-文件夹"><a href="#uploads-文件夹" class="headerlink" title="_uploads 文件夹"></a>_uploads 文件夹</h4><p>_uploads 文件夹是个临时的文件夹，主要用来存放 push 镜像过程中的文件数据，当镜像 <code>layer</code> 上传完成之后会清空该文件夹。其中的 <code>data</code> 文件上传完毕后会移动到 <code>blobs</code> 目录下，根据该文件的 <code>sha256</code> 值来进行散列存储到相应的目录下。</p><p>上传过程中的目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_uploads</span><br><span class="line">├── [  53]  0d6c996e-638f-4436-b2b6-54fa7ad430d2</span><br><span class="line">│   ├── [198M]  data</span><br><span class="line">│   ├── [  20]  hashstates</span><br><span class="line">│   │   └── [  15]  sha256</span><br><span class="line">│   │       └── [ 108]  0</span><br><span class="line">│   └── [  20]  startedat</span><br><span class="line">└── [  53]  ba31818e-4217-47ef-ae46-2784c9222614</span><br><span class="line">    ├── [571M]  data</span><br><span class="line">    ├── [  20]  hashstates</span><br><span class="line">    │   └── [  15]  sha256</span><br><span class="line">    │       └── [ 108]  0</span><br><span class="line">    └── [  20]  startedat</span><br><span class="line"></span><br><span class="line">6 directories, 6 files</span><br></pre></td></tr></table></figure><ul><li>上传完镜像之后，<code>_uploads</code> 文件夹就会被清空，正常情况下这个文件夹是空的。但也有异常的时候😂，比如网络抖动导致上传意外中断，该文件夹就可能不为空。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_uploads</span><br><span class="line"></span><br><span class="line">0 directories, 0 files</span><br></pre></td></tr></table></figure><h4 id="manifests-文件夹"><a href="#manifests-文件夹" class="headerlink" title="_manifests 文件夹"></a>_manifests 文件夹</h4><p><code>_manifests</code> 文件夹是镜像上传完成之后由 registry 来生成的，并且该目录下的文件都是一个名为 <code>link</code>的文本文件，它的值指向 blobs 目录下与之对应的目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2/repositories/library</span><br><span class="line">╰─# find . -type f</span><br><span class="line">./debian/_layers/sha256/aaae33815489895f602207ac5a583422b8a8755b3f67fc6286ca9484ba685bdb/link</span><br><span class="line">./debian/_layers/sha256/e6e782a57a51d01168907938beb5cd5af24fcb7ebed8f0b32c203137ace6d3df/link</span><br><span class="line">./debian/_layers/sha256/cfba37fd24f80f59e5d7c1f7735cae7a383e887d8cff7e2762fdd78c0d73568d/link</span><br><span class="line">./debian/_manifests/tags/v2/current/link</span><br><span class="line">./debian/_manifests/tags/v2/index/sha256/c805f078bb47c575e9602b09af7568eb27fd1c92073199acba68c187bc5bcf11/link</span><br><span class="line">./debian/_manifests/tags/v1/current/link</span><br><span class="line">./debian/_manifests/tags/v1/index/sha256/b9caca385021f231e15aee34929eac332c49402372a79808d07ee66866792239/link</span><br><span class="line">./debian/_manifests/revisions/sha256/b9caca385021f231e15aee34929eac332c49402372a79808d07ee66866792239/link</span><br><span class="line">./debian/_manifests/revisions/sha256/c805f078bb47c575e9602b09af7568eb27fd1c92073199acba68c187bc5bcf11/link</span><br></pre></td></tr></table></figure><p><code>_manifests</code> 文件夹下包含着镜像的 <code>tags</code> 和 <code>revisions</code> 信息，每一个镜像的每一个 tag 对应着于 tag 名相同的目录。镜像的 tag 并不存储在 image config 中，而是以目录的形式来形成镜像的 tag，这一点比较奇妙，这和我们 Dockerfile 中并不包含镜像名和 tag 一个道理？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── [4.0K]  _layers</span><br><span class="line">│   └── [4.0K]  sha256</span><br><span class="line">│       ├── [4.0K]  aaae33815489895f602207ac5a583422b8a8755b3f67fc6286ca9484ba685bdb</span><br><span class="line">│       │   └── [  71]  link</span><br><span class="line">│       ├── [4.0K]  cfba37fd24f80f59e5d7c1f7735cae7a383e887d8cff7e2762fdd78c0d73568d</span><br><span class="line">│       │   └── [  71]  link</span><br><span class="line">│       └── [4.0K]  e6e782a57a51d01168907938beb5cd5af24fcb7ebed8f0b32c203137ace6d3df</span><br><span class="line">│           └── [  71]  link</span><br><span class="line">├── [4.0K]  _manifests</span><br><span class="line">│   ├── [4.0K]  revisions</span><br><span class="line">│   │   └── [4.0K]  sha256</span><br><span class="line">│   │       ├── [4.0K]  b9caca385021f231e15aee34929eac332c49402372a79808d07ee66866792239</span><br><span class="line">│   │       │   └── [  71]  link</span><br><span class="line">│   │       └── [4.0K]  c805f078bb47c575e9602b09af7568eb27fd1c92073199acba68c187bc5bcf11</span><br><span class="line">│   │           └── [  71]  link</span><br><span class="line">│   └── [4.0K]  tags</span><br><span class="line">│       ├── [4.0K]  v1</span><br><span class="line">│       │   ├── [4.0K]  current</span><br><span class="line">│       │   │   └── [  71]  link</span><br><span class="line">│       │   └── [4.0K]  index</span><br><span class="line">│       │       └── [4.0K]  sha256</span><br><span class="line">│       │           └── [4.0K]  b9caca385021f231e15aee34929eac332c49402372a79808d07ee66866792239</span><br><span class="line">│       │               └── [  71]  link</span><br><span class="line">│       └── [4.0K]  v2</span><br><span class="line">│           ├── [4.0K]  current</span><br><span class="line">│           │   └── [  71]  link</span><br><span class="line">│           └── [4.0K]  index</span><br><span class="line">│               └── [4.0K]  sha256</span><br><span class="line">│                   └── [4.0K]  c805f078bb47c575e9602b09af7568eb27fd1c92073199acba68c187bc5bcf11</span><br><span class="line">│                       └── [  71]  link</span><br><span class="line">└── [4.0K]  _uploads</span><br><span class="line"></span><br><span class="line">22 directories, 9 files</span><br></pre></td></tr></table></figure><h4 id="镜像的-tag"><a href="#镜像的-tag" class="headerlink" title="镜像的 tag"></a>镜像的 tag</h4><p> 每个 <code>tag</code>名目录下面有 <code>current</code> 目录和 <code>index</code> 目录， <code>current</code> 目录下的 link 文件保存了该 tag 目前的 manifest 文件的 sha256 编码，对应在 <code>blobs</code> 中的 <code>sha256</code> 目录下的 <code>data</code> 文件，而 <code>index</code> 目录则列出了该 <code>tag</code> 历史上传的所有版本的 <code>sha256</code> 编码信息。<code>_revisions</code> 目录里存放了该 <code>repository</code> 历史上上传版本的所有 sha256 编码信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2/repositories/library/debian/_manifests/tags/v1</span><br><span class="line">╰─# cat current/link</span><br><span class="line">sha256:b9caca385021f231e15aee34929eac332c49402372a79808d07ee66866792239</span><br><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2/blobs/sha256</span><br><span class="line">╰─# tree -h</span><br><span class="line">.</span><br><span class="line">├── [4.0K]  aa</span><br><span class="line">│   └── [4.0K]  aaae33815489895f602207ac5a583422b8a8755b3f67fc6286ca9484ba685bdb</span><br><span class="line">│       └── [ 26M]  data</span><br><span class="line">├── [4.0K]  b9</span><br><span class="line">│   └── [4.0K]  b9caca385021f231e15aee34929eac332c49402372a79808d07ee66866792239</span><br><span class="line">│       └── [ 529]  data</span><br></pre></td></tr></table></figure><p>当我们 <code>pull</code> 镜像的时候如果不指定镜像的 <code>tag</code>名，默认就是 latest，registry 会从 HTTP 请求中解析到这个 tag 名，然后根据 tag 名目录下的 link 文件找到该镜像的 manifest 的位置返回给客户端，客户端接着去请求这个 manifest 文件，客户端根据这个 manifest 文件来 pull 相应的镜像 layer 。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/registry/docker/registry/v2/repositories/library/debian/_manifests/tags/v1</span><br><span class="line">╰─# cat  /var/lib/registry/docker/registry/v2/blobs/sha256/b9/b9caca385021f231e15aee34929eac332c49402372a79808d07ee66866792239/data</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"schemaVersion"</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.distribution.manifest.v2+json"</span>,</span><br><span class="line">   <span class="attr">"config"</span>: &#123;</span><br><span class="line">      <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.container.image.v1+json"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">1462</span>,</span><br><span class="line">      <span class="attr">"digest"</span>: <span class="string">"sha256:cfba37fd24f80f59e5d7c1f7735cae7a383e887d8cff7e2762fdd78c0d73568d"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"layers"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"mediaType"</span>: <span class="string">"application/vnd.docker.image.rootfs.diff.tar.gzip"</span>,</span><br><span class="line">         <span class="attr">"size"</span>: <span class="number">27097859</span>,</span><br><span class="line">         <span class="attr">"digest"</span>: <span class="string">"sha256:aaae33815489895f602207ac5a583422b8a8755b3f67fc6286ca9484ba685bdb"</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再补充一点就是，同一个镜像在 registry 中存储的位置是相同的，具体的分析可以参考 <a href="https://supereagle.github.io/2018/04/24/docker-registry/" target="_blank" rel="noopener">镜像仓库中镜像存储的原理解析</a> 这篇博客。</p><blockquote><ul><li>通过 Registry API 获得的两个镜像仓库中相同镜像的 manifest 信息完全相同。</li><li>两个镜像仓库中相同镜像的 manifest 信息的存储路径和内容完全相同。</li><li>两个镜像仓库中相同镜像的 blob 信息的存储路径和内容完全相同。</li></ul></blockquote><p>从上面这三个结论中我们可以推断出 registry 存储目录里并不会存储与该 registry 相关的信息，比我们 push 镜像的时候需要给镜像加上 <code>localhost:5000</code> 这个前缀，这个前缀并不会存储在 registry 存储中。加入我要迁移一个很大的 registry 镜像仓库，镜像的数量在 5k 以上。最便捷的办法就是打包这个 registry 存储目录，将这个 tar 包 rsync 到另一台机器即可。需要强调一点，打包 registry 存储目录的时候不需要进行压缩，直接 <code>tar -cvf</code> 即可。因为 registry 存储的镜像 layer 已经是个 <code>tar.gzip</code> 格式的文件，再进行压缩的话效果甚微而且还浪费 CPU 时间得不偿失。</p><h3 id="docker-archive"><a href="#docker-archive" class="headerlink" title="docker-archive"></a>docker-archive</h3><p>本来我想着 docker save 出来的并不是一个镜像，而是一个 <code>.tar</code> 文件，但我想了又想，还是觉着它是一个镜像，只不过存在的方式不同而已。于在 docker 和 registry 中存放的方式不同，使用 docker save 出来的镜像是一个孤立的存在。就像是从蛋糕店里拿出来的蛋糕，外面肯定要有个精美的包装是吧，你总没见过。放在哪里都可以，使用的时候我们使用 docker load 拆开外包装(<code>.tar</code>)就可。比如我们离线部署 harbor 的时候就是使用官方的镜像 tar 包来进行加载镜像启动容器的。</p><h2 id="镜像是怎么食用的😋"><a href="#镜像是怎么食用的😋" class="headerlink" title="镜像是怎么食用的😋"></a>镜像是怎么食用的😋</h2><p>当我们拿到一个镜像之后，如果用它来启动一个容器呢？这里就涉及到了 OCI 规范中的另一个规范即运行时规范 <a href="https://github.com/opencontainers/runtime-spec" target="_blank" rel="noopener">runtime-spec</a> 。容器运行时通过一个叫 <a href="https://github.com/opencontainers/runtime-spec/blob/master/bundle.md" target="_blank" rel="noopener"> OCI runtime filesytem bundle</a> 的标准格式将 OCI 镜像通过工具转换为 bundle ，然后 OCI 容器引擎能够识别这个 bundle 来运行容器。</p><blockquote><p>filesystem bundle 是个目录，用于给 runtime 提供启动容器必备的配置文件和文件系统。标准的容器 bundle 包含以下内容：</p><ul><li>config.json: 该文件包含了容器运行的配置信息，该文件必须存在 bundle 的根目录，且名字必须为 config.json</li><li>容器的根目录，可以由 config.json 中的 root.path 指定</li></ul></blockquote><p><img src="img/20200609_oci-04.jpg" alt="img"></p><h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h3><p>当我们启动一个容器之后我们使用 tree 命令来分析一下 overlay2 就会发现，较之前的目录，容器启动之后 overlay2 目录下多了一个 <code>merged</code> 的文件夹，该文件夹就是容器内看到的。docker 通过 overlayfs 联合挂载的技术将镜像的多层 layer 挂载为一层，这层的内容就是容器里所看到的，也就是 merged 文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">╭─root@sg-02 /var/lib/docker</span><br><span class="line">╰─# tree overlay2 -d -L 3</span><br><span class="line">overlay2</span><br><span class="line">├── 259cf6934509a674b1158f0a6c90c60c133fd11189f98945c7c3a524784509ff</span><br><span class="line">│   └── diff</span><br><span class="line">│       ├── bin</span><br><span class="line">|</span><br><span class="line">│       └── var</span><br><span class="line">├── 27f9e9b74a88a269121b4e77330a665d6cca4719cb9a58bfc96a2b88a07af805</span><br><span class="line">│   ├── diff</span><br><span class="line">│   └── work</span><br><span class="line">├── 5f85c914c55220ec2635bce0080d2ad677f739dcfac4fd266b773625e3051844</span><br><span class="line">│   ├── diff</span><br><span class="line">│   │   └── var</span><br><span class="line">│   ├── merged</span><br><span class="line">│   │   ├── bin</span><br><span class="line">│   │   ├── dev</span><br><span class="line">│   │   ├── etc</span><br><span class="line">│   │   ├── home</span><br><span class="line">│   │   ├── lib</span><br><span class="line">│   │   ├── media</span><br><span class="line">│   │   ├── mnt</span><br><span class="line">│   │   ├── proc</span><br><span class="line">│   │   ├── root</span><br><span class="line">│   │   ├── run</span><br><span class="line">│   │   ├── sbin</span><br><span class="line">│   │   ├── srv</span><br><span class="line">│   │   ├── sys</span><br><span class="line">│   │   ├── tmp</span><br><span class="line">│   │   ├── usr</span><br><span class="line">│   │   └── var</span><br><span class="line">│   └── work</span><br><span class="line">│       └── work</span><br><span class="line">├── 5f85c914c55220ec2635bce0080d2ad677f739dcfac4fd266b773625e3051844-init</span><br><span class="line">│   ├── diff</span><br><span class="line">│   │   ├── dev</span><br><span class="line">│   │   └── etc</span><br><span class="line">│   └── work</span><br><span class="line">│       └── work</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">overlay on / type overlay (rw,relatime,lowerdir=/opt/docker/overlay2/l/4EPD2X5VF62FH5PZOZHZDKAKGL:/opt/docker/overlay2/l/MYRYBGZRI4I76MJWQHN7VLZXLW:/opt/docker/overlay2/l/5RZOXYR35NSGAWTI36CVUIRW7U:/opt/docker/overlay2/l/LBWRL4ZXGBWOTN5JDCDZVNOY7H:/opt/docker/overlay2/l/526XCHXRJMZXRIHN4YWJH2QLPY:/opt/docker/overlay2/l/XK5IA4BWQ2CIS667J3SXPXGQK5,upperdir=/opt/docker/overlay2/f913d81219134e23eb0827a1c27668494dfaea2f1b5d1d0c70382366eabed629/diff,workdir=/opt/docker/overlay2/f913d81219134e23eb0827a1c27668494dfaea2f1b5d1d0c70382366eabed629/work)</span><br></pre></td></tr></table></figure><p>从 docker 官方文档 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/" target="_blank" rel="noopener">Use the OverlayFS storage driver</a> 里偷来的一张图片</p><p><img src="img/overlay_constructs.jpg" alt="overlayfs lowerdir, upperdir, merged"></p><p>关于上图中这些 Dir 的作用，下面是一段从 <a href="https://stackoverflow.com/questions/56550890/docker-image-merged-diff-work-lowerdir-components-of-graphdriver" target="_blank" rel="noopener">StackOverflow</a> 上搬运过来的解释。</p><blockquote><p><strong>LowerDir</strong>: these are the read-only layers of an overlay filesystem. For docker, these are the image layers assembled in order.</p><p><strong>UpperDir</strong>: this is the read-write layer of an overlay filesystem. For docker, that is the equivalent of the container specific layer that contains changes made by that container.</p><p><strong>WorkDir</strong>: this is a required directory for overlay, it needs an empty directory for internal use.</p><p><strong>MergedDir</strong>: this is the result of the overlay filesystem. Docker effectively chroot’s into this directory when running the container.</p></blockquote><p>如果想对 overlayfs 文件系统有详细的了解，可以参考 Linux 内核官网上的这篇文档 <a href="https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt" target="_blank" rel="noopener">overlayfs.txt</a> 。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><ul><li><a href="https://docs.docker.com/develop/develop-images/baseimages/" target="_blank" rel="noopener">Create a base image</a></li><li><a href="https://hub.docker.com/_/scratch" target="_blank" rel="noopener">FROM scratch</a></li><li><a href="https://docs.docker.com/registry/" target="_blank" rel="noopener">Docker Registry</a></li><li><a href="https://github.com/docker/distribution/blob/master/docs/spec/manifest-v2-2.md" target="_blank" rel="noopener">Image Manifest Version 2, Schema 2</a></li><li><a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="noopener">Docker Registry HTTP API V2</a></li><li><a href="https://github.com/containers/image" target="_blank" rel="noopener">image</a></li><li><a href="https://github.com/opencontainers/image-spec" target="_blank" rel="noopener">OCI Image Manifest Specification</a></li><li><a href="https://github.com/opencontainers/distribution-spec" target="_blank" rel="noopener">distribution-spec</a></li><li><a href="https://doi-janky.infosiftr.net/job/tianon/job/debuerreotype/" target="_blank" rel="noopener">debuerreotype/</a></li><li><a href="https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt" target="_blank" rel="noopener">overlayfs.txt</a></li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ul><li><a href="https://github.com/docker-library/oi-janky-groovy" target="_blank" rel="noopener">oi-janky-groovy</a></li><li><a href="https://github.com/debuerreotype/docker-debian-artifacts" target="_blank" rel="noopener">docker-debian-artifacts</a></li><li><a href="https://github.com/NotGlop/docker-drag" target="_blank" rel="noopener">docker-drag</a></li><li><a href="https://github.com/deislabs/oras" target="_blank" rel="noopener">oras</a></li><li><a href="https://github.com/containers/skopeo" target="_blank" rel="noopener">skopeo</a></li><li><a href="https://github.com/vbatts/tar-split" target="_blank" rel="noopener">tar-split</a></li></ul><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><ul><li><a href="https://supereagle.github.io/2018/04/24/docker-registry/" target="_blank" rel="noopener">镜像仓库中镜像存储的原理解析</a></li><li><a href="https://fuckcloudnative.io/posts/how-manage-image/" target="_blank" rel="noopener">docker 在本地如何管理 image（镜像）?</a></li><li><a href="http://gaocegege.com/Blog/ormb" target="_blank" rel="noopener">ormb：像管理 Docker 容器镜像一样管理机器学习模型</a></li><li><a href="https://blog.fleeto.us/post/how-are-docker-images-built/" target="_blank" rel="noopener">镜像是怎样炼成的</a></li><li><a href="https://duyanghao.github.io/docker-registry-pull-manifest-v2/" target="_blank" rel="noopener">docker pull分析</a></li><li><a href="https://github.com/helios741/myblog/blob/new/learn_go/src/2019/20191206_docker_disk_storage/README.md" target="_blank" rel="noopener">浅谈docker中镜像和容器在本地的存储</a></li><li><a href="https://www.qedev.com/cloud/103860.html" target="_blank" rel="noopener">容器OCI规范 镜像规范</a></li><li><a href="https://xuanwo.io/2019/08/06/oci-intro/" target="_blank" rel="noopener">开放容器标准(OCI) 内部分享</a></li><li><a href="https://wilhelmguo.cn/blog/post/william/%E5%AE%B9%E5%99%A8%E5%BC%80%E6%94%BE%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83%EF%BC%88CRI-OCI%EF%BC%89-2" target="_blank" rel="noopener">容器开放接口规范（CRI OCI）</a></li><li><a href="https://segmentfault.com/a/1190000014284289" target="_blank" rel="noopener">Docker镜像的存储机制</a></li><li><a href="http://open.daocloud.io/docker-source-code-analysis-part10/" target="_blank" rel="noopener">Docker源码分析（十）：Docker镜像下载</a></li><li><a href="http://open.daocloud.io/docker-source-code-analysis-part9/" target="_blank" rel="noopener">Docker源码分析（九）：Docker镜像</a></li><li><a href="https://www.twblogs.net/a/5b8aab392b71775d1ce86eca" target="_blank" rel="noopener">docker push 過程 distribution源碼 分析</a></li><li><a href="http://open.daocloud.io/tag/allen-tan-docker/" target="_blank" rel="noopener">Allen 谈 Docker</a></li><li><a href="http://open.daocloud.io/shen-ru-li-jie-dockerjing-xiang-jsonwen-jian-2/" target="_blank" rel="noopener">深入理解 Docker 镜像 json 文件</a></li><li><a href="http://open.daocloud.io/docker-jing-xiang-nei-you-sha-cun-na-ntitled/" target="_blank" rel="noopener">Docker 镜像内有啥，存哪？</a></li><li><a href="http://open.daocloud.io/allen-tan-docker-xi-lie-zhi-shen-ke-li-jie-docker-jing-xiang-da-xiao/" target="_blank" rel="noopener">理解 Docker 镜像大小</a></li><li><a href="http://open.daocloud.io/allen-tan-docker-xi-lie-zhi-tu-kan-jin-docker-rong-qi-wen-jian-xi-tong/" target="_blank" rel="noopener">看尽 docker 容器文件系统</a></li><li><a href="https://qhh.me/2019/02/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Docker-%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87/" target="_blank" rel="noopener">深入理解 Docker 构建上下文</a></li><li><a href="https://cizixs.com/2017/11/05/oci-and-runc/" target="_blank" rel="noopener">OCI 和 runc：容器标准化和 docker</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;上周在写&lt;a
        
      
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.k8s.li/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="https://blog.k8s.li/tags/docker/"/>
    
      <category term="registry" scheme="https://blog.k8s.li/tags/registry/"/>
    
      <category term="image" scheme="https://blog.k8s.li/tags/image/"/>
    
  </entry>
  
  <entry>
    <title>mount 命令之 --bind 挂载参数</title>
    <link href="https://blog.k8s.li/mount-bind.html"/>
    <id>https://blog.k8s.li/mount-bind.html</id>
    <published>2020-06-01T16:00:00.000Z</published>
    <updated>2021-02-24T13:40:34.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="翻车（："><a href="#翻车（：" class="headerlink" title="翻车（："></a>翻车（：</h2><p>由于我的 VPS 不是大盘鸡(就是大容量磁盘机器啦😂)， docker 存储目录 <code>/var/lib/docker</code> 所在的分区严重不足，于是就想着在不改变 docker 配置的下将 <code>/opt</code> 目录下的分区分配给 <code>/var/lib/docker</code> 目录。首先想到的是把 <code>/var/lib/docker</code> 复制到 <code>/opt/docker</code>，然后再将 <code>/opt/docker</code> 软链接到 <code>/var/lib/docker</code> 。</p><p>于是我就一顿操作猛如虎，<code>mv /var/lib/docker /opt/docker &amp;&amp; ln -s /opt/docker /var/lib/docker</code> 一把梭，然后我启动一个容器的时候当场就翻车了🤣。</p><p>原来有些程序是不支持软链接目录的，还有一点就是软链接的路径也有点坑。比如我将 <code>/opt/docker -&gt; /var/lib/docker/</code> ，在 <code>/var/lib/docker</code> 目录下执行 <code>ls ../</code> 即它的上一级目录是 <code>/opt</code> 而不是 <code>/var/lib</code> ，对于一些依赖相对路径的应用（尤其是 shell 脚本）来讲这样使用软链接的方式也容易翻车😂。</p><p>那么有没有一种更好的办法将两个目录进行“硬链接”呢，注意我在此用的是双引号，并非是真正的”硬链接“，搜了一圈发现 mount –bind 这种骚操作。无论我们对文件使用软链接/硬链接/bind，还是对目录使用软链接，其实都是希望操作的 <code>src</code> 和 <code>dest</code> 他们二者都能保持一致。通过 bind 挂载的方式具有着挂载点的一些特性，这是链接是不具有的，对一些不支持链接的应用来讲，bind 的方式要友好一些。</p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>其实 bind 这个挂载选项我们在使用 docker 或者 kubernetes 多少都会用到的，尤其是当使用 kubernetes  时 kubelet 在启动容器挂载存储的时候底层是将 node 节点本机的 <code>/var/lib/kubelet/pods/&lt;Pod的ID&gt;/volumes/kubernetes.io~&lt;Volume类型&gt;/&lt;Volume名字&gt;</code> 目录通过 bind 的方式挂载到容器中的，详细的分析可以参考之前我写的一篇博客 <a href="https://blog.k8s.li/kubelet-mount-volumes-analysis.html">kubelet 挂载 volume 原理分析</a> 。</p><blockquote><ul><li><strong>Volumes</strong> are stored in a part of the host filesystem which is <em>managed by Docker</em> (<code>/var/lib/docker/volumes/</code> on Linux). Non-Docker processes should not modify this part of the filesystem. Volumes are the best way to persist data in Docker.</li><li><strong>Bind mounts</strong> may be stored <em>anywhere</em> on the host system. They may even be important system files or directories. Non-Docker processes on the Docker host or a Docker container can modify them at any time.</li><li><strong><code>tmpfs</code> mounts</strong> are stored in the host system’s memory only, and are never written to the host system’s filesystem.</li></ul></blockquote><p>不过那时候并没有详细地去了解 bind 的原理，直到最近翻了一次车才想起来 bind ，于是接下来就详细地分析以下 mount –bind 挂载参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用软链接链接目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls -i 显示文件/目录的 inode 号</span></span><br><span class="line">╭─root@sg-02 /var/lib</span><br><span class="line">╰─# ln -s /opt/docker /var/lib/docker</span><br><span class="line">╭─root@sg-02 /var/lib</span><br><span class="line">╰─# ls -i /opt | grep docker</span><br><span class="line">2304916 docker</span><br><span class="line">╭─root@sg-02 /var/lib</span><br><span class="line">╰─# ls -i /var/lib | grep docker</span><br><span class="line">    211 docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用硬链接链接两个文件</span></span><br><span class="line">╭─root@sg-02 /var/lib</span><br><span class="line">╰─# ln /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br><span class="line">╭─root@sg-02 /var/lib</span><br><span class="line">╰─# ls -i /usr/bin/docker-compose</span><br><span class="line">112 /usr/bin/docker-compose</span><br><span class="line">╭─root@sg-02 /var/lib</span><br><span class="line">╰─# ls -i /usr/bin/docker-compose</span><br><span class="line">112 /usr/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 --<span class="built_in">bind</span> 挂载目录</span></span><br><span class="line">╭─root@sg-02 /var/lib</span><br><span class="line">╰─# mount --bind /opt/docker /var/lib/docker</span><br><span class="line">╭─root@sg-02 /var/lib</span><br><span class="line">╰─# ls -i /var/lib | grep docker</span><br><span class="line">2304916 docker</span><br><span class="line">╭─root@sg-02 /var/lib</span><br><span class="line">╰─# ls -i /opt | grep docker</span><br><span class="line">2304916 docker</span><br></pre></td></tr></table></figure><p>我们可以看到当使用使用硬链接或 bind 挂载目录时，两个文件 inode 号是相同的，使用软链接的两个文件的 inode 号是不同的。但目录又不能使用硬链接，而且硬链接不支持跨分区。我们是否可以将 bind 的效果和<br>“硬链接目录“ 样来使用呢？其实可以这样用，但这样类比并不严谨。</p><p>当我们使用 bind 的时候，是将一个目录 A  挂载到另一个目录 B ，目录 B 原有的内容就被屏”蔽掉“了，目录 B 里面的内容就是目录 A 里面的内容。这和我们挂在其他分区到挂载点目录一样，目录 B 的内容还是存在的，只不过是被”屏蔽“掉了，当我们 umount B 后，原内容就会复现。</p><p>当我们使用 <code>docker run -v PATH:PATH</code> 启动一个容器的时候，实质上也是会用到 <code>bind</code>，docker 会将主机的目录通过 <code>bind</code> 的方式挂载到容器目录。下面我们启动一个 alpine 容器来实验一下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name alpine -v /opt/bind/:/var --privileged --rm -it alpine sh</span><br><span class="line">docker inspect alpine</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"Mounts": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Type"</span>: <span class="string">"bind"</span>,</span><br><span class="line">        <span class="attr">"Source"</span>: <span class="string">"/opt/bind"</span>,</span><br><span class="line">        <span class="attr">"Destination"</span>: <span class="string">"/var"</span>,</span><br><span class="line">        <span class="attr">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"Propagation"</span>: <span class="string">"rprivate"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在容器内使用 umount 命令卸载掉 <code>/var</code> ，umount 操作需要 root 权限，这也是为什么要在容器启动的时候加上 <code>--privileged</code> 参数来启动一个特权容器的原因。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ # ls /var/</span><br><span class="line">74898710_p21.jpg    MJSTEALEY.md        docker-compose.yml  letsencrypt         resolv.conf</span><br><span class="line">CONSOLE.md          README.md           hostname            logs                stop-and-remove.sh</span><br><span class="line">LICENSE             config              hosts               nginx               webp-server</span><br><span class="line">/ # umount /var/</span><br><span class="line"><span class="meta">#</span><span class="bash"> umount 之后容器内原来的 /var 目录内容<span class="string">"恢复"</span>了</span></span><br><span class="line">/ # ls /var/</span><br><span class="line">cache  empty  lib    local  lock   log    mail   opt    run    spool  tmp</span><br></pre></td></tr></table></figure><h2 id="其他用处🤔"><a href="#其他用处🤔" class="headerlink" title="其他用处🤔"></a>其他用处🤔</h2><h3 id="无缝更新-Webp-Server-Go"><a href="#无缝更新-Webp-Server-Go" class="headerlink" title="无缝更新 Webp Server Go"></a>无缝更新 Webp Server Go</h3><p>在 <a href="">小土豆</a>、<a href="">Nona</a> 大佬讨论 <a href="">Webp Server Go</a> 无缝更新的时候我们提出了一个思路：</p><blockquote><ul><li><p>在更新之前先对 nginx 配置文件进行修改，去掉 webp server 的 location 字段：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* \.(png|jpg|jpeg)$</span> &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:3333;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> HOST <span class="variable">$http_host</span>;</span><br><span class="line">    <span class="attribute">add_header</span> Cache-Control <span class="string">'no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后再 nginx -s reload 不中断 reload 一</p></li><li><p>接着停掉 webp server 服务 <code>systemctl stop webps</code></p></li><li><p>mv webp-server{.bak,}</p></li><li><p>mv ./upload/webp-server-linux-amd64 webp-server</p></li><li><p>接着启动 webp server 服务 <code>systemctl start webps</code></p></li><li><p>然后开倒车把 nginx 配置文件再改回去🍞</p></li></ul></blockquote><p>在此需要提几点，我们希望<strong>无缝更新</strong>，即在更新的过程中不会导致用户请求图片资源失败，那怕 <code>+1s</code>都不行，所以我们需要暂时性地在 nginx 配置文件里去掉 webp server ，使它去请求原图片，等更新完 webp server 之后再添加上去。</p><p>对于木子这种经常删库跑路的手残菜鸟来讲，对一个配置文件改来改去不是好方法，万一 nginx 配置文件改来改去没改好， nginx -s reload 一下 nginx 服务就炸了😂。那么使用 cp 和 mv 怎么样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cp blog.conf&#123;,.bak&#125;</span><br><span class="line">vim blog.conf</span><br><span class="line">nginx -s reload</span><br><span class="line">- update webp server</span><br><span class="line">mv blog.conf&#123;,.bak2&#125;</span><br><span class="line">mv blog.conf&#123;.bak,&#125;</span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>使用 bind 呢？好像少了一步，下次更新 webp server 的时候只需要 umount 一下，更新完之后再 mount 一下就可以啦。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cp blog.conf&#123;,.bak&#125;</span><br><span class="line">vim blog.conf</span><br><span class="line">nginx -s reload</span><br><span class="line">- update webp server</span><br><span class="line">mount --bind blog.conf.bak blohg.conf</span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="VPS-搬家助手"><a href="#VPS-搬家助手" class="headerlink" title="VPS 搬家助手"></a>VPS 搬家助手</h3><p>其实还有很多用途啦，这里就不罗列了</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;翻车（：&quot;&gt;&lt;a href=&quot;#翻车（：&quot;
        
      
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.k8s.li/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="https://blog.k8s.li/tags/docker/"/>
    
      <category term="linux" scheme="https://blog.k8s.li/tags/linux/"/>
    
      <category term="overlay2" scheme="https://blog.k8s.li/tags/overlay2/"/>
    
  </entry>
  
</feed>
